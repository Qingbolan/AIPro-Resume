// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"silan-backend/internal/ent/award"
	"silan-backend/internal/ent/awardtranslation"
	"silan-backend/internal/ent/blogcategory"
	"silan-backend/internal/ent/blogcategorytranslation"
	"silan-backend/internal/ent/blogcomment"
	"silan-backend/internal/ent/blogpost"
	"silan-backend/internal/ent/blogposttag"
	"silan-backend/internal/ent/blogposttranslation"
	"silan-backend/internal/ent/blogseries"
	"silan-backend/internal/ent/blogseriestranslation"
	"silan-backend/internal/ent/blogtag"
	"silan-backend/internal/ent/education"
	"silan-backend/internal/ent/educationdetail"
	"silan-backend/internal/ent/educationdetailtranslation"
	"silan-backend/internal/ent/educationtranslation"
	"silan-backend/internal/ent/idea"
	"silan-backend/internal/ent/ideatranslation"
	"silan-backend/internal/ent/language"
	"silan-backend/internal/ent/personalinfo"
	"silan-backend/internal/ent/personalinfotranslation"
	"silan-backend/internal/ent/predicate"
	"silan-backend/internal/ent/project"
	"silan-backend/internal/ent/projectdetail"
	"silan-backend/internal/ent/projectdetailtranslation"
	"silan-backend/internal/ent/projectimage"
	"silan-backend/internal/ent/projectimagetranslation"
	"silan-backend/internal/ent/projectrelationship"
	"silan-backend/internal/ent/projecttechnology"
	"silan-backend/internal/ent/projecttranslation"
	"silan-backend/internal/ent/publication"
	"silan-backend/internal/ent/publicationauthor"
	"silan-backend/internal/ent/publicationtranslation"
	"silan-backend/internal/ent/recentupdate"
	"silan-backend/internal/ent/recentupdatetranslation"
	"silan-backend/internal/ent/researchproject"
	"silan-backend/internal/ent/researchprojectdetail"
	"silan-backend/internal/ent/researchprojectdetailtranslation"
	"silan-backend/internal/ent/researchprojecttranslation"
	"silan-backend/internal/ent/sociallink"
	"silan-backend/internal/ent/user"
	"silan-backend/internal/ent/workexperience"
	"silan-backend/internal/ent/workexperiencedetail"
	"silan-backend/internal/ent/workexperiencedetailtranslation"
	"silan-backend/internal/ent/workexperiencetranslation"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAward                            = "Award"
	TypeAwardTranslation                 = "AwardTranslation"
	TypeBlogCategory                     = "BlogCategory"
	TypeBlogCategoryTranslation          = "BlogCategoryTranslation"
	TypeBlogComment                      = "BlogComment"
	TypeBlogPost                         = "BlogPost"
	TypeBlogPostTag                      = "BlogPostTag"
	TypeBlogPostTranslation              = "BlogPostTranslation"
	TypeBlogSeries                       = "BlogSeries"
	TypeBlogSeriesTranslation            = "BlogSeriesTranslation"
	TypeBlogTag                          = "BlogTag"
	TypeEducation                        = "Education"
	TypeEducationDetail                  = "EducationDetail"
	TypeEducationDetailTranslation       = "EducationDetailTranslation"
	TypeEducationTranslation             = "EducationTranslation"
	TypeIdea                             = "Idea"
	TypeIdeaTranslation                  = "IdeaTranslation"
	TypeLanguage                         = "Language"
	TypePersonalInfo                     = "PersonalInfo"
	TypePersonalInfoTranslation          = "PersonalInfoTranslation"
	TypeProject                          = "Project"
	TypeProjectDetail                    = "ProjectDetail"
	TypeProjectDetailTranslation         = "ProjectDetailTranslation"
	TypeProjectImage                     = "ProjectImage"
	TypeProjectImageTranslation          = "ProjectImageTranslation"
	TypeProjectRelationship              = "ProjectRelationship"
	TypeProjectTechnology                = "ProjectTechnology"
	TypeProjectTranslation               = "ProjectTranslation"
	TypePublication                      = "Publication"
	TypePublicationAuthor                = "PublicationAuthor"
	TypePublicationTranslation           = "PublicationTranslation"
	TypeRecentUpdate                     = "RecentUpdate"
	TypeRecentUpdateTranslation          = "RecentUpdateTranslation"
	TypeResearchProject                  = "ResearchProject"
	TypeResearchProjectDetail            = "ResearchProjectDetail"
	TypeResearchProjectDetailTranslation = "ResearchProjectDetailTranslation"
	TypeResearchProjectTranslation       = "ResearchProjectTranslation"
	TypeSocialLink                       = "SocialLink"
	TypeUser                             = "User"
	TypeWorkExperience                   = "WorkExperience"
	TypeWorkExperienceDetail             = "WorkExperienceDetail"
	TypeWorkExperienceDetailTranslation  = "WorkExperienceDetailTranslation"
	TypeWorkExperienceTranslation        = "WorkExperienceTranslation"
)

// AwardMutation represents an operation that mutates the Award nodes in the graph.
type AwardMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	title                 *string
	awarding_organization *string
	award_date            *time.Time
	award_type            *string
	amount                *float64
	addamount             *float64
	description           *string
	certificate_url       *string
	sort_order            *int
	addsort_order         *int
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	translations          map[uuid.UUID]struct{}
	removedtranslations   map[uuid.UUID]struct{}
	clearedtranslations   bool
	done                  bool
	oldValue              func(context.Context) (*Award, error)
	predicates            []predicate.Award
}

var _ ent.Mutation = (*AwardMutation)(nil)

// awardOption allows management of the mutation configuration using functional options.
type awardOption func(*AwardMutation)

// newAwardMutation creates new mutation for the Award entity.
func newAwardMutation(c config, op Op, opts ...awardOption) *AwardMutation {
	m := &AwardMutation{
		config:        c,
		op:            op,
		typ:           TypeAward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAwardID sets the ID field of the mutation.
func withAwardID(id uuid.UUID) awardOption {
	return func(m *AwardMutation) {
		var (
			err   error
			once  sync.Once
			value *Award
		)
		m.oldValue = func(ctx context.Context) (*Award, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Award.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAward sets the old Award of the mutation.
func withAward(node *Award) awardOption {
	return func(m *AwardMutation) {
		m.oldValue = func(context.Context) (*Award, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AwardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AwardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Award entities.
func (m *AwardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AwardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AwardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Award.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AwardMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AwardMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AwardMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *AwardMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AwardMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AwardMutation) ResetTitle() {
	m.title = nil
}

// SetAwardingOrganization sets the "awarding_organization" field.
func (m *AwardMutation) SetAwardingOrganization(s string) {
	m.awarding_organization = &s
}

// AwardingOrganization returns the value of the "awarding_organization" field in the mutation.
func (m *AwardMutation) AwardingOrganization() (r string, exists bool) {
	v := m.awarding_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardingOrganization returns the old "awarding_organization" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAwardingOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardingOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardingOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardingOrganization: %w", err)
	}
	return oldValue.AwardingOrganization, nil
}

// ResetAwardingOrganization resets all changes to the "awarding_organization" field.
func (m *AwardMutation) ResetAwardingOrganization() {
	m.awarding_organization = nil
}

// SetAwardDate sets the "award_date" field.
func (m *AwardMutation) SetAwardDate(t time.Time) {
	m.award_date = &t
}

// AwardDate returns the value of the "award_date" field in the mutation.
func (m *AwardMutation) AwardDate() (r time.Time, exists bool) {
	v := m.award_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardDate returns the old "award_date" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAwardDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardDate: %w", err)
	}
	return oldValue.AwardDate, nil
}

// ClearAwardDate clears the value of the "award_date" field.
func (m *AwardMutation) ClearAwardDate() {
	m.award_date = nil
	m.clearedFields[award.FieldAwardDate] = struct{}{}
}

// AwardDateCleared returns if the "award_date" field was cleared in this mutation.
func (m *AwardMutation) AwardDateCleared() bool {
	_, ok := m.clearedFields[award.FieldAwardDate]
	return ok
}

// ResetAwardDate resets all changes to the "award_date" field.
func (m *AwardMutation) ResetAwardDate() {
	m.award_date = nil
	delete(m.clearedFields, award.FieldAwardDate)
}

// SetAwardType sets the "award_type" field.
func (m *AwardMutation) SetAwardType(s string) {
	m.award_type = &s
}

// AwardType returns the value of the "award_type" field in the mutation.
func (m *AwardMutation) AwardType() (r string, exists bool) {
	v := m.award_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardType returns the old "award_type" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAwardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardType: %w", err)
	}
	return oldValue.AwardType, nil
}

// ClearAwardType clears the value of the "award_type" field.
func (m *AwardMutation) ClearAwardType() {
	m.award_type = nil
	m.clearedFields[award.FieldAwardType] = struct{}{}
}

// AwardTypeCleared returns if the "award_type" field was cleared in this mutation.
func (m *AwardMutation) AwardTypeCleared() bool {
	_, ok := m.clearedFields[award.FieldAwardType]
	return ok
}

// ResetAwardType resets all changes to the "award_type" field.
func (m *AwardMutation) ResetAwardType() {
	m.award_type = nil
	delete(m.clearedFields, award.FieldAwardType)
}

// SetAmount sets the "amount" field.
func (m *AwardMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AwardMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AwardMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AwardMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *AwardMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[award.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *AwardMutation) AmountCleared() bool {
	_, ok := m.clearedFields[award.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *AwardMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, award.FieldAmount)
}

// SetDescription sets the "description" field.
func (m *AwardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AwardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AwardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[award.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AwardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[award.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AwardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, award.FieldDescription)
}

// SetCertificateURL sets the "certificate_url" field.
func (m *AwardMutation) SetCertificateURL(s string) {
	m.certificate_url = &s
}

// CertificateURL returns the value of the "certificate_url" field in the mutation.
func (m *AwardMutation) CertificateURL() (r string, exists bool) {
	v := m.certificate_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateURL returns the old "certificate_url" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldCertificateURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateURL: %w", err)
	}
	return oldValue.CertificateURL, nil
}

// ClearCertificateURL clears the value of the "certificate_url" field.
func (m *AwardMutation) ClearCertificateURL() {
	m.certificate_url = nil
	m.clearedFields[award.FieldCertificateURL] = struct{}{}
}

// CertificateURLCleared returns if the "certificate_url" field was cleared in this mutation.
func (m *AwardMutation) CertificateURLCleared() bool {
	_, ok := m.clearedFields[award.FieldCertificateURL]
	return ok
}

// ResetCertificateURL resets all changes to the "certificate_url" field.
func (m *AwardMutation) ResetCertificateURL() {
	m.certificate_url = nil
	delete(m.clearedFields, award.FieldCertificateURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *AwardMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AwardMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *AwardMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AwardMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AwardMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AwardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AwardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AwardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AwardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AwardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AwardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AwardMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[award.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AwardMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AwardMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AwardMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the AwardTranslation entity by ids.
func (m *AwardMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the AwardTranslation entity.
func (m *AwardMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the AwardTranslation entity was cleared.
func (m *AwardMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the AwardTranslation entity by IDs.
func (m *AwardMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the AwardTranslation entity.
func (m *AwardMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *AwardMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *AwardMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the AwardMutation builder.
func (m *AwardMutation) Where(ps ...predicate.Award) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AwardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AwardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Award, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AwardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AwardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Award).
func (m *AwardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AwardMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, award.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, award.FieldTitle)
	}
	if m.awarding_organization != nil {
		fields = append(fields, award.FieldAwardingOrganization)
	}
	if m.award_date != nil {
		fields = append(fields, award.FieldAwardDate)
	}
	if m.award_type != nil {
		fields = append(fields, award.FieldAwardType)
	}
	if m.amount != nil {
		fields = append(fields, award.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, award.FieldDescription)
	}
	if m.certificate_url != nil {
		fields = append(fields, award.FieldCertificateURL)
	}
	if m.sort_order != nil {
		fields = append(fields, award.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, award.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, award.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AwardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case award.FieldUserID:
		return m.UserID()
	case award.FieldTitle:
		return m.Title()
	case award.FieldAwardingOrganization:
		return m.AwardingOrganization()
	case award.FieldAwardDate:
		return m.AwardDate()
	case award.FieldAwardType:
		return m.AwardType()
	case award.FieldAmount:
		return m.Amount()
	case award.FieldDescription:
		return m.Description()
	case award.FieldCertificateURL:
		return m.CertificateURL()
	case award.FieldSortOrder:
		return m.SortOrder()
	case award.FieldCreatedAt:
		return m.CreatedAt()
	case award.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AwardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case award.FieldUserID:
		return m.OldUserID(ctx)
	case award.FieldTitle:
		return m.OldTitle(ctx)
	case award.FieldAwardingOrganization:
		return m.OldAwardingOrganization(ctx)
	case award.FieldAwardDate:
		return m.OldAwardDate(ctx)
	case award.FieldAwardType:
		return m.OldAwardType(ctx)
	case award.FieldAmount:
		return m.OldAmount(ctx)
	case award.FieldDescription:
		return m.OldDescription(ctx)
	case award.FieldCertificateURL:
		return m.OldCertificateURL(ctx)
	case award.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case award.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case award.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Award field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case award.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case award.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case award.FieldAwardingOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardingOrganization(v)
		return nil
	case award.FieldAwardDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardDate(v)
		return nil
	case award.FieldAwardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardType(v)
		return nil
	case award.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case award.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case award.FieldCertificateURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateURL(v)
		return nil
	case award.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case award.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case award.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Award field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AwardMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, award.FieldAmount)
	}
	if m.addsort_order != nil {
		fields = append(fields, award.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AwardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case award.FieldAmount:
		return m.AddedAmount()
	case award.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case award.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case award.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Award numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AwardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(award.FieldAwardDate) {
		fields = append(fields, award.FieldAwardDate)
	}
	if m.FieldCleared(award.FieldAwardType) {
		fields = append(fields, award.FieldAwardType)
	}
	if m.FieldCleared(award.FieldAmount) {
		fields = append(fields, award.FieldAmount)
	}
	if m.FieldCleared(award.FieldDescription) {
		fields = append(fields, award.FieldDescription)
	}
	if m.FieldCleared(award.FieldCertificateURL) {
		fields = append(fields, award.FieldCertificateURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AwardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AwardMutation) ClearField(name string) error {
	switch name {
	case award.FieldAwardDate:
		m.ClearAwardDate()
		return nil
	case award.FieldAwardType:
		m.ClearAwardType()
		return nil
	case award.FieldAmount:
		m.ClearAmount()
		return nil
	case award.FieldDescription:
		m.ClearDescription()
		return nil
	case award.FieldCertificateURL:
		m.ClearCertificateURL()
		return nil
	}
	return fmt.Errorf("unknown Award nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AwardMutation) ResetField(name string) error {
	switch name {
	case award.FieldUserID:
		m.ResetUserID()
		return nil
	case award.FieldTitle:
		m.ResetTitle()
		return nil
	case award.FieldAwardingOrganization:
		m.ResetAwardingOrganization()
		return nil
	case award.FieldAwardDate:
		m.ResetAwardDate()
		return nil
	case award.FieldAwardType:
		m.ResetAwardType()
		return nil
	case award.FieldAmount:
		m.ResetAmount()
		return nil
	case award.FieldDescription:
		m.ResetDescription()
		return nil
	case award.FieldCertificateURL:
		m.ResetCertificateURL()
		return nil
	case award.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case award.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case award.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Award field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AwardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, award.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, award.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AwardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case award.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case award.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AwardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, award.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AwardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case award.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AwardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, award.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, award.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AwardMutation) EdgeCleared(name string) bool {
	switch name {
	case award.EdgeUser:
		return m.cleareduser
	case award.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AwardMutation) ClearEdge(name string) error {
	switch name {
	case award.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Award unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AwardMutation) ResetEdge(name string) error {
	switch name {
	case award.EdgeUser:
		m.ResetUser()
		return nil
	case award.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown Award edge %s", name)
}

// AwardTranslationMutation represents an operation that mutates the AwardTranslation nodes in the graph.
type AwardTranslationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	title                 *string
	awarding_organization *string
	award_type            *string
	description           *string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	award                 *uuid.UUID
	clearedaward          bool
	language              *string
	clearedlanguage       bool
	done                  bool
	oldValue              func(context.Context) (*AwardTranslation, error)
	predicates            []predicate.AwardTranslation
}

var _ ent.Mutation = (*AwardTranslationMutation)(nil)

// awardtranslationOption allows management of the mutation configuration using functional options.
type awardtranslationOption func(*AwardTranslationMutation)

// newAwardTranslationMutation creates new mutation for the AwardTranslation entity.
func newAwardTranslationMutation(c config, op Op, opts ...awardtranslationOption) *AwardTranslationMutation {
	m := &AwardTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeAwardTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAwardTranslationID sets the ID field of the mutation.
func withAwardTranslationID(id uuid.UUID) awardtranslationOption {
	return func(m *AwardTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *AwardTranslation
		)
		m.oldValue = func(ctx context.Context) (*AwardTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AwardTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAwardTranslation sets the old AwardTranslation of the mutation.
func withAwardTranslation(node *AwardTranslation) awardtranslationOption {
	return func(m *AwardTranslationMutation) {
		m.oldValue = func(context.Context) (*AwardTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AwardTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AwardTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AwardTranslation entities.
func (m *AwardTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AwardTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AwardTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AwardTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAwardID sets the "award_id" field.
func (m *AwardTranslationMutation) SetAwardID(u uuid.UUID) {
	m.award = &u
}

// AwardID returns the value of the "award_id" field in the mutation.
func (m *AwardTranslationMutation) AwardID() (r uuid.UUID, exists bool) {
	v := m.award
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardID returns the old "award_id" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldAwardID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardID: %w", err)
	}
	return oldValue.AwardID, nil
}

// ResetAwardID resets all changes to the "award_id" field.
func (m *AwardTranslationMutation) ResetAwardID() {
	m.award = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *AwardTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *AwardTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *AwardTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *AwardTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AwardTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AwardTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetAwardingOrganization sets the "awarding_organization" field.
func (m *AwardTranslationMutation) SetAwardingOrganization(s string) {
	m.awarding_organization = &s
}

// AwardingOrganization returns the value of the "awarding_organization" field in the mutation.
func (m *AwardTranslationMutation) AwardingOrganization() (r string, exists bool) {
	v := m.awarding_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardingOrganization returns the old "awarding_organization" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldAwardingOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardingOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardingOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardingOrganization: %w", err)
	}
	return oldValue.AwardingOrganization, nil
}

// ResetAwardingOrganization resets all changes to the "awarding_organization" field.
func (m *AwardTranslationMutation) ResetAwardingOrganization() {
	m.awarding_organization = nil
}

// SetAwardType sets the "award_type" field.
func (m *AwardTranslationMutation) SetAwardType(s string) {
	m.award_type = &s
}

// AwardType returns the value of the "award_type" field in the mutation.
func (m *AwardTranslationMutation) AwardType() (r string, exists bool) {
	v := m.award_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardType returns the old "award_type" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldAwardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardType: %w", err)
	}
	return oldValue.AwardType, nil
}

// ClearAwardType clears the value of the "award_type" field.
func (m *AwardTranslationMutation) ClearAwardType() {
	m.award_type = nil
	m.clearedFields[awardtranslation.FieldAwardType] = struct{}{}
}

// AwardTypeCleared returns if the "award_type" field was cleared in this mutation.
func (m *AwardTranslationMutation) AwardTypeCleared() bool {
	_, ok := m.clearedFields[awardtranslation.FieldAwardType]
	return ok
}

// ResetAwardType resets all changes to the "award_type" field.
func (m *AwardTranslationMutation) ResetAwardType() {
	m.award_type = nil
	delete(m.clearedFields, awardtranslation.FieldAwardType)
}

// SetDescription sets the "description" field.
func (m *AwardTranslationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AwardTranslationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AwardTranslationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[awardtranslation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AwardTranslationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[awardtranslation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AwardTranslationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, awardtranslation.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *AwardTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AwardTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AwardTranslation entity.
// If the AwardTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AwardTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAward clears the "award" edge to the Award entity.
func (m *AwardTranslationMutation) ClearAward() {
	m.clearedaward = true
	m.clearedFields[awardtranslation.FieldAwardID] = struct{}{}
}

// AwardCleared reports if the "award" edge to the Award entity was cleared.
func (m *AwardTranslationMutation) AwardCleared() bool {
	return m.clearedaward
}

// AwardIDs returns the "award" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AwardID instead. It exists only for internal usage by the builders.
func (m *AwardTranslationMutation) AwardIDs() (ids []uuid.UUID) {
	if id := m.award; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAward resets all changes to the "award" edge.
func (m *AwardTranslationMutation) ResetAward() {
	m.award = nil
	m.clearedaward = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *AwardTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *AwardTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[awardtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *AwardTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *AwardTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *AwardTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *AwardTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the AwardTranslationMutation builder.
func (m *AwardTranslationMutation) Where(ps ...predicate.AwardTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AwardTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AwardTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AwardTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AwardTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AwardTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AwardTranslation).
func (m *AwardTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AwardTranslationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.award != nil {
		fields = append(fields, awardtranslation.FieldAwardID)
	}
	if m.language != nil {
		fields = append(fields, awardtranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, awardtranslation.FieldTitle)
	}
	if m.awarding_organization != nil {
		fields = append(fields, awardtranslation.FieldAwardingOrganization)
	}
	if m.award_type != nil {
		fields = append(fields, awardtranslation.FieldAwardType)
	}
	if m.description != nil {
		fields = append(fields, awardtranslation.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, awardtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AwardTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case awardtranslation.FieldAwardID:
		return m.AwardID()
	case awardtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case awardtranslation.FieldTitle:
		return m.Title()
	case awardtranslation.FieldAwardingOrganization:
		return m.AwardingOrganization()
	case awardtranslation.FieldAwardType:
		return m.AwardType()
	case awardtranslation.FieldDescription:
		return m.Description()
	case awardtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AwardTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case awardtranslation.FieldAwardID:
		return m.OldAwardID(ctx)
	case awardtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case awardtranslation.FieldTitle:
		return m.OldTitle(ctx)
	case awardtranslation.FieldAwardingOrganization:
		return m.OldAwardingOrganization(ctx)
	case awardtranslation.FieldAwardType:
		return m.OldAwardType(ctx)
	case awardtranslation.FieldDescription:
		return m.OldDescription(ctx)
	case awardtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AwardTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case awardtranslation.FieldAwardID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardID(v)
		return nil
	case awardtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case awardtranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case awardtranslation.FieldAwardingOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardingOrganization(v)
		return nil
	case awardtranslation.FieldAwardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardType(v)
		return nil
	case awardtranslation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case awardtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AwardTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AwardTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AwardTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AwardTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AwardTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(awardtranslation.FieldAwardType) {
		fields = append(fields, awardtranslation.FieldAwardType)
	}
	if m.FieldCleared(awardtranslation.FieldDescription) {
		fields = append(fields, awardtranslation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AwardTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AwardTranslationMutation) ClearField(name string) error {
	switch name {
	case awardtranslation.FieldAwardType:
		m.ClearAwardType()
		return nil
	case awardtranslation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AwardTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AwardTranslationMutation) ResetField(name string) error {
	switch name {
	case awardtranslation.FieldAwardID:
		m.ResetAwardID()
		return nil
	case awardtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case awardtranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case awardtranslation.FieldAwardingOrganization:
		m.ResetAwardingOrganization()
		return nil
	case awardtranslation.FieldAwardType:
		m.ResetAwardType()
		return nil
	case awardtranslation.FieldDescription:
		m.ResetDescription()
		return nil
	case awardtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AwardTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AwardTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.award != nil {
		edges = append(edges, awardtranslation.EdgeAward)
	}
	if m.language != nil {
		edges = append(edges, awardtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AwardTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case awardtranslation.EdgeAward:
		if id := m.award; id != nil {
			return []ent.Value{*id}
		}
	case awardtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AwardTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AwardTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AwardTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaward {
		edges = append(edges, awardtranslation.EdgeAward)
	}
	if m.clearedlanguage {
		edges = append(edges, awardtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AwardTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case awardtranslation.EdgeAward:
		return m.clearedaward
	case awardtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AwardTranslationMutation) ClearEdge(name string) error {
	switch name {
	case awardtranslation.EdgeAward:
		m.ClearAward()
		return nil
	case awardtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown AwardTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AwardTranslationMutation) ResetEdge(name string) error {
	switch name {
	case awardtranslation.EdgeAward:
		m.ResetAward()
		return nil
	case awardtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown AwardTranslation edge %s", name)
}

// BlogCategoryMutation represents an operation that mutates the BlogCategory nodes in the graph.
type BlogCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	slug                *string
	description         *string
	color               *string
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	blog_posts          map[uuid.UUID]struct{}
	removedblog_posts   map[uuid.UUID]struct{}
	clearedblog_posts   bool
	done                bool
	oldValue            func(context.Context) (*BlogCategory, error)
	predicates          []predicate.BlogCategory
}

var _ ent.Mutation = (*BlogCategoryMutation)(nil)

// blogcategoryOption allows management of the mutation configuration using functional options.
type blogcategoryOption func(*BlogCategoryMutation)

// newBlogCategoryMutation creates new mutation for the BlogCategory entity.
func newBlogCategoryMutation(c config, op Op, opts ...blogcategoryOption) *BlogCategoryMutation {
	m := &BlogCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogCategoryID sets the ID field of the mutation.
func withBlogCategoryID(id uuid.UUID) blogcategoryOption {
	return func(m *BlogCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogCategory
		)
		m.oldValue = func(ctx context.Context) (*BlogCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogCategory sets the old BlogCategory of the mutation.
func withBlogCategory(node *BlogCategory) blogcategoryOption {
	return func(m *BlogCategoryMutation) {
		m.oldValue = func(context.Context) (*BlogCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogCategory entities.
func (m *BlogCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BlogCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlogCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlogCategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *BlogCategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogCategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogCategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BlogCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogcategory.FieldDescription)
}

// SetColor sets the "color" field.
func (m *BlogCategoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *BlogCategoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *BlogCategoryMutation) ClearColor() {
	m.color = nil
	m.clearedFields[blogcategory.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *BlogCategoryMutation) ColorCleared() bool {
	_, ok := m.clearedFields[blogcategory.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *BlogCategoryMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, blogcategory.FieldColor)
}

// SetSortOrder sets the "sort_order" field.
func (m *BlogCategoryMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *BlogCategoryMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *BlogCategoryMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *BlogCategoryMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *BlogCategoryMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddTranslationIDs adds the "translations" edge to the BlogCategoryTranslation entity by ids.
func (m *BlogCategoryMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the BlogCategoryTranslation entity.
func (m *BlogCategoryMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the BlogCategoryTranslation entity was cleared.
func (m *BlogCategoryMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the BlogCategoryTranslation entity by IDs.
func (m *BlogCategoryMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the BlogCategoryTranslation entity.
func (m *BlogCategoryMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *BlogCategoryMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *BlogCategoryMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *BlogCategoryMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *BlogCategoryMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *BlogCategoryMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *BlogCategoryMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *BlogCategoryMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *BlogCategoryMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *BlogCategoryMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// Where appends a list predicates to the BlogCategoryMutation builder.
func (m *BlogCategoryMutation) Where(ps ...predicate.BlogCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogCategory).
func (m *BlogCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, blogcategory.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, blogcategory.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, blogcategory.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, blogcategory.FieldColor)
	}
	if m.sort_order != nil {
		fields = append(fields, blogcategory.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, blogcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogcategory.FieldName:
		return m.Name()
	case blogcategory.FieldSlug:
		return m.Slug()
	case blogcategory.FieldDescription:
		return m.Description()
	case blogcategory.FieldColor:
		return m.Color()
	case blogcategory.FieldSortOrder:
		return m.SortOrder()
	case blogcategory.FieldCreatedAt:
		return m.CreatedAt()
	case blogcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogcategory.FieldName:
		return m.OldName(ctx)
	case blogcategory.FieldSlug:
		return m.OldSlug(ctx)
	case blogcategory.FieldDescription:
		return m.OldDescription(ctx)
	case blogcategory.FieldColor:
		return m.OldColor(ctx)
	case blogcategory.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case blogcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blogcategory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogcategory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case blogcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case blogcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, blogcategory.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogcategory.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogcategory.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown BlogCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogcategory.FieldDescription) {
		fields = append(fields, blogcategory.FieldDescription)
	}
	if m.FieldCleared(blogcategory.FieldColor) {
		fields = append(fields, blogcategory.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogCategoryMutation) ClearField(name string) error {
	switch name {
	case blogcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case blogcategory.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown BlogCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogCategoryMutation) ResetField(name string) error {
	switch name {
	case blogcategory.FieldName:
		m.ResetName()
		return nil
	case blogcategory.FieldSlug:
		m.ResetSlug()
		return nil
	case blogcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case blogcategory.FieldColor:
		m.ResetColor()
		return nil
	case blogcategory.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case blogcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.translations != nil {
		edges = append(edges, blogcategory.EdgeTranslations)
	}
	if m.blog_posts != nil {
		edges = append(edges, blogcategory.EdgeBlogPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogcategory.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case blogcategory.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, blogcategory.EdgeTranslations)
	}
	if m.removedblog_posts != nil {
		edges = append(edges, blogcategory.EdgeBlogPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogcategory.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case blogcategory.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtranslations {
		edges = append(edges, blogcategory.EdgeTranslations)
	}
	if m.clearedblog_posts {
		edges = append(edges, blogcategory.EdgeBlogPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case blogcategory.EdgeTranslations:
		return m.clearedtranslations
	case blogcategory.EdgeBlogPosts:
		return m.clearedblog_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogCategoryMutation) ResetEdge(name string) error {
	switch name {
	case blogcategory.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case blogcategory.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	}
	return fmt.Errorf("unknown BlogCategory edge %s", name)
}

// BlogCategoryTranslationMutation represents an operation that mutates the BlogCategoryTranslation nodes in the graph.
type BlogCategoryTranslationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	description          *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	blog_category        *uuid.UUID
	clearedblog_category bool
	language             *string
	clearedlanguage      bool
	done                 bool
	oldValue             func(context.Context) (*BlogCategoryTranslation, error)
	predicates           []predicate.BlogCategoryTranslation
}

var _ ent.Mutation = (*BlogCategoryTranslationMutation)(nil)

// blogcategorytranslationOption allows management of the mutation configuration using functional options.
type blogcategorytranslationOption func(*BlogCategoryTranslationMutation)

// newBlogCategoryTranslationMutation creates new mutation for the BlogCategoryTranslation entity.
func newBlogCategoryTranslationMutation(c config, op Op, opts ...blogcategorytranslationOption) *BlogCategoryTranslationMutation {
	m := &BlogCategoryTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogCategoryTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogCategoryTranslationID sets the ID field of the mutation.
func withBlogCategoryTranslationID(id uuid.UUID) blogcategorytranslationOption {
	return func(m *BlogCategoryTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogCategoryTranslation
		)
		m.oldValue = func(ctx context.Context) (*BlogCategoryTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogCategoryTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogCategoryTranslation sets the old BlogCategoryTranslation of the mutation.
func withBlogCategoryTranslation(node *BlogCategoryTranslation) blogcategorytranslationOption {
	return func(m *BlogCategoryTranslationMutation) {
		m.oldValue = func(context.Context) (*BlogCategoryTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogCategoryTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogCategoryTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogCategoryTranslation entities.
func (m *BlogCategoryTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogCategoryTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogCategoryTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogCategoryTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlogCategoryID sets the "blog_category_id" field.
func (m *BlogCategoryTranslationMutation) SetBlogCategoryID(u uuid.UUID) {
	m.blog_category = &u
}

// BlogCategoryID returns the value of the "blog_category_id" field in the mutation.
func (m *BlogCategoryTranslationMutation) BlogCategoryID() (r uuid.UUID, exists bool) {
	v := m.blog_category
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogCategoryID returns the old "blog_category_id" field's value of the BlogCategoryTranslation entity.
// If the BlogCategoryTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryTranslationMutation) OldBlogCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogCategoryID: %w", err)
	}
	return oldValue.BlogCategoryID, nil
}

// ResetBlogCategoryID resets all changes to the "blog_category_id" field.
func (m *BlogCategoryTranslationMutation) ResetBlogCategoryID() {
	m.blog_category = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *BlogCategoryTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *BlogCategoryTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the BlogCategoryTranslation entity.
// If the BlogCategoryTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *BlogCategoryTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetName sets the "name" field.
func (m *BlogCategoryTranslationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlogCategoryTranslationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BlogCategoryTranslation entity.
// If the BlogCategoryTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryTranslationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlogCategoryTranslationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BlogCategoryTranslationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogCategoryTranslationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogCategoryTranslation entity.
// If the BlogCategoryTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryTranslationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogCategoryTranslationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogcategorytranslation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogCategoryTranslationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogcategorytranslation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogCategoryTranslationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogcategorytranslation.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogCategoryTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogCategoryTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogCategoryTranslation entity.
// If the BlogCategoryTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogCategoryTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearBlogCategory clears the "blog_category" edge to the BlogCategory entity.
func (m *BlogCategoryTranslationMutation) ClearBlogCategory() {
	m.clearedblog_category = true
	m.clearedFields[blogcategorytranslation.FieldBlogCategoryID] = struct{}{}
}

// BlogCategoryCleared reports if the "blog_category" edge to the BlogCategory entity was cleared.
func (m *BlogCategoryTranslationMutation) BlogCategoryCleared() bool {
	return m.clearedblog_category
}

// BlogCategoryIDs returns the "blog_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogCategoryID instead. It exists only for internal usage by the builders.
func (m *BlogCategoryTranslationMutation) BlogCategoryIDs() (ids []uuid.UUID) {
	if id := m.blog_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlogCategory resets all changes to the "blog_category" edge.
func (m *BlogCategoryTranslationMutation) ResetBlogCategory() {
	m.blog_category = nil
	m.clearedblog_category = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *BlogCategoryTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *BlogCategoryTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[blogcategorytranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *BlogCategoryTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *BlogCategoryTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *BlogCategoryTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *BlogCategoryTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the BlogCategoryTranslationMutation builder.
func (m *BlogCategoryTranslationMutation) Where(ps ...predicate.BlogCategoryTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogCategoryTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogCategoryTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogCategoryTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogCategoryTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogCategoryTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogCategoryTranslation).
func (m *BlogCategoryTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogCategoryTranslationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.blog_category != nil {
		fields = append(fields, blogcategorytranslation.FieldBlogCategoryID)
	}
	if m.language != nil {
		fields = append(fields, blogcategorytranslation.FieldLanguageCode)
	}
	if m.name != nil {
		fields = append(fields, blogcategorytranslation.FieldName)
	}
	if m.description != nil {
		fields = append(fields, blogcategorytranslation.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, blogcategorytranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogCategoryTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogcategorytranslation.FieldBlogCategoryID:
		return m.BlogCategoryID()
	case blogcategorytranslation.FieldLanguageCode:
		return m.LanguageCode()
	case blogcategorytranslation.FieldName:
		return m.Name()
	case blogcategorytranslation.FieldDescription:
		return m.Description()
	case blogcategorytranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogCategoryTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogcategorytranslation.FieldBlogCategoryID:
		return m.OldBlogCategoryID(ctx)
	case blogcategorytranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case blogcategorytranslation.FieldName:
		return m.OldName(ctx)
	case blogcategorytranslation.FieldDescription:
		return m.OldDescription(ctx)
	case blogcategorytranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogCategoryTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCategoryTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogcategorytranslation.FieldBlogCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogCategoryID(v)
		return nil
	case blogcategorytranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case blogcategorytranslation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blogcategorytranslation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogcategorytranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogCategoryTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogCategoryTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogCategoryTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCategoryTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogCategoryTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogCategoryTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogcategorytranslation.FieldDescription) {
		fields = append(fields, blogcategorytranslation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogCategoryTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogCategoryTranslationMutation) ClearField(name string) error {
	switch name {
	case blogcategorytranslation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlogCategoryTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogCategoryTranslationMutation) ResetField(name string) error {
	switch name {
	case blogcategorytranslation.FieldBlogCategoryID:
		m.ResetBlogCategoryID()
		return nil
	case blogcategorytranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case blogcategorytranslation.FieldName:
		m.ResetName()
		return nil
	case blogcategorytranslation.FieldDescription:
		m.ResetDescription()
		return nil
	case blogcategorytranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogCategoryTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogCategoryTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blog_category != nil {
		edges = append(edges, blogcategorytranslation.EdgeBlogCategory)
	}
	if m.language != nil {
		edges = append(edges, blogcategorytranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogCategoryTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogcategorytranslation.EdgeBlogCategory:
		if id := m.blog_category; id != nil {
			return []ent.Value{*id}
		}
	case blogcategorytranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogCategoryTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogCategoryTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogCategoryTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblog_category {
		edges = append(edges, blogcategorytranslation.EdgeBlogCategory)
	}
	if m.clearedlanguage {
		edges = append(edges, blogcategorytranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogCategoryTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case blogcategorytranslation.EdgeBlogCategory:
		return m.clearedblog_category
	case blogcategorytranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogCategoryTranslationMutation) ClearEdge(name string) error {
	switch name {
	case blogcategorytranslation.EdgeBlogCategory:
		m.ClearBlogCategory()
		return nil
	case blogcategorytranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown BlogCategoryTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogCategoryTranslationMutation) ResetEdge(name string) error {
	switch name {
	case blogcategorytranslation.EdgeBlogCategory:
		m.ResetBlogCategory()
		return nil
	case blogcategorytranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown BlogCategoryTranslation edge %s", name)
}

// BlogCommentMutation represents an operation that mutates the BlogComment nodes in the graph.
type BlogCommentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	author_name      *string
	author_email     *string
	author_website   *string
	content          *string
	is_approved      *bool
	ip_address       *string
	user_agent       *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	blog_post        *uuid.UUID
	clearedblog_post bool
	parent           *uuid.UUID
	clearedparent    bool
	replies          map[uuid.UUID]struct{}
	removedreplies   map[uuid.UUID]struct{}
	clearedreplies   bool
	done             bool
	oldValue         func(context.Context) (*BlogComment, error)
	predicates       []predicate.BlogComment
}

var _ ent.Mutation = (*BlogCommentMutation)(nil)

// blogcommentOption allows management of the mutation configuration using functional options.
type blogcommentOption func(*BlogCommentMutation)

// newBlogCommentMutation creates new mutation for the BlogComment entity.
func newBlogCommentMutation(c config, op Op, opts ...blogcommentOption) *BlogCommentMutation {
	m := &BlogCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogCommentID sets the ID field of the mutation.
func withBlogCommentID(id uuid.UUID) blogcommentOption {
	return func(m *BlogCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogComment
		)
		m.oldValue = func(ctx context.Context) (*BlogComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogComment sets the old BlogComment of the mutation.
func withBlogComment(node *BlogComment) blogcommentOption {
	return func(m *BlogCommentMutation) {
		m.oldValue = func(context.Context) (*BlogComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogComment entities.
func (m *BlogCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlogPostID sets the "blog_post_id" field.
func (m *BlogCommentMutation) SetBlogPostID(u uuid.UUID) {
	m.blog_post = &u
}

// BlogPostID returns the value of the "blog_post_id" field in the mutation.
func (m *BlogCommentMutation) BlogPostID() (r uuid.UUID, exists bool) {
	v := m.blog_post
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogPostID returns the old "blog_post_id" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldBlogPostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogPostID: %w", err)
	}
	return oldValue.BlogPostID, nil
}

// ResetBlogPostID resets all changes to the "blog_post_id" field.
func (m *BlogCommentMutation) ResetBlogPostID() {
	m.blog_post = nil
}

// SetParentID sets the "parent_id" field.
func (m *BlogCommentMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BlogCommentMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *BlogCommentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[blogcomment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *BlogCommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BlogCommentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, blogcomment.FieldParentID)
}

// SetAuthorName sets the "author_name" field.
func (m *BlogCommentMutation) SetAuthorName(s string) {
	m.author_name = &s
}

// AuthorName returns the value of the "author_name" field in the mutation.
func (m *BlogCommentMutation) AuthorName() (r string, exists bool) {
	v := m.author_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorName returns the old "author_name" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldAuthorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorName: %w", err)
	}
	return oldValue.AuthorName, nil
}

// ResetAuthorName resets all changes to the "author_name" field.
func (m *BlogCommentMutation) ResetAuthorName() {
	m.author_name = nil
}

// SetAuthorEmail sets the "author_email" field.
func (m *BlogCommentMutation) SetAuthorEmail(s string) {
	m.author_email = &s
}

// AuthorEmail returns the value of the "author_email" field in the mutation.
func (m *BlogCommentMutation) AuthorEmail() (r string, exists bool) {
	v := m.author_email
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorEmail returns the old "author_email" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldAuthorEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorEmail: %w", err)
	}
	return oldValue.AuthorEmail, nil
}

// ResetAuthorEmail resets all changes to the "author_email" field.
func (m *BlogCommentMutation) ResetAuthorEmail() {
	m.author_email = nil
}

// SetAuthorWebsite sets the "author_website" field.
func (m *BlogCommentMutation) SetAuthorWebsite(s string) {
	m.author_website = &s
}

// AuthorWebsite returns the value of the "author_website" field in the mutation.
func (m *BlogCommentMutation) AuthorWebsite() (r string, exists bool) {
	v := m.author_website
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorWebsite returns the old "author_website" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldAuthorWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorWebsite: %w", err)
	}
	return oldValue.AuthorWebsite, nil
}

// ClearAuthorWebsite clears the value of the "author_website" field.
func (m *BlogCommentMutation) ClearAuthorWebsite() {
	m.author_website = nil
	m.clearedFields[blogcomment.FieldAuthorWebsite] = struct{}{}
}

// AuthorWebsiteCleared returns if the "author_website" field was cleared in this mutation.
func (m *BlogCommentMutation) AuthorWebsiteCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldAuthorWebsite]
	return ok
}

// ResetAuthorWebsite resets all changes to the "author_website" field.
func (m *BlogCommentMutation) ResetAuthorWebsite() {
	m.author_website = nil
	delete(m.clearedFields, blogcomment.FieldAuthorWebsite)
}

// SetContent sets the "content" field.
func (m *BlogCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogCommentMutation) ResetContent() {
	m.content = nil
}

// SetIsApproved sets the "is_approved" field.
func (m *BlogCommentMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *BlogCommentMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *BlogCommentMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *BlogCommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *BlogCommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *BlogCommentMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[blogcomment.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *BlogCommentMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *BlogCommentMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, blogcomment.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *BlogCommentMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *BlogCommentMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *BlogCommentMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[blogcomment.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *BlogCommentMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *BlogCommentMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, blogcomment.FieldUserAgent)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearBlogPost clears the "blog_post" edge to the BlogPost entity.
func (m *BlogCommentMutation) ClearBlogPost() {
	m.clearedblog_post = true
	m.clearedFields[blogcomment.FieldBlogPostID] = struct{}{}
}

// BlogPostCleared reports if the "blog_post" edge to the BlogPost entity was cleared.
func (m *BlogCommentMutation) BlogPostCleared() bool {
	return m.clearedblog_post
}

// BlogPostIDs returns the "blog_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogPostID instead. It exists only for internal usage by the builders.
func (m *BlogCommentMutation) BlogPostIDs() (ids []uuid.UUID) {
	if id := m.blog_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlogPost resets all changes to the "blog_post" edge.
func (m *BlogCommentMutation) ResetBlogPost() {
	m.blog_post = nil
	m.clearedblog_post = false
}

// ClearParent clears the "parent" edge to the BlogComment entity.
func (m *BlogCommentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[blogcomment.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the BlogComment entity was cleared.
func (m *BlogCommentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BlogCommentMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BlogCommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddReplyIDs adds the "replies" edge to the BlogComment entity by ids.
func (m *BlogCommentMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the BlogComment entity.
func (m *BlogCommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the BlogComment entity was cleared.
func (m *BlogCommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the BlogComment entity by IDs.
func (m *BlogCommentMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the BlogComment entity.
func (m *BlogCommentMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *BlogCommentMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *BlogCommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// Where appends a list predicates to the BlogCommentMutation builder.
func (m *BlogCommentMutation) Where(ps ...predicate.BlogComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogComment).
func (m *BlogCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogCommentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.blog_post != nil {
		fields = append(fields, blogcomment.FieldBlogPostID)
	}
	if m.parent != nil {
		fields = append(fields, blogcomment.FieldParentID)
	}
	if m.author_name != nil {
		fields = append(fields, blogcomment.FieldAuthorName)
	}
	if m.author_email != nil {
		fields = append(fields, blogcomment.FieldAuthorEmail)
	}
	if m.author_website != nil {
		fields = append(fields, blogcomment.FieldAuthorWebsite)
	}
	if m.content != nil {
		fields = append(fields, blogcomment.FieldContent)
	}
	if m.is_approved != nil {
		fields = append(fields, blogcomment.FieldIsApproved)
	}
	if m.ip_address != nil {
		fields = append(fields, blogcomment.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, blogcomment.FieldUserAgent)
	}
	if m.created_at != nil {
		fields = append(fields, blogcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogcomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogcomment.FieldBlogPostID:
		return m.BlogPostID()
	case blogcomment.FieldParentID:
		return m.ParentID()
	case blogcomment.FieldAuthorName:
		return m.AuthorName()
	case blogcomment.FieldAuthorEmail:
		return m.AuthorEmail()
	case blogcomment.FieldAuthorWebsite:
		return m.AuthorWebsite()
	case blogcomment.FieldContent:
		return m.Content()
	case blogcomment.FieldIsApproved:
		return m.IsApproved()
	case blogcomment.FieldIPAddress:
		return m.IPAddress()
	case blogcomment.FieldUserAgent:
		return m.UserAgent()
	case blogcomment.FieldCreatedAt:
		return m.CreatedAt()
	case blogcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogcomment.FieldBlogPostID:
		return m.OldBlogPostID(ctx)
	case blogcomment.FieldParentID:
		return m.OldParentID(ctx)
	case blogcomment.FieldAuthorName:
		return m.OldAuthorName(ctx)
	case blogcomment.FieldAuthorEmail:
		return m.OldAuthorEmail(ctx)
	case blogcomment.FieldAuthorWebsite:
		return m.OldAuthorWebsite(ctx)
	case blogcomment.FieldContent:
		return m.OldContent(ctx)
	case blogcomment.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case blogcomment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case blogcomment.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case blogcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogcomment.FieldBlogPostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogPostID(v)
		return nil
	case blogcomment.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case blogcomment.FieldAuthorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorName(v)
		return nil
	case blogcomment.FieldAuthorEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorEmail(v)
		return nil
	case blogcomment.FieldAuthorWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorWebsite(v)
		return nil
	case blogcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogcomment.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case blogcomment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case blogcomment.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case blogcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogCommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogCommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogcomment.FieldParentID) {
		fields = append(fields, blogcomment.FieldParentID)
	}
	if m.FieldCleared(blogcomment.FieldAuthorWebsite) {
		fields = append(fields, blogcomment.FieldAuthorWebsite)
	}
	if m.FieldCleared(blogcomment.FieldIPAddress) {
		fields = append(fields, blogcomment.FieldIPAddress)
	}
	if m.FieldCleared(blogcomment.FieldUserAgent) {
		fields = append(fields, blogcomment.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogCommentMutation) ClearField(name string) error {
	switch name {
	case blogcomment.FieldParentID:
		m.ClearParentID()
		return nil
	case blogcomment.FieldAuthorWebsite:
		m.ClearAuthorWebsite()
		return nil
	case blogcomment.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case blogcomment.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown BlogComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogCommentMutation) ResetField(name string) error {
	switch name {
	case blogcomment.FieldBlogPostID:
		m.ResetBlogPostID()
		return nil
	case blogcomment.FieldParentID:
		m.ResetParentID()
		return nil
	case blogcomment.FieldAuthorName:
		m.ResetAuthorName()
		return nil
	case blogcomment.FieldAuthorEmail:
		m.ResetAuthorEmail()
		return nil
	case blogcomment.FieldAuthorWebsite:
		m.ResetAuthorWebsite()
		return nil
	case blogcomment.FieldContent:
		m.ResetContent()
		return nil
	case blogcomment.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case blogcomment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case blogcomment.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case blogcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.blog_post != nil {
		edges = append(edges, blogcomment.EdgeBlogPost)
	}
	if m.parent != nil {
		edges = append(edges, blogcomment.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, blogcomment.EdgeReplies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogcomment.EdgeBlogPost:
		if id := m.blog_post; id != nil {
			return []ent.Value{*id}
		}
	case blogcomment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case blogcomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreplies != nil {
		edges = append(edges, blogcomment.EdgeReplies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogCommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogcomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedblog_post {
		edges = append(edges, blogcomment.EdgeBlogPost)
	}
	if m.clearedparent {
		edges = append(edges, blogcomment.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, blogcomment.EdgeReplies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case blogcomment.EdgeBlogPost:
		return m.clearedblog_post
	case blogcomment.EdgeParent:
		return m.clearedparent
	case blogcomment.EdgeReplies:
		return m.clearedreplies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogCommentMutation) ClearEdge(name string) error {
	switch name {
	case blogcomment.EdgeBlogPost:
		m.ClearBlogPost()
		return nil
	case blogcomment.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BlogComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogCommentMutation) ResetEdge(name string) error {
	switch name {
	case blogcomment.EdgeBlogPost:
		m.ResetBlogPost()
		return nil
	case blogcomment.EdgeParent:
		m.ResetParent()
		return nil
	case blogcomment.EdgeReplies:
		m.ResetReplies()
		return nil
	}
	return fmt.Errorf("unknown BlogComment edge %s", name)
}

// BlogPostMutation represents an operation that mutates the BlogPost nodes in the graph.
type BlogPostMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	title                   *string
	slug                    *string
	excerpt                 *string
	content                 *string
	content_type            *blogpost.ContentType
	status                  *blogpost.Status
	is_featured             *bool
	featured_image_url      *string
	reading_time_minutes    *int
	addreading_time_minutes *int
	view_count              *int
	addview_count           *int
	like_count              *int
	addlike_count           *int
	comment_count           *int
	addcomment_count        *int
	published_at            *time.Time
	series_order            *int
	addseries_order         *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	user                    *uuid.UUID
	cleareduser             bool
	category                *uuid.UUID
	clearedcategory         bool
	series                  *uuid.UUID
	clearedseries           bool
	ideas                   *uuid.UUID
	clearedideas            bool
	tags                    map[uuid.UUID]struct{}
	removedtags             map[uuid.UUID]struct{}
	clearedtags             bool
	translations            map[uuid.UUID]struct{}
	removedtranslations     map[uuid.UUID]struct{}
	clearedtranslations     bool
	comments                map[uuid.UUID]struct{}
	removedcomments         map[uuid.UUID]struct{}
	clearedcomments         bool
	done                    bool
	oldValue                func(context.Context) (*BlogPost, error)
	predicates              []predicate.BlogPost
}

var _ ent.Mutation = (*BlogPostMutation)(nil)

// blogpostOption allows management of the mutation configuration using functional options.
type blogpostOption func(*BlogPostMutation)

// newBlogPostMutation creates new mutation for the BlogPost entity.
func newBlogPostMutation(c config, op Op, opts ...blogpostOption) *BlogPostMutation {
	m := &BlogPostMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogPostID sets the ID field of the mutation.
func withBlogPostID(id uuid.UUID) blogpostOption {
	return func(m *BlogPostMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogPost
		)
		m.oldValue = func(ctx context.Context) (*BlogPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogPost sets the old BlogPost of the mutation.
func withBlogPost(node *BlogPost) blogpostOption {
	return func(m *BlogPostMutation) {
		m.oldValue = func(context.Context) (*BlogPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogPost entities.
func (m *BlogPostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogPostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogPostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *BlogPostMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *BlogPostMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *BlogPostMutation) ResetUserID() {
	m.user = nil
}

// SetCategoryID sets the "category_id" field.
func (m *BlogPostMutation) SetCategoryID(u uuid.UUID) {
	m.category = &u
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *BlogPostMutation) CategoryID() (r uuid.UUID, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldCategoryID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *BlogPostMutation) ClearCategoryID() {
	m.category = nil
	m.clearedFields[blogpost.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *BlogPostMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *BlogPostMutation) ResetCategoryID() {
	m.category = nil
	delete(m.clearedFields, blogpost.FieldCategoryID)
}

// SetSeriesID sets the "series_id" field.
func (m *BlogPostMutation) SetSeriesID(u uuid.UUID) {
	m.series = &u
}

// SeriesID returns the value of the "series_id" field in the mutation.
func (m *BlogPostMutation) SeriesID() (r uuid.UUID, exists bool) {
	v := m.series
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesID returns the old "series_id" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldSeriesID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesID: %w", err)
	}
	return oldValue.SeriesID, nil
}

// ClearSeriesID clears the value of the "series_id" field.
func (m *BlogPostMutation) ClearSeriesID() {
	m.series = nil
	m.clearedFields[blogpost.FieldSeriesID] = struct{}{}
}

// SeriesIDCleared returns if the "series_id" field was cleared in this mutation.
func (m *BlogPostMutation) SeriesIDCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldSeriesID]
	return ok
}

// ResetSeriesID resets all changes to the "series_id" field.
func (m *BlogPostMutation) ResetSeriesID() {
	m.series = nil
	delete(m.clearedFields, blogpost.FieldSeriesID)
}

// SetIdeasID sets the "ideas_id" field.
func (m *BlogPostMutation) SetIdeasID(u uuid.UUID) {
	m.ideas = &u
}

// IdeasID returns the value of the "ideas_id" field in the mutation.
func (m *BlogPostMutation) IdeasID() (r uuid.UUID, exists bool) {
	v := m.ideas
	if v == nil {
		return
	}
	return *v, true
}

// OldIdeasID returns the old "ideas_id" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldIdeasID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdeasID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdeasID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdeasID: %w", err)
	}
	return oldValue.IdeasID, nil
}

// ClearIdeasID clears the value of the "ideas_id" field.
func (m *BlogPostMutation) ClearIdeasID() {
	m.ideas = nil
	m.clearedFields[blogpost.FieldIdeasID] = struct{}{}
}

// IdeasIDCleared returns if the "ideas_id" field was cleared in this mutation.
func (m *BlogPostMutation) IdeasIDCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldIdeasID]
	return ok
}

// ResetIdeasID resets all changes to the "ideas_id" field.
func (m *BlogPostMutation) ResetIdeasID() {
	m.ideas = nil
	delete(m.clearedFields, blogpost.FieldIdeasID)
}

// SetTitle sets the "title" field.
func (m *BlogPostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogPostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogPostMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *BlogPostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogPostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogPostMutation) ResetSlug() {
	m.slug = nil
}

// SetExcerpt sets the "excerpt" field.
func (m *BlogPostMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *BlogPostMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *BlogPostMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[blogpost.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *BlogPostMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *BlogPostMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, blogpost.FieldExcerpt)
}

// SetContent sets the "content" field.
func (m *BlogPostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogPostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogPostMutation) ResetContent() {
	m.content = nil
}

// SetContentType sets the "content_type" field.
func (m *BlogPostMutation) SetContentType(bt blogpost.ContentType) {
	m.content_type = &bt
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *BlogPostMutation) ContentType() (r blogpost.ContentType, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldContentType(ctx context.Context) (v blogpost.ContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *BlogPostMutation) ResetContentType() {
	m.content_type = nil
}

// SetStatus sets the "status" field.
func (m *BlogPostMutation) SetStatus(b blogpost.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BlogPostMutation) Status() (r blogpost.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldStatus(ctx context.Context) (v blogpost.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BlogPostMutation) ResetStatus() {
	m.status = nil
}

// SetIsFeatured sets the "is_featured" field.
func (m *BlogPostMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *BlogPostMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *BlogPostMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// SetFeaturedImageURL sets the "featured_image_url" field.
func (m *BlogPostMutation) SetFeaturedImageURL(s string) {
	m.featured_image_url = &s
}

// FeaturedImageURL returns the value of the "featured_image_url" field in the mutation.
func (m *BlogPostMutation) FeaturedImageURL() (r string, exists bool) {
	v := m.featured_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedImageURL returns the old "featured_image_url" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldFeaturedImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedImageURL: %w", err)
	}
	return oldValue.FeaturedImageURL, nil
}

// ClearFeaturedImageURL clears the value of the "featured_image_url" field.
func (m *BlogPostMutation) ClearFeaturedImageURL() {
	m.featured_image_url = nil
	m.clearedFields[blogpost.FieldFeaturedImageURL] = struct{}{}
}

// FeaturedImageURLCleared returns if the "featured_image_url" field was cleared in this mutation.
func (m *BlogPostMutation) FeaturedImageURLCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldFeaturedImageURL]
	return ok
}

// ResetFeaturedImageURL resets all changes to the "featured_image_url" field.
func (m *BlogPostMutation) ResetFeaturedImageURL() {
	m.featured_image_url = nil
	delete(m.clearedFields, blogpost.FieldFeaturedImageURL)
}

// SetReadingTimeMinutes sets the "reading_time_minutes" field.
func (m *BlogPostMutation) SetReadingTimeMinutes(i int) {
	m.reading_time_minutes = &i
	m.addreading_time_minutes = nil
}

// ReadingTimeMinutes returns the value of the "reading_time_minutes" field in the mutation.
func (m *BlogPostMutation) ReadingTimeMinutes() (r int, exists bool) {
	v := m.reading_time_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingTimeMinutes returns the old "reading_time_minutes" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldReadingTimeMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingTimeMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingTimeMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingTimeMinutes: %w", err)
	}
	return oldValue.ReadingTimeMinutes, nil
}

// AddReadingTimeMinutes adds i to the "reading_time_minutes" field.
func (m *BlogPostMutation) AddReadingTimeMinutes(i int) {
	if m.addreading_time_minutes != nil {
		*m.addreading_time_minutes += i
	} else {
		m.addreading_time_minutes = &i
	}
}

// AddedReadingTimeMinutes returns the value that was added to the "reading_time_minutes" field in this mutation.
func (m *BlogPostMutation) AddedReadingTimeMinutes() (r int, exists bool) {
	v := m.addreading_time_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearReadingTimeMinutes clears the value of the "reading_time_minutes" field.
func (m *BlogPostMutation) ClearReadingTimeMinutes() {
	m.reading_time_minutes = nil
	m.addreading_time_minutes = nil
	m.clearedFields[blogpost.FieldReadingTimeMinutes] = struct{}{}
}

// ReadingTimeMinutesCleared returns if the "reading_time_minutes" field was cleared in this mutation.
func (m *BlogPostMutation) ReadingTimeMinutesCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldReadingTimeMinutes]
	return ok
}

// ResetReadingTimeMinutes resets all changes to the "reading_time_minutes" field.
func (m *BlogPostMutation) ResetReadingTimeMinutes() {
	m.reading_time_minutes = nil
	m.addreading_time_minutes = nil
	delete(m.clearedFields, blogpost.FieldReadingTimeMinutes)
}

// SetViewCount sets the "view_count" field.
func (m *BlogPostMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *BlogPostMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *BlogPostMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *BlogPostMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *BlogPostMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *BlogPostMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *BlogPostMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *BlogPostMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *BlogPostMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *BlogPostMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *BlogPostMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *BlogPostMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *BlogPostMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *BlogPostMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *BlogPostMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *BlogPostMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *BlogPostMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *BlogPostMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[blogpost.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *BlogPostMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *BlogPostMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, blogpost.FieldPublishedAt)
}

// SetSeriesOrder sets the "series_order" field.
func (m *BlogPostMutation) SetSeriesOrder(i int) {
	m.series_order = &i
	m.addseries_order = nil
}

// SeriesOrder returns the value of the "series_order" field in the mutation.
func (m *BlogPostMutation) SeriesOrder() (r int, exists bool) {
	v := m.series_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesOrder returns the old "series_order" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldSeriesOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesOrder: %w", err)
	}
	return oldValue.SeriesOrder, nil
}

// AddSeriesOrder adds i to the "series_order" field.
func (m *BlogPostMutation) AddSeriesOrder(i int) {
	if m.addseries_order != nil {
		*m.addseries_order += i
	} else {
		m.addseries_order = &i
	}
}

// AddedSeriesOrder returns the value that was added to the "series_order" field in this mutation.
func (m *BlogPostMutation) AddedSeriesOrder() (r int, exists bool) {
	v := m.addseries_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeriesOrder clears the value of the "series_order" field.
func (m *BlogPostMutation) ClearSeriesOrder() {
	m.series_order = nil
	m.addseries_order = nil
	m.clearedFields[blogpost.FieldSeriesOrder] = struct{}{}
}

// SeriesOrderCleared returns if the "series_order" field was cleared in this mutation.
func (m *BlogPostMutation) SeriesOrderCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldSeriesOrder]
	return ok
}

// ResetSeriesOrder resets all changes to the "series_order" field.
func (m *BlogPostMutation) ResetSeriesOrder() {
	m.series_order = nil
	m.addseries_order = nil
	delete(m.clearedFields, blogpost.FieldSeriesOrder)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogPostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogPostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogPostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogPostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *BlogPostMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[blogpost.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BlogPostMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BlogPostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCategory clears the "category" edge to the BlogCategory entity.
func (m *BlogPostMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[blogpost.FieldCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the BlogCategory entity was cleared.
func (m *BlogPostMutation) CategoryCleared() bool {
	return m.CategoryIDCleared() || m.clearedcategory
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) CategoryIDs() (ids []uuid.UUID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *BlogPostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// ClearSeries clears the "series" edge to the BlogSeries entity.
func (m *BlogPostMutation) ClearSeries() {
	m.clearedseries = true
	m.clearedFields[blogpost.FieldSeriesID] = struct{}{}
}

// SeriesCleared reports if the "series" edge to the BlogSeries entity was cleared.
func (m *BlogPostMutation) SeriesCleared() bool {
	return m.SeriesIDCleared() || m.clearedseries
}

// SeriesIDs returns the "series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeriesID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) SeriesIDs() (ids []uuid.UUID) {
	if id := m.series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *BlogPostMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
}

// ClearIdeas clears the "ideas" edge to the Idea entity.
func (m *BlogPostMutation) ClearIdeas() {
	m.clearedideas = true
	m.clearedFields[blogpost.FieldIdeasID] = struct{}{}
}

// IdeasCleared reports if the "ideas" edge to the Idea entity was cleared.
func (m *BlogPostMutation) IdeasCleared() bool {
	return m.IdeasIDCleared() || m.clearedideas
}

// IdeasIDs returns the "ideas" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdeasID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) IdeasIDs() (ids []uuid.UUID) {
	if id := m.ideas; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdeas resets all changes to the "ideas" edge.
func (m *BlogPostMutation) ResetIdeas() {
	m.ideas = nil
	m.clearedideas = false
}

// AddTagIDs adds the "tags" edge to the BlogTag entity by ids.
func (m *BlogPostMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the BlogTag entity.
func (m *BlogPostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the BlogTag entity was cleared.
func (m *BlogPostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the BlogTag entity by IDs.
func (m *BlogPostMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the BlogTag entity.
func (m *BlogPostMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *BlogPostMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *BlogPostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddTranslationIDs adds the "translations" edge to the BlogPostTranslation entity by ids.
func (m *BlogPostMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the BlogPostTranslation entity.
func (m *BlogPostMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the BlogPostTranslation entity was cleared.
func (m *BlogPostMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the BlogPostTranslation entity by IDs.
func (m *BlogPostMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the BlogPostTranslation entity.
func (m *BlogPostMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *BlogPostMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *BlogPostMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddCommentIDs adds the "comments" edge to the BlogComment entity by ids.
func (m *BlogPostMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the BlogComment entity.
func (m *BlogPostMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the BlogComment entity was cleared.
func (m *BlogPostMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the BlogComment entity by IDs.
func (m *BlogPostMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the BlogComment entity.
func (m *BlogPostMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *BlogPostMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *BlogPostMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the BlogPostMutation builder.
func (m *BlogPostMutation) Where(ps ...predicate.BlogPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogPost).
func (m *BlogPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogPostMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.user != nil {
		fields = append(fields, blogpost.FieldUserID)
	}
	if m.category != nil {
		fields = append(fields, blogpost.FieldCategoryID)
	}
	if m.series != nil {
		fields = append(fields, blogpost.FieldSeriesID)
	}
	if m.ideas != nil {
		fields = append(fields, blogpost.FieldIdeasID)
	}
	if m.title != nil {
		fields = append(fields, blogpost.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, blogpost.FieldSlug)
	}
	if m.excerpt != nil {
		fields = append(fields, blogpost.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, blogpost.FieldContent)
	}
	if m.content_type != nil {
		fields = append(fields, blogpost.FieldContentType)
	}
	if m.status != nil {
		fields = append(fields, blogpost.FieldStatus)
	}
	if m.is_featured != nil {
		fields = append(fields, blogpost.FieldIsFeatured)
	}
	if m.featured_image_url != nil {
		fields = append(fields, blogpost.FieldFeaturedImageURL)
	}
	if m.reading_time_minutes != nil {
		fields = append(fields, blogpost.FieldReadingTimeMinutes)
	}
	if m.view_count != nil {
		fields = append(fields, blogpost.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, blogpost.FieldLikeCount)
	}
	if m.comment_count != nil {
		fields = append(fields, blogpost.FieldCommentCount)
	}
	if m.published_at != nil {
		fields = append(fields, blogpost.FieldPublishedAt)
	}
	if m.series_order != nil {
		fields = append(fields, blogpost.FieldSeriesOrder)
	}
	if m.created_at != nil {
		fields = append(fields, blogpost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogpost.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogpost.FieldUserID:
		return m.UserID()
	case blogpost.FieldCategoryID:
		return m.CategoryID()
	case blogpost.FieldSeriesID:
		return m.SeriesID()
	case blogpost.FieldIdeasID:
		return m.IdeasID()
	case blogpost.FieldTitle:
		return m.Title()
	case blogpost.FieldSlug:
		return m.Slug()
	case blogpost.FieldExcerpt:
		return m.Excerpt()
	case blogpost.FieldContent:
		return m.Content()
	case blogpost.FieldContentType:
		return m.ContentType()
	case blogpost.FieldStatus:
		return m.Status()
	case blogpost.FieldIsFeatured:
		return m.IsFeatured()
	case blogpost.FieldFeaturedImageURL:
		return m.FeaturedImageURL()
	case blogpost.FieldReadingTimeMinutes:
		return m.ReadingTimeMinutes()
	case blogpost.FieldViewCount:
		return m.ViewCount()
	case blogpost.FieldLikeCount:
		return m.LikeCount()
	case blogpost.FieldCommentCount:
		return m.CommentCount()
	case blogpost.FieldPublishedAt:
		return m.PublishedAt()
	case blogpost.FieldSeriesOrder:
		return m.SeriesOrder()
	case blogpost.FieldCreatedAt:
		return m.CreatedAt()
	case blogpost.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogpost.FieldUserID:
		return m.OldUserID(ctx)
	case blogpost.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case blogpost.FieldSeriesID:
		return m.OldSeriesID(ctx)
	case blogpost.FieldIdeasID:
		return m.OldIdeasID(ctx)
	case blogpost.FieldTitle:
		return m.OldTitle(ctx)
	case blogpost.FieldSlug:
		return m.OldSlug(ctx)
	case blogpost.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case blogpost.FieldContent:
		return m.OldContent(ctx)
	case blogpost.FieldContentType:
		return m.OldContentType(ctx)
	case blogpost.FieldStatus:
		return m.OldStatus(ctx)
	case blogpost.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case blogpost.FieldFeaturedImageURL:
		return m.OldFeaturedImageURL(ctx)
	case blogpost.FieldReadingTimeMinutes:
		return m.OldReadingTimeMinutes(ctx)
	case blogpost.FieldViewCount:
		return m.OldViewCount(ctx)
	case blogpost.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case blogpost.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case blogpost.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case blogpost.FieldSeriesOrder:
		return m.OldSeriesOrder(ctx)
	case blogpost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogpost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogpost.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case blogpost.FieldCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case blogpost.FieldSeriesID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesID(v)
		return nil
	case blogpost.FieldIdeasID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdeasID(v)
		return nil
	case blogpost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogpost.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogpost.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case blogpost.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogpost.FieldContentType:
		v, ok := value.(blogpost.ContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case blogpost.FieldStatus:
		v, ok := value.(blogpost.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blogpost.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case blogpost.FieldFeaturedImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedImageURL(v)
		return nil
	case blogpost.FieldReadingTimeMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingTimeMinutes(v)
		return nil
	case blogpost.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case blogpost.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case blogpost.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case blogpost.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case blogpost.FieldSeriesOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesOrder(v)
		return nil
	case blogpost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogpost.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogPostMutation) AddedFields() []string {
	var fields []string
	if m.addreading_time_minutes != nil {
		fields = append(fields, blogpost.FieldReadingTimeMinutes)
	}
	if m.addview_count != nil {
		fields = append(fields, blogpost.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, blogpost.FieldLikeCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, blogpost.FieldCommentCount)
	}
	if m.addseries_order != nil {
		fields = append(fields, blogpost.FieldSeriesOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogPostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogpost.FieldReadingTimeMinutes:
		return m.AddedReadingTimeMinutes()
	case blogpost.FieldViewCount:
		return m.AddedViewCount()
	case blogpost.FieldLikeCount:
		return m.AddedLikeCount()
	case blogpost.FieldCommentCount:
		return m.AddedCommentCount()
	case blogpost.FieldSeriesOrder:
		return m.AddedSeriesOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogpost.FieldReadingTimeMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingTimeMinutes(v)
		return nil
	case blogpost.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case blogpost.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case blogpost.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case blogpost.FieldSeriesOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeriesOrder(v)
		return nil
	}
	return fmt.Errorf("unknown BlogPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogpost.FieldCategoryID) {
		fields = append(fields, blogpost.FieldCategoryID)
	}
	if m.FieldCleared(blogpost.FieldSeriesID) {
		fields = append(fields, blogpost.FieldSeriesID)
	}
	if m.FieldCleared(blogpost.FieldIdeasID) {
		fields = append(fields, blogpost.FieldIdeasID)
	}
	if m.FieldCleared(blogpost.FieldExcerpt) {
		fields = append(fields, blogpost.FieldExcerpt)
	}
	if m.FieldCleared(blogpost.FieldFeaturedImageURL) {
		fields = append(fields, blogpost.FieldFeaturedImageURL)
	}
	if m.FieldCleared(blogpost.FieldReadingTimeMinutes) {
		fields = append(fields, blogpost.FieldReadingTimeMinutes)
	}
	if m.FieldCleared(blogpost.FieldPublishedAt) {
		fields = append(fields, blogpost.FieldPublishedAt)
	}
	if m.FieldCleared(blogpost.FieldSeriesOrder) {
		fields = append(fields, blogpost.FieldSeriesOrder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogPostMutation) ClearField(name string) error {
	switch name {
	case blogpost.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	case blogpost.FieldSeriesID:
		m.ClearSeriesID()
		return nil
	case blogpost.FieldIdeasID:
		m.ClearIdeasID()
		return nil
	case blogpost.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case blogpost.FieldFeaturedImageURL:
		m.ClearFeaturedImageURL()
		return nil
	case blogpost.FieldReadingTimeMinutes:
		m.ClearReadingTimeMinutes()
		return nil
	case blogpost.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case blogpost.FieldSeriesOrder:
		m.ClearSeriesOrder()
		return nil
	}
	return fmt.Errorf("unknown BlogPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogPostMutation) ResetField(name string) error {
	switch name {
	case blogpost.FieldUserID:
		m.ResetUserID()
		return nil
	case blogpost.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case blogpost.FieldSeriesID:
		m.ResetSeriesID()
		return nil
	case blogpost.FieldIdeasID:
		m.ResetIdeasID()
		return nil
	case blogpost.FieldTitle:
		m.ResetTitle()
		return nil
	case blogpost.FieldSlug:
		m.ResetSlug()
		return nil
	case blogpost.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case blogpost.FieldContent:
		m.ResetContent()
		return nil
	case blogpost.FieldContentType:
		m.ResetContentType()
		return nil
	case blogpost.FieldStatus:
		m.ResetStatus()
		return nil
	case blogpost.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case blogpost.FieldFeaturedImageURL:
		m.ResetFeaturedImageURL()
		return nil
	case blogpost.FieldReadingTimeMinutes:
		m.ResetReadingTimeMinutes()
		return nil
	case blogpost.FieldViewCount:
		m.ResetViewCount()
		return nil
	case blogpost.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case blogpost.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case blogpost.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case blogpost.FieldSeriesOrder:
		m.ResetSeriesOrder()
		return nil
	case blogpost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogpost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.user != nil {
		edges = append(edges, blogpost.EdgeUser)
	}
	if m.category != nil {
		edges = append(edges, blogpost.EdgeCategory)
	}
	if m.series != nil {
		edges = append(edges, blogpost.EdgeSeries)
	}
	if m.ideas != nil {
		edges = append(edges, blogpost.EdgeIdeas)
	}
	if m.tags != nil {
		edges = append(edges, blogpost.EdgeTags)
	}
	if m.translations != nil {
		edges = append(edges, blogpost.EdgeTranslations)
	}
	if m.comments != nil {
		edges = append(edges, blogpost.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogpost.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeSeries:
		if id := m.series; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeIdeas:
		if id := m.ideas; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case blogpost.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case blogpost.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedtags != nil {
		edges = append(edges, blogpost.EdgeTags)
	}
	if m.removedtranslations != nil {
		edges = append(edges, blogpost.EdgeTranslations)
	}
	if m.removedcomments != nil {
		edges = append(edges, blogpost.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogpost.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case blogpost.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case blogpost.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareduser {
		edges = append(edges, blogpost.EdgeUser)
	}
	if m.clearedcategory {
		edges = append(edges, blogpost.EdgeCategory)
	}
	if m.clearedseries {
		edges = append(edges, blogpost.EdgeSeries)
	}
	if m.clearedideas {
		edges = append(edges, blogpost.EdgeIdeas)
	}
	if m.clearedtags {
		edges = append(edges, blogpost.EdgeTags)
	}
	if m.clearedtranslations {
		edges = append(edges, blogpost.EdgeTranslations)
	}
	if m.clearedcomments {
		edges = append(edges, blogpost.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogPostMutation) EdgeCleared(name string) bool {
	switch name {
	case blogpost.EdgeUser:
		return m.cleareduser
	case blogpost.EdgeCategory:
		return m.clearedcategory
	case blogpost.EdgeSeries:
		return m.clearedseries
	case blogpost.EdgeIdeas:
		return m.clearedideas
	case blogpost.EdgeTags:
		return m.clearedtags
	case blogpost.EdgeTranslations:
		return m.clearedtranslations
	case blogpost.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogPostMutation) ClearEdge(name string) error {
	switch name {
	case blogpost.EdgeUser:
		m.ClearUser()
		return nil
	case blogpost.EdgeCategory:
		m.ClearCategory()
		return nil
	case blogpost.EdgeSeries:
		m.ClearSeries()
		return nil
	case blogpost.EdgeIdeas:
		m.ClearIdeas()
		return nil
	}
	return fmt.Errorf("unknown BlogPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogPostMutation) ResetEdge(name string) error {
	switch name {
	case blogpost.EdgeUser:
		m.ResetUser()
		return nil
	case blogpost.EdgeCategory:
		m.ResetCategory()
		return nil
	case blogpost.EdgeSeries:
		m.ResetSeries()
		return nil
	case blogpost.EdgeIdeas:
		m.ResetIdeas()
		return nil
	case blogpost.EdgeTags:
		m.ResetTags()
		return nil
	case blogpost.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case blogpost.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown BlogPost edge %s", name)
}

// BlogPostTagMutation represents an operation that mutates the BlogPostTag nodes in the graph.
type BlogPostTagMutation struct {
	config
	op               Op
	typ              string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	blog_post        *uuid.UUID
	clearedblog_post bool
	blog_tag         *uuid.UUID
	clearedblog_tag  bool
	done             bool
	oldValue         func(context.Context) (*BlogPostTag, error)
	predicates       []predicate.BlogPostTag
}

var _ ent.Mutation = (*BlogPostTagMutation)(nil)

// blogposttagOption allows management of the mutation configuration using functional options.
type blogposttagOption func(*BlogPostTagMutation)

// newBlogPostTagMutation creates new mutation for the BlogPostTag entity.
func newBlogPostTagMutation(c config, op Op, opts ...blogposttagOption) *BlogPostTagMutation {
	m := &BlogPostTagMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogPostTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogPostTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogPostTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetBlogPostID sets the "blog_post_id" field.
func (m *BlogPostTagMutation) SetBlogPostID(u uuid.UUID) {
	m.blog_post = &u
}

// BlogPostID returns the value of the "blog_post_id" field in the mutation.
func (m *BlogPostTagMutation) BlogPostID() (r uuid.UUID, exists bool) {
	v := m.blog_post
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogPostID resets all changes to the "blog_post_id" field.
func (m *BlogPostTagMutation) ResetBlogPostID() {
	m.blog_post = nil
}

// SetBlogTagID sets the "blog_tag_id" field.
func (m *BlogPostTagMutation) SetBlogTagID(u uuid.UUID) {
	m.blog_tag = &u
}

// BlogTagID returns the value of the "blog_tag_id" field in the mutation.
func (m *BlogPostTagMutation) BlogTagID() (r uuid.UUID, exists bool) {
	v := m.blog_tag
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlogTagID resets all changes to the "blog_tag_id" field.
func (m *BlogPostTagMutation) ResetBlogTagID() {
	m.blog_tag = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogPostTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogPostTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogPostTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearBlogPost clears the "blog_post" edge to the BlogPost entity.
func (m *BlogPostTagMutation) ClearBlogPost() {
	m.clearedblog_post = true
	m.clearedFields[blogposttag.FieldBlogPostID] = struct{}{}
}

// BlogPostCleared reports if the "blog_post" edge to the BlogPost entity was cleared.
func (m *BlogPostTagMutation) BlogPostCleared() bool {
	return m.clearedblog_post
}

// BlogPostIDs returns the "blog_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogPostID instead. It exists only for internal usage by the builders.
func (m *BlogPostTagMutation) BlogPostIDs() (ids []uuid.UUID) {
	if id := m.blog_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlogPost resets all changes to the "blog_post" edge.
func (m *BlogPostTagMutation) ResetBlogPost() {
	m.blog_post = nil
	m.clearedblog_post = false
}

// ClearBlogTag clears the "blog_tag" edge to the BlogTag entity.
func (m *BlogPostTagMutation) ClearBlogTag() {
	m.clearedblog_tag = true
	m.clearedFields[blogposttag.FieldBlogTagID] = struct{}{}
}

// BlogTagCleared reports if the "blog_tag" edge to the BlogTag entity was cleared.
func (m *BlogPostTagMutation) BlogTagCleared() bool {
	return m.clearedblog_tag
}

// BlogTagIDs returns the "blog_tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogTagID instead. It exists only for internal usage by the builders.
func (m *BlogPostTagMutation) BlogTagIDs() (ids []uuid.UUID) {
	if id := m.blog_tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlogTag resets all changes to the "blog_tag" edge.
func (m *BlogPostTagMutation) ResetBlogTag() {
	m.blog_tag = nil
	m.clearedblog_tag = false
}

// Where appends a list predicates to the BlogPostTagMutation builder.
func (m *BlogPostTagMutation) Where(ps ...predicate.BlogPostTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogPostTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogPostTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogPostTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogPostTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogPostTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogPostTag).
func (m *BlogPostTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogPostTagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.blog_post != nil {
		fields = append(fields, blogposttag.FieldBlogPostID)
	}
	if m.blog_tag != nil {
		fields = append(fields, blogposttag.FieldBlogTagID)
	}
	if m.created_at != nil {
		fields = append(fields, blogposttag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogPostTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogposttag.FieldBlogPostID:
		return m.BlogPostID()
	case blogposttag.FieldBlogTagID:
		return m.BlogTagID()
	case blogposttag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogPostTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema BlogPostTag does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogposttag.FieldBlogPostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogPostID(v)
		return nil
	case blogposttag.FieldBlogTagID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogTagID(v)
		return nil
	case blogposttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogPostTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogPostTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogPostTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogPostTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogPostTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogPostTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogPostTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogPostTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogPostTagMutation) ResetField(name string) error {
	switch name {
	case blogposttag.FieldBlogPostID:
		m.ResetBlogPostID()
		return nil
	case blogposttag.FieldBlogTagID:
		m.ResetBlogTagID()
		return nil
	case blogposttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogPostTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blog_post != nil {
		edges = append(edges, blogposttag.EdgeBlogPost)
	}
	if m.blog_tag != nil {
		edges = append(edges, blogposttag.EdgeBlogTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogPostTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogposttag.EdgeBlogPost:
		if id := m.blog_post; id != nil {
			return []ent.Value{*id}
		}
	case blogposttag.EdgeBlogTag:
		if id := m.blog_tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogPostTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogPostTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogPostTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblog_post {
		edges = append(edges, blogposttag.EdgeBlogPost)
	}
	if m.clearedblog_tag {
		edges = append(edges, blogposttag.EdgeBlogTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogPostTagMutation) EdgeCleared(name string) bool {
	switch name {
	case blogposttag.EdgeBlogPost:
		return m.clearedblog_post
	case blogposttag.EdgeBlogTag:
		return m.clearedblog_tag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogPostTagMutation) ClearEdge(name string) error {
	switch name {
	case blogposttag.EdgeBlogPost:
		m.ClearBlogPost()
		return nil
	case blogposttag.EdgeBlogTag:
		m.ClearBlogTag()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogPostTagMutation) ResetEdge(name string) error {
	switch name {
	case blogposttag.EdgeBlogPost:
		m.ResetBlogPost()
		return nil
	case blogposttag.EdgeBlogTag:
		m.ResetBlogTag()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTag edge %s", name)
}

// BlogPostTranslationMutation represents an operation that mutates the BlogPostTranslation nodes in the graph.
type BlogPostTranslationMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	title            *string
	excerpt          *string
	content          *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	blog_post        *uuid.UUID
	clearedblog_post bool
	language         *string
	clearedlanguage  bool
	done             bool
	oldValue         func(context.Context) (*BlogPostTranslation, error)
	predicates       []predicate.BlogPostTranslation
}

var _ ent.Mutation = (*BlogPostTranslationMutation)(nil)

// blogposttranslationOption allows management of the mutation configuration using functional options.
type blogposttranslationOption func(*BlogPostTranslationMutation)

// newBlogPostTranslationMutation creates new mutation for the BlogPostTranslation entity.
func newBlogPostTranslationMutation(c config, op Op, opts ...blogposttranslationOption) *BlogPostTranslationMutation {
	m := &BlogPostTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogPostTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogPostTranslationID sets the ID field of the mutation.
func withBlogPostTranslationID(id uuid.UUID) blogposttranslationOption {
	return func(m *BlogPostTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogPostTranslation
		)
		m.oldValue = func(ctx context.Context) (*BlogPostTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogPostTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogPostTranslation sets the old BlogPostTranslation of the mutation.
func withBlogPostTranslation(node *BlogPostTranslation) blogposttranslationOption {
	return func(m *BlogPostTranslationMutation) {
		m.oldValue = func(context.Context) (*BlogPostTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogPostTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogPostTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogPostTranslation entities.
func (m *BlogPostTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogPostTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogPostTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogPostTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlogPostID sets the "blog_post_id" field.
func (m *BlogPostTranslationMutation) SetBlogPostID(u uuid.UUID) {
	m.blog_post = &u
}

// BlogPostID returns the value of the "blog_post_id" field in the mutation.
func (m *BlogPostTranslationMutation) BlogPostID() (r uuid.UUID, exists bool) {
	v := m.blog_post
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogPostID returns the old "blog_post_id" field's value of the BlogPostTranslation entity.
// If the BlogPostTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostTranslationMutation) OldBlogPostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogPostID: %w", err)
	}
	return oldValue.BlogPostID, nil
}

// ResetBlogPostID resets all changes to the "blog_post_id" field.
func (m *BlogPostTranslationMutation) ResetBlogPostID() {
	m.blog_post = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *BlogPostTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *BlogPostTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the BlogPostTranslation entity.
// If the BlogPostTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *BlogPostTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *BlogPostTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogPostTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlogPostTranslation entity.
// If the BlogPostTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogPostTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetExcerpt sets the "excerpt" field.
func (m *BlogPostTranslationMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *BlogPostTranslationMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the BlogPostTranslation entity.
// If the BlogPostTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostTranslationMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *BlogPostTranslationMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[blogposttranslation.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *BlogPostTranslationMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[blogposttranslation.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *BlogPostTranslationMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, blogposttranslation.FieldExcerpt)
}

// SetContent sets the "content" field.
func (m *BlogPostTranslationMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogPostTranslationMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogPostTranslation entity.
// If the BlogPostTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostTranslationMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogPostTranslationMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogPostTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogPostTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogPostTranslation entity.
// If the BlogPostTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogPostTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearBlogPost clears the "blog_post" edge to the BlogPost entity.
func (m *BlogPostTranslationMutation) ClearBlogPost() {
	m.clearedblog_post = true
	m.clearedFields[blogposttranslation.FieldBlogPostID] = struct{}{}
}

// BlogPostCleared reports if the "blog_post" edge to the BlogPost entity was cleared.
func (m *BlogPostTranslationMutation) BlogPostCleared() bool {
	return m.clearedblog_post
}

// BlogPostIDs returns the "blog_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogPostID instead. It exists only for internal usage by the builders.
func (m *BlogPostTranslationMutation) BlogPostIDs() (ids []uuid.UUID) {
	if id := m.blog_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlogPost resets all changes to the "blog_post" edge.
func (m *BlogPostTranslationMutation) ResetBlogPost() {
	m.blog_post = nil
	m.clearedblog_post = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *BlogPostTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *BlogPostTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[blogposttranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *BlogPostTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *BlogPostTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *BlogPostTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *BlogPostTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the BlogPostTranslationMutation builder.
func (m *BlogPostTranslationMutation) Where(ps ...predicate.BlogPostTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogPostTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogPostTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogPostTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogPostTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogPostTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogPostTranslation).
func (m *BlogPostTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogPostTranslationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.blog_post != nil {
		fields = append(fields, blogposttranslation.FieldBlogPostID)
	}
	if m.language != nil {
		fields = append(fields, blogposttranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, blogposttranslation.FieldTitle)
	}
	if m.excerpt != nil {
		fields = append(fields, blogposttranslation.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, blogposttranslation.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, blogposttranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogPostTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogposttranslation.FieldBlogPostID:
		return m.BlogPostID()
	case blogposttranslation.FieldLanguageCode:
		return m.LanguageCode()
	case blogposttranslation.FieldTitle:
		return m.Title()
	case blogposttranslation.FieldExcerpt:
		return m.Excerpt()
	case blogposttranslation.FieldContent:
		return m.Content()
	case blogposttranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogPostTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogposttranslation.FieldBlogPostID:
		return m.OldBlogPostID(ctx)
	case blogposttranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case blogposttranslation.FieldTitle:
		return m.OldTitle(ctx)
	case blogposttranslation.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case blogposttranslation.FieldContent:
		return m.OldContent(ctx)
	case blogposttranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogPostTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogposttranslation.FieldBlogPostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogPostID(v)
		return nil
	case blogposttranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case blogposttranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogposttranslation.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case blogposttranslation.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogposttranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogPostTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogPostTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogPostTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogPostTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogPostTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogposttranslation.FieldExcerpt) {
		fields = append(fields, blogposttranslation.FieldExcerpt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogPostTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogPostTranslationMutation) ClearField(name string) error {
	switch name {
	case blogposttranslation.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogPostTranslationMutation) ResetField(name string) error {
	switch name {
	case blogposttranslation.FieldBlogPostID:
		m.ResetBlogPostID()
		return nil
	case blogposttranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case blogposttranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case blogposttranslation.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case blogposttranslation.FieldContent:
		m.ResetContent()
		return nil
	case blogposttranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogPostTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blog_post != nil {
		edges = append(edges, blogposttranslation.EdgeBlogPost)
	}
	if m.language != nil {
		edges = append(edges, blogposttranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogPostTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogposttranslation.EdgeBlogPost:
		if id := m.blog_post; id != nil {
			return []ent.Value{*id}
		}
	case blogposttranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogPostTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogPostTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogPostTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblog_post {
		edges = append(edges, blogposttranslation.EdgeBlogPost)
	}
	if m.clearedlanguage {
		edges = append(edges, blogposttranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogPostTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case blogposttranslation.EdgeBlogPost:
		return m.clearedblog_post
	case blogposttranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogPostTranslationMutation) ClearEdge(name string) error {
	switch name {
	case blogposttranslation.EdgeBlogPost:
		m.ClearBlogPost()
		return nil
	case blogposttranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogPostTranslationMutation) ResetEdge(name string) error {
	switch name {
	case blogposttranslation.EdgeBlogPost:
		m.ResetBlogPost()
		return nil
	case blogposttranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown BlogPostTranslation edge %s", name)
}

// BlogSeriesMutation represents an operation that mutates the BlogSeries nodes in the graph.
type BlogSeriesMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	title               *string
	slug                *string
	description         *string
	thumbnail_url       *string
	status              *string
	episode_count       *int
	addepisode_count    *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	blog_posts          map[uuid.UUID]struct{}
	removedblog_posts   map[uuid.UUID]struct{}
	clearedblog_posts   bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	done                bool
	oldValue            func(context.Context) (*BlogSeries, error)
	predicates          []predicate.BlogSeries
}

var _ ent.Mutation = (*BlogSeriesMutation)(nil)

// blogseriesOption allows management of the mutation configuration using functional options.
type blogseriesOption func(*BlogSeriesMutation)

// newBlogSeriesMutation creates new mutation for the BlogSeries entity.
func newBlogSeriesMutation(c config, op Op, opts ...blogseriesOption) *BlogSeriesMutation {
	m := &BlogSeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogSeriesID sets the ID field of the mutation.
func withBlogSeriesID(id uuid.UUID) blogseriesOption {
	return func(m *BlogSeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogSeries
		)
		m.oldValue = func(ctx context.Context) (*BlogSeries, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogSeries.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogSeries sets the old BlogSeries of the mutation.
func withBlogSeries(node *BlogSeries) blogseriesOption {
	return func(m *BlogSeriesMutation) {
		m.oldValue = func(context.Context) (*BlogSeries, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogSeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogSeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogSeries entities.
func (m *BlogSeriesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogSeriesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogSeriesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogSeries.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *BlogSeriesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogSeriesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogSeriesMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *BlogSeriesMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogSeriesMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogSeriesMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BlogSeriesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogSeriesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogSeriesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogseries.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogSeriesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogseries.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogSeriesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogseries.FieldDescription)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *BlogSeriesMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *BlogSeriesMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *BlogSeriesMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[blogseries.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *BlogSeriesMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[blogseries.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *BlogSeriesMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, blogseries.FieldThumbnailURL)
}

// SetStatus sets the "status" field.
func (m *BlogSeriesMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *BlogSeriesMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BlogSeriesMutation) ResetStatus() {
	m.status = nil
}

// SetEpisodeCount sets the "episode_count" field.
func (m *BlogSeriesMutation) SetEpisodeCount(i int) {
	m.episode_count = &i
	m.addepisode_count = nil
}

// EpisodeCount returns the value of the "episode_count" field in the mutation.
func (m *BlogSeriesMutation) EpisodeCount() (r int, exists bool) {
	v := m.episode_count
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeCount returns the old "episode_count" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldEpisodeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeCount: %w", err)
	}
	return oldValue.EpisodeCount, nil
}

// AddEpisodeCount adds i to the "episode_count" field.
func (m *BlogSeriesMutation) AddEpisodeCount(i int) {
	if m.addepisode_count != nil {
		*m.addepisode_count += i
	} else {
		m.addepisode_count = &i
	}
}

// AddedEpisodeCount returns the value that was added to the "episode_count" field in this mutation.
func (m *BlogSeriesMutation) AddedEpisodeCount() (r int, exists bool) {
	v := m.addepisode_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeCount resets all changes to the "episode_count" field.
func (m *BlogSeriesMutation) ResetEpisodeCount() {
	m.episode_count = nil
	m.addepisode_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogSeriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogSeriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogSeriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogSeriesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogSeriesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogSeriesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *BlogSeriesMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *BlogSeriesMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *BlogSeriesMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *BlogSeriesMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *BlogSeriesMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *BlogSeriesMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *BlogSeriesMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// AddTranslationIDs adds the "translations" edge to the BlogSeriesTranslation entity by ids.
func (m *BlogSeriesMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the BlogSeriesTranslation entity.
func (m *BlogSeriesMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the BlogSeriesTranslation entity was cleared.
func (m *BlogSeriesMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the BlogSeriesTranslation entity by IDs.
func (m *BlogSeriesMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the BlogSeriesTranslation entity.
func (m *BlogSeriesMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *BlogSeriesMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *BlogSeriesMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the BlogSeriesMutation builder.
func (m *BlogSeriesMutation) Where(ps ...predicate.BlogSeries) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogSeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogSeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogSeries, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogSeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogSeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogSeries).
func (m *BlogSeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogSeriesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, blogseries.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, blogseries.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, blogseries.FieldDescription)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, blogseries.FieldThumbnailURL)
	}
	if m.status != nil {
		fields = append(fields, blogseries.FieldStatus)
	}
	if m.episode_count != nil {
		fields = append(fields, blogseries.FieldEpisodeCount)
	}
	if m.created_at != nil {
		fields = append(fields, blogseries.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogseries.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogSeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogseries.FieldTitle:
		return m.Title()
	case blogseries.FieldSlug:
		return m.Slug()
	case blogseries.FieldDescription:
		return m.Description()
	case blogseries.FieldThumbnailURL:
		return m.ThumbnailURL()
	case blogseries.FieldStatus:
		return m.Status()
	case blogseries.FieldEpisodeCount:
		return m.EpisodeCount()
	case blogseries.FieldCreatedAt:
		return m.CreatedAt()
	case blogseries.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogSeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogseries.FieldTitle:
		return m.OldTitle(ctx)
	case blogseries.FieldSlug:
		return m.OldSlug(ctx)
	case blogseries.FieldDescription:
		return m.OldDescription(ctx)
	case blogseries.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case blogseries.FieldStatus:
		return m.OldStatus(ctx)
	case blogseries.FieldEpisodeCount:
		return m.OldEpisodeCount(ctx)
	case blogseries.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogseries.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogSeries field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogSeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogseries.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogseries.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogseries.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogseries.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case blogseries.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blogseries.FieldEpisodeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeCount(v)
		return nil
	case blogseries.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogseries.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogSeries field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogSeriesMutation) AddedFields() []string {
	var fields []string
	if m.addepisode_count != nil {
		fields = append(fields, blogseries.FieldEpisodeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogSeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogseries.FieldEpisodeCount:
		return m.AddedEpisodeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogSeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogseries.FieldEpisodeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeCount(v)
		return nil
	}
	return fmt.Errorf("unknown BlogSeries numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogSeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogseries.FieldDescription) {
		fields = append(fields, blogseries.FieldDescription)
	}
	if m.FieldCleared(blogseries.FieldThumbnailURL) {
		fields = append(fields, blogseries.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogSeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogSeriesMutation) ClearField(name string) error {
	switch name {
	case blogseries.FieldDescription:
		m.ClearDescription()
		return nil
	case blogseries.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogSeriesMutation) ResetField(name string) error {
	switch name {
	case blogseries.FieldTitle:
		m.ResetTitle()
		return nil
	case blogseries.FieldSlug:
		m.ResetSlug()
		return nil
	case blogseries.FieldDescription:
		m.ResetDescription()
		return nil
	case blogseries.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case blogseries.FieldStatus:
		m.ResetStatus()
		return nil
	case blogseries.FieldEpisodeCount:
		m.ResetEpisodeCount()
		return nil
	case blogseries.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogseries.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogSeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blog_posts != nil {
		edges = append(edges, blogseries.EdgeBlogPosts)
	}
	if m.translations != nil {
		edges = append(edges, blogseries.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogSeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogseries.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	case blogseries.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogSeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblog_posts != nil {
		edges = append(edges, blogseries.EdgeBlogPosts)
	}
	if m.removedtranslations != nil {
		edges = append(edges, blogseries.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogSeriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogseries.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	case blogseries.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogSeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblog_posts {
		edges = append(edges, blogseries.EdgeBlogPosts)
	}
	if m.clearedtranslations {
		edges = append(edges, blogseries.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogSeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case blogseries.EdgeBlogPosts:
		return m.clearedblog_posts
	case blogseries.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogSeriesMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogSeries unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogSeriesMutation) ResetEdge(name string) error {
	switch name {
	case blogseries.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	case blogseries.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries edge %s", name)
}

// BlogSeriesTranslationMutation represents an operation that mutates the BlogSeriesTranslation nodes in the graph.
type BlogSeriesTranslationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	title              *string
	description        *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	blog_series        *uuid.UUID
	clearedblog_series bool
	language           *string
	clearedlanguage    bool
	done               bool
	oldValue           func(context.Context) (*BlogSeriesTranslation, error)
	predicates         []predicate.BlogSeriesTranslation
}

var _ ent.Mutation = (*BlogSeriesTranslationMutation)(nil)

// blogseriestranslationOption allows management of the mutation configuration using functional options.
type blogseriestranslationOption func(*BlogSeriesTranslationMutation)

// newBlogSeriesTranslationMutation creates new mutation for the BlogSeriesTranslation entity.
func newBlogSeriesTranslationMutation(c config, op Op, opts ...blogseriestranslationOption) *BlogSeriesTranslationMutation {
	m := &BlogSeriesTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogSeriesTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogSeriesTranslationID sets the ID field of the mutation.
func withBlogSeriesTranslationID(id uuid.UUID) blogseriestranslationOption {
	return func(m *BlogSeriesTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogSeriesTranslation
		)
		m.oldValue = func(ctx context.Context) (*BlogSeriesTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogSeriesTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogSeriesTranslation sets the old BlogSeriesTranslation of the mutation.
func withBlogSeriesTranslation(node *BlogSeriesTranslation) blogseriestranslationOption {
	return func(m *BlogSeriesTranslationMutation) {
		m.oldValue = func(context.Context) (*BlogSeriesTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogSeriesTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogSeriesTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogSeriesTranslation entities.
func (m *BlogSeriesTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogSeriesTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogSeriesTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogSeriesTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlogSeriesID sets the "blog_series_id" field.
func (m *BlogSeriesTranslationMutation) SetBlogSeriesID(u uuid.UUID) {
	m.blog_series = &u
}

// BlogSeriesID returns the value of the "blog_series_id" field in the mutation.
func (m *BlogSeriesTranslationMutation) BlogSeriesID() (r uuid.UUID, exists bool) {
	v := m.blog_series
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogSeriesID returns the old "blog_series_id" field's value of the BlogSeriesTranslation entity.
// If the BlogSeriesTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesTranslationMutation) OldBlogSeriesID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogSeriesID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogSeriesID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogSeriesID: %w", err)
	}
	return oldValue.BlogSeriesID, nil
}

// ResetBlogSeriesID resets all changes to the "blog_series_id" field.
func (m *BlogSeriesTranslationMutation) ResetBlogSeriesID() {
	m.blog_series = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *BlogSeriesTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *BlogSeriesTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the BlogSeriesTranslation entity.
// If the BlogSeriesTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *BlogSeriesTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *BlogSeriesTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogSeriesTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlogSeriesTranslation entity.
// If the BlogSeriesTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogSeriesTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *BlogSeriesTranslationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogSeriesTranslationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogSeriesTranslation entity.
// If the BlogSeriesTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesTranslationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogSeriesTranslationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogseriestranslation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogSeriesTranslationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogseriestranslation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogSeriesTranslationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogseriestranslation.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogSeriesTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogSeriesTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogSeriesTranslation entity.
// If the BlogSeriesTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogSeriesTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearBlogSeries clears the "blog_series" edge to the BlogSeries entity.
func (m *BlogSeriesTranslationMutation) ClearBlogSeries() {
	m.clearedblog_series = true
	m.clearedFields[blogseriestranslation.FieldBlogSeriesID] = struct{}{}
}

// BlogSeriesCleared reports if the "blog_series" edge to the BlogSeries entity was cleared.
func (m *BlogSeriesTranslationMutation) BlogSeriesCleared() bool {
	return m.clearedblog_series
}

// BlogSeriesIDs returns the "blog_series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlogSeriesID instead. It exists only for internal usage by the builders.
func (m *BlogSeriesTranslationMutation) BlogSeriesIDs() (ids []uuid.UUID) {
	if id := m.blog_series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlogSeries resets all changes to the "blog_series" edge.
func (m *BlogSeriesTranslationMutation) ResetBlogSeries() {
	m.blog_series = nil
	m.clearedblog_series = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *BlogSeriesTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *BlogSeriesTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[blogseriestranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *BlogSeriesTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *BlogSeriesTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *BlogSeriesTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *BlogSeriesTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the BlogSeriesTranslationMutation builder.
func (m *BlogSeriesTranslationMutation) Where(ps ...predicate.BlogSeriesTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogSeriesTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogSeriesTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogSeriesTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogSeriesTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogSeriesTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogSeriesTranslation).
func (m *BlogSeriesTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogSeriesTranslationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.blog_series != nil {
		fields = append(fields, blogseriestranslation.FieldBlogSeriesID)
	}
	if m.language != nil {
		fields = append(fields, blogseriestranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, blogseriestranslation.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, blogseriestranslation.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, blogseriestranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogSeriesTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogseriestranslation.FieldBlogSeriesID:
		return m.BlogSeriesID()
	case blogseriestranslation.FieldLanguageCode:
		return m.LanguageCode()
	case blogseriestranslation.FieldTitle:
		return m.Title()
	case blogseriestranslation.FieldDescription:
		return m.Description()
	case blogseriestranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogSeriesTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogseriestranslation.FieldBlogSeriesID:
		return m.OldBlogSeriesID(ctx)
	case blogseriestranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case blogseriestranslation.FieldTitle:
		return m.OldTitle(ctx)
	case blogseriestranslation.FieldDescription:
		return m.OldDescription(ctx)
	case blogseriestranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogSeriesTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogSeriesTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogseriestranslation.FieldBlogSeriesID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogSeriesID(v)
		return nil
	case blogseriestranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case blogseriestranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogseriestranslation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogseriestranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogSeriesTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogSeriesTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogSeriesTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogSeriesTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogSeriesTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogSeriesTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogseriestranslation.FieldDescription) {
		fields = append(fields, blogseriestranslation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogSeriesTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogSeriesTranslationMutation) ClearField(name string) error {
	switch name {
	case blogseriestranslation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown BlogSeriesTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogSeriesTranslationMutation) ResetField(name string) error {
	switch name {
	case blogseriestranslation.FieldBlogSeriesID:
		m.ResetBlogSeriesID()
		return nil
	case blogseriestranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case blogseriestranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case blogseriestranslation.FieldDescription:
		m.ResetDescription()
		return nil
	case blogseriestranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogSeriesTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogSeriesTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blog_series != nil {
		edges = append(edges, blogseriestranslation.EdgeBlogSeries)
	}
	if m.language != nil {
		edges = append(edges, blogseriestranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogSeriesTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogseriestranslation.EdgeBlogSeries:
		if id := m.blog_series; id != nil {
			return []ent.Value{*id}
		}
	case blogseriestranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogSeriesTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogSeriesTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogSeriesTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblog_series {
		edges = append(edges, blogseriestranslation.EdgeBlogSeries)
	}
	if m.clearedlanguage {
		edges = append(edges, blogseriestranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogSeriesTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case blogseriestranslation.EdgeBlogSeries:
		return m.clearedblog_series
	case blogseriestranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogSeriesTranslationMutation) ClearEdge(name string) error {
	switch name {
	case blogseriestranslation.EdgeBlogSeries:
		m.ClearBlogSeries()
		return nil
	case blogseriestranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown BlogSeriesTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogSeriesTranslationMutation) ResetEdge(name string) error {
	switch name {
	case blogseriestranslation.EdgeBlogSeries:
		m.ResetBlogSeries()
		return nil
	case blogseriestranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown BlogSeriesTranslation edge %s", name)
}

// BlogTagMutation represents an operation that mutates the BlogTag nodes in the graph.
type BlogTagMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	slug              *string
	usage_count       *int
	addusage_count    *int
	created_at        *time.Time
	clearedFields     map[string]struct{}
	blog_posts        map[uuid.UUID]struct{}
	removedblog_posts map[uuid.UUID]struct{}
	clearedblog_posts bool
	done              bool
	oldValue          func(context.Context) (*BlogTag, error)
	predicates        []predicate.BlogTag
}

var _ ent.Mutation = (*BlogTagMutation)(nil)

// blogtagOption allows management of the mutation configuration using functional options.
type blogtagOption func(*BlogTagMutation)

// newBlogTagMutation creates new mutation for the BlogTag entity.
func newBlogTagMutation(c config, op Op, opts ...blogtagOption) *BlogTagMutation {
	m := &BlogTagMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogTagID sets the ID field of the mutation.
func withBlogTagID(id uuid.UUID) blogtagOption {
	return func(m *BlogTagMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogTag
		)
		m.oldValue = func(ctx context.Context) (*BlogTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogTag sets the old BlogTag of the mutation.
func withBlogTag(node *BlogTag) blogtagOption {
	return func(m *BlogTagMutation) {
		m.oldValue = func(context.Context) (*BlogTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogTag entities.
func (m *BlogTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BlogTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlogTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlogTagMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *BlogTagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogTagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogTagMutation) ResetSlug() {
	m.slug = nil
}

// SetUsageCount sets the "usage_count" field.
func (m *BlogTagMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *BlogTagMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *BlogTagMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *BlogTagMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *BlogTagMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *BlogTagMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *BlogTagMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *BlogTagMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *BlogTagMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *BlogTagMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *BlogTagMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *BlogTagMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// Where appends a list predicates to the BlogTagMutation builder.
func (m *BlogTagMutation) Where(ps ...predicate.BlogTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogTag).
func (m *BlogTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogTagMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, blogtag.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, blogtag.FieldSlug)
	}
	if m.usage_count != nil {
		fields = append(fields, blogtag.FieldUsageCount)
	}
	if m.created_at != nil {
		fields = append(fields, blogtag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogtag.FieldName:
		return m.Name()
	case blogtag.FieldSlug:
		return m.Slug()
	case blogtag.FieldUsageCount:
		return m.UsageCount()
	case blogtag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogtag.FieldName:
		return m.OldName(ctx)
	case blogtag.FieldSlug:
		return m.OldSlug(ctx)
	case blogtag.FieldUsageCount:
		return m.OldUsageCount(ctx)
	case blogtag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogtag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blogtag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogtag.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	case blogtag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogTagMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, blogtag.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogtag.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogtag.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown BlogTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlogTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogTagMutation) ResetField(name string) error {
	switch name {
	case blogtag.FieldName:
		m.ResetName()
		return nil
	case blogtag.FieldSlug:
		m.ResetSlug()
		return nil
	case blogtag.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	case blogtag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.blog_posts != nil {
		edges = append(edges, blogtag.EdgeBlogPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogtag.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedblog_posts != nil {
		edges = append(edges, blogtag.EdgeBlogPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogtag.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblog_posts {
		edges = append(edges, blogtag.EdgeBlogPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogTagMutation) EdgeCleared(name string) bool {
	switch name {
	case blogtag.EdgeBlogPosts:
		return m.clearedblog_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogTagMutation) ResetEdge(name string) error {
	switch name {
	case blogtag.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	}
	return fmt.Errorf("unknown BlogTag edge %s", name)
}

// EducationMutation represents an operation that mutates the Education nodes in the graph.
type EducationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	institution          *string
	degree               *string
	field_of_study       *string
	start_date           *time.Time
	end_date             *time.Time
	is_current           *bool
	gpa                  *string
	location             *string
	institution_website  *string
	institution_logo_url *string
	sort_order           *int
	addsort_order        *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *uuid.UUID
	cleareduser          bool
	translations         map[uuid.UUID]struct{}
	removedtranslations  map[uuid.UUID]struct{}
	clearedtranslations  bool
	details              map[uuid.UUID]struct{}
	removeddetails       map[uuid.UUID]struct{}
	cleareddetails       bool
	done                 bool
	oldValue             func(context.Context) (*Education, error)
	predicates           []predicate.Education
}

var _ ent.Mutation = (*EducationMutation)(nil)

// educationOption allows management of the mutation configuration using functional options.
type educationOption func(*EducationMutation)

// newEducationMutation creates new mutation for the Education entity.
func newEducationMutation(c config, op Op, opts ...educationOption) *EducationMutation {
	m := &EducationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationID sets the ID field of the mutation.
func withEducationID(id uuid.UUID) educationOption {
	return func(m *EducationMutation) {
		var (
			err   error
			once  sync.Once
			value *Education
		)
		m.oldValue = func(ctx context.Context) (*Education, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Education.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducation sets the old Education of the mutation.
func withEducation(node *Education) educationOption {
	return func(m *EducationMutation) {
		m.oldValue = func(context.Context) (*Education, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Education entities.
func (m *EducationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Education.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *EducationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EducationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EducationMutation) ResetUserID() {
	m.user = nil
}

// SetInstitution sets the "institution" field.
func (m *EducationMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the value of the "institution" field in the mutation.
func (m *EducationMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old "institution" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ResetInstitution resets all changes to the "institution" field.
func (m *EducationMutation) ResetInstitution() {
	m.institution = nil
}

// SetDegree sets the "degree" field.
func (m *EducationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *EducationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ResetDegree resets all changes to the "degree" field.
func (m *EducationMutation) ResetDegree() {
	m.degree = nil
}

// SetFieldOfStudy sets the "field_of_study" field.
func (m *EducationMutation) SetFieldOfStudy(s string) {
	m.field_of_study = &s
}

// FieldOfStudy returns the value of the "field_of_study" field in the mutation.
func (m *EducationMutation) FieldOfStudy() (r string, exists bool) {
	v := m.field_of_study
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldOfStudy returns the old "field_of_study" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldFieldOfStudy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldOfStudy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldOfStudy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldOfStudy: %w", err)
	}
	return oldValue.FieldOfStudy, nil
}

// ClearFieldOfStudy clears the value of the "field_of_study" field.
func (m *EducationMutation) ClearFieldOfStudy() {
	m.field_of_study = nil
	m.clearedFields[education.FieldFieldOfStudy] = struct{}{}
}

// FieldOfStudyCleared returns if the "field_of_study" field was cleared in this mutation.
func (m *EducationMutation) FieldOfStudyCleared() bool {
	_, ok := m.clearedFields[education.FieldFieldOfStudy]
	return ok
}

// ResetFieldOfStudy resets all changes to the "field_of_study" field.
func (m *EducationMutation) ResetFieldOfStudy() {
	m.field_of_study = nil
	delete(m.clearedFields, education.FieldFieldOfStudy)
}

// SetStartDate sets the "start_date" field.
func (m *EducationMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EducationMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *EducationMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[education.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *EducationMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[education.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EducationMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, education.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *EducationMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EducationMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *EducationMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[education.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *EducationMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[education.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EducationMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, education.FieldEndDate)
}

// SetIsCurrent sets the "is_current" field.
func (m *EducationMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *EducationMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *EducationMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetGpa sets the "gpa" field.
func (m *EducationMutation) SetGpa(s string) {
	m.gpa = &s
}

// Gpa returns the value of the "gpa" field in the mutation.
func (m *EducationMutation) Gpa() (r string, exists bool) {
	v := m.gpa
	if v == nil {
		return
	}
	return *v, true
}

// OldGpa returns the old "gpa" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldGpa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpa: %w", err)
	}
	return oldValue.Gpa, nil
}

// ClearGpa clears the value of the "gpa" field.
func (m *EducationMutation) ClearGpa() {
	m.gpa = nil
	m.clearedFields[education.FieldGpa] = struct{}{}
}

// GpaCleared returns if the "gpa" field was cleared in this mutation.
func (m *EducationMutation) GpaCleared() bool {
	_, ok := m.clearedFields[education.FieldGpa]
	return ok
}

// ResetGpa resets all changes to the "gpa" field.
func (m *EducationMutation) ResetGpa() {
	m.gpa = nil
	delete(m.clearedFields, education.FieldGpa)
}

// SetLocation sets the "location" field.
func (m *EducationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EducationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *EducationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[education.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *EducationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[education.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *EducationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, education.FieldLocation)
}

// SetInstitutionWebsite sets the "institution_website" field.
func (m *EducationMutation) SetInstitutionWebsite(s string) {
	m.institution_website = &s
}

// InstitutionWebsite returns the value of the "institution_website" field in the mutation.
func (m *EducationMutation) InstitutionWebsite() (r string, exists bool) {
	v := m.institution_website
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionWebsite returns the old "institution_website" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitutionWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionWebsite: %w", err)
	}
	return oldValue.InstitutionWebsite, nil
}

// ClearInstitutionWebsite clears the value of the "institution_website" field.
func (m *EducationMutation) ClearInstitutionWebsite() {
	m.institution_website = nil
	m.clearedFields[education.FieldInstitutionWebsite] = struct{}{}
}

// InstitutionWebsiteCleared returns if the "institution_website" field was cleared in this mutation.
func (m *EducationMutation) InstitutionWebsiteCleared() bool {
	_, ok := m.clearedFields[education.FieldInstitutionWebsite]
	return ok
}

// ResetInstitutionWebsite resets all changes to the "institution_website" field.
func (m *EducationMutation) ResetInstitutionWebsite() {
	m.institution_website = nil
	delete(m.clearedFields, education.FieldInstitutionWebsite)
}

// SetInstitutionLogoURL sets the "institution_logo_url" field.
func (m *EducationMutation) SetInstitutionLogoURL(s string) {
	m.institution_logo_url = &s
}

// InstitutionLogoURL returns the value of the "institution_logo_url" field in the mutation.
func (m *EducationMutation) InstitutionLogoURL() (r string, exists bool) {
	v := m.institution_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionLogoURL returns the old "institution_logo_url" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitutionLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionLogoURL: %w", err)
	}
	return oldValue.InstitutionLogoURL, nil
}

// ClearInstitutionLogoURL clears the value of the "institution_logo_url" field.
func (m *EducationMutation) ClearInstitutionLogoURL() {
	m.institution_logo_url = nil
	m.clearedFields[education.FieldInstitutionLogoURL] = struct{}{}
}

// InstitutionLogoURLCleared returns if the "institution_logo_url" field was cleared in this mutation.
func (m *EducationMutation) InstitutionLogoURLCleared() bool {
	_, ok := m.clearedFields[education.FieldInstitutionLogoURL]
	return ok
}

// ResetInstitutionLogoURL resets all changes to the "institution_logo_url" field.
func (m *EducationMutation) ResetInstitutionLogoURL() {
	m.institution_logo_url = nil
	delete(m.clearedFields, education.FieldInstitutionLogoURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *EducationMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *EducationMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *EducationMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *EducationMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *EducationMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EducationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EducationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EducationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *EducationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[education.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EducationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EducationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EducationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the EducationTranslation entity by ids.
func (m *EducationMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the EducationTranslation entity.
func (m *EducationMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the EducationTranslation entity was cleared.
func (m *EducationMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the EducationTranslation entity by IDs.
func (m *EducationMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the EducationTranslation entity.
func (m *EducationMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *EducationMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *EducationMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddDetailIDs adds the "details" edge to the EducationDetail entity by ids.
func (m *EducationMutation) AddDetailIDs(ids ...uuid.UUID) {
	if m.details == nil {
		m.details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the EducationDetail entity.
func (m *EducationMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the EducationDetail entity was cleared.
func (m *EducationMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the EducationDetail entity by IDs.
func (m *EducationMutation) RemoveDetailIDs(ids ...uuid.UUID) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the EducationDetail entity.
func (m *EducationMutation) RemovedDetailsIDs() (ids []uuid.UUID) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *EducationMutation) DetailsIDs() (ids []uuid.UUID) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *EducationMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// Where appends a list predicates to the EducationMutation builder.
func (m *EducationMutation) Where(ps ...predicate.Education) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Education, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Education).
func (m *EducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.user != nil {
		fields = append(fields, education.FieldUserID)
	}
	if m.institution != nil {
		fields = append(fields, education.FieldInstitution)
	}
	if m.degree != nil {
		fields = append(fields, education.FieldDegree)
	}
	if m.field_of_study != nil {
		fields = append(fields, education.FieldFieldOfStudy)
	}
	if m.start_date != nil {
		fields = append(fields, education.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, education.FieldEndDate)
	}
	if m.is_current != nil {
		fields = append(fields, education.FieldIsCurrent)
	}
	if m.gpa != nil {
		fields = append(fields, education.FieldGpa)
	}
	if m.location != nil {
		fields = append(fields, education.FieldLocation)
	}
	if m.institution_website != nil {
		fields = append(fields, education.FieldInstitutionWebsite)
	}
	if m.institution_logo_url != nil {
		fields = append(fields, education.FieldInstitutionLogoURL)
	}
	if m.sort_order != nil {
		fields = append(fields, education.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, education.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, education.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case education.FieldUserID:
		return m.UserID()
	case education.FieldInstitution:
		return m.Institution()
	case education.FieldDegree:
		return m.Degree()
	case education.FieldFieldOfStudy:
		return m.FieldOfStudy()
	case education.FieldStartDate:
		return m.StartDate()
	case education.FieldEndDate:
		return m.EndDate()
	case education.FieldIsCurrent:
		return m.IsCurrent()
	case education.FieldGpa:
		return m.Gpa()
	case education.FieldLocation:
		return m.Location()
	case education.FieldInstitutionWebsite:
		return m.InstitutionWebsite()
	case education.FieldInstitutionLogoURL:
		return m.InstitutionLogoURL()
	case education.FieldSortOrder:
		return m.SortOrder()
	case education.FieldCreatedAt:
		return m.CreatedAt()
	case education.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case education.FieldUserID:
		return m.OldUserID(ctx)
	case education.FieldInstitution:
		return m.OldInstitution(ctx)
	case education.FieldDegree:
		return m.OldDegree(ctx)
	case education.FieldFieldOfStudy:
		return m.OldFieldOfStudy(ctx)
	case education.FieldStartDate:
		return m.OldStartDate(ctx)
	case education.FieldEndDate:
		return m.OldEndDate(ctx)
	case education.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case education.FieldGpa:
		return m.OldGpa(ctx)
	case education.FieldLocation:
		return m.OldLocation(ctx)
	case education.FieldInstitutionWebsite:
		return m.OldInstitutionWebsite(ctx)
	case education.FieldInstitutionLogoURL:
		return m.OldInstitutionLogoURL(ctx)
	case education.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case education.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case education.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Education field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case education.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case education.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	case education.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case education.FieldFieldOfStudy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldOfStudy(v)
		return nil
	case education.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case education.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case education.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case education.FieldGpa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpa(v)
		return nil
	case education.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case education.FieldInstitutionWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionWebsite(v)
		return nil
	case education.FieldInstitutionLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionLogoURL(v)
		return nil
	case education.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case education.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case education.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, education.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case education.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case education.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Education numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(education.FieldFieldOfStudy) {
		fields = append(fields, education.FieldFieldOfStudy)
	}
	if m.FieldCleared(education.FieldStartDate) {
		fields = append(fields, education.FieldStartDate)
	}
	if m.FieldCleared(education.FieldEndDate) {
		fields = append(fields, education.FieldEndDate)
	}
	if m.FieldCleared(education.FieldGpa) {
		fields = append(fields, education.FieldGpa)
	}
	if m.FieldCleared(education.FieldLocation) {
		fields = append(fields, education.FieldLocation)
	}
	if m.FieldCleared(education.FieldInstitutionWebsite) {
		fields = append(fields, education.FieldInstitutionWebsite)
	}
	if m.FieldCleared(education.FieldInstitutionLogoURL) {
		fields = append(fields, education.FieldInstitutionLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationMutation) ClearField(name string) error {
	switch name {
	case education.FieldFieldOfStudy:
		m.ClearFieldOfStudy()
		return nil
	case education.FieldStartDate:
		m.ClearStartDate()
		return nil
	case education.FieldEndDate:
		m.ClearEndDate()
		return nil
	case education.FieldGpa:
		m.ClearGpa()
		return nil
	case education.FieldLocation:
		m.ClearLocation()
		return nil
	case education.FieldInstitutionWebsite:
		m.ClearInstitutionWebsite()
		return nil
	case education.FieldInstitutionLogoURL:
		m.ClearInstitutionLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Education nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationMutation) ResetField(name string) error {
	switch name {
	case education.FieldUserID:
		m.ResetUserID()
		return nil
	case education.FieldInstitution:
		m.ResetInstitution()
		return nil
	case education.FieldDegree:
		m.ResetDegree()
		return nil
	case education.FieldFieldOfStudy:
		m.ResetFieldOfStudy()
		return nil
	case education.FieldStartDate:
		m.ResetStartDate()
		return nil
	case education.FieldEndDate:
		m.ResetEndDate()
		return nil
	case education.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case education.FieldGpa:
		m.ResetGpa()
		return nil
	case education.FieldLocation:
		m.ResetLocation()
		return nil
	case education.FieldInstitutionWebsite:
		m.ResetInstitutionWebsite()
		return nil
	case education.FieldInstitutionLogoURL:
		m.ResetInstitutionLogoURL()
		return nil
	case education.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case education.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case education.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, education.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, education.EdgeTranslations)
	}
	if m.details != nil {
		edges = append(edges, education.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case education.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case education.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtranslations != nil {
		edges = append(edges, education.EdgeTranslations)
	}
	if m.removeddetails != nil {
		edges = append(edges, education.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case education.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, education.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, education.EdgeTranslations)
	}
	if m.cleareddetails {
		edges = append(edges, education.EdgeDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationMutation) EdgeCleared(name string) bool {
	switch name {
	case education.EdgeUser:
		return m.cleareduser
	case education.EdgeTranslations:
		return m.clearedtranslations
	case education.EdgeDetails:
		return m.cleareddetails
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationMutation) ClearEdge(name string) error {
	switch name {
	case education.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Education unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationMutation) ResetEdge(name string) error {
	switch name {
	case education.EdgeUser:
		m.ResetUser()
		return nil
	case education.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case education.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown Education edge %s", name)
}

// EducationDetailMutation represents an operation that mutates the EducationDetail nodes in the graph.
type EducationDetailMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	detail_text         *string
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	education           *uuid.UUID
	clearededucation    bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	done                bool
	oldValue            func(context.Context) (*EducationDetail, error)
	predicates          []predicate.EducationDetail
}

var _ ent.Mutation = (*EducationDetailMutation)(nil)

// educationdetailOption allows management of the mutation configuration using functional options.
type educationdetailOption func(*EducationDetailMutation)

// newEducationDetailMutation creates new mutation for the EducationDetail entity.
func newEducationDetailMutation(c config, op Op, opts ...educationdetailOption) *EducationDetailMutation {
	m := &EducationDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationDetailID sets the ID field of the mutation.
func withEducationDetailID(id uuid.UUID) educationdetailOption {
	return func(m *EducationDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *EducationDetail
		)
		m.oldValue = func(ctx context.Context) (*EducationDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EducationDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationDetail sets the old EducationDetail of the mutation.
func withEducationDetail(node *EducationDetail) educationdetailOption {
	return func(m *EducationDetailMutation) {
		m.oldValue = func(context.Context) (*EducationDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EducationDetail entities.
func (m *EducationDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EducationDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEducationID sets the "education_id" field.
func (m *EducationDetailMutation) SetEducationID(u uuid.UUID) {
	m.education = &u
}

// EducationID returns the value of the "education_id" field in the mutation.
func (m *EducationDetailMutation) EducationID() (r uuid.UUID, exists bool) {
	v := m.education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationID returns the old "education_id" field's value of the EducationDetail entity.
// If the EducationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailMutation) OldEducationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationID: %w", err)
	}
	return oldValue.EducationID, nil
}

// ResetEducationID resets all changes to the "education_id" field.
func (m *EducationDetailMutation) ResetEducationID() {
	m.education = nil
}

// SetDetailText sets the "detail_text" field.
func (m *EducationDetailMutation) SetDetailText(s string) {
	m.detail_text = &s
}

// DetailText returns the value of the "detail_text" field in the mutation.
func (m *EducationDetailMutation) DetailText() (r string, exists bool) {
	v := m.detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailText returns the old "detail_text" field's value of the EducationDetail entity.
// If the EducationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailMutation) OldDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailText: %w", err)
	}
	return oldValue.DetailText, nil
}

// ResetDetailText resets all changes to the "detail_text" field.
func (m *EducationDetailMutation) ResetDetailText() {
	m.detail_text = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *EducationDetailMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *EducationDetailMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the EducationDetail entity.
// If the EducationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *EducationDetailMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *EducationDetailMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *EducationDetailMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EducationDetail entity.
// If the EducationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EducationDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EducationDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EducationDetail entity.
// If the EducationDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EducationDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearEducation clears the "education" edge to the Education entity.
func (m *EducationDetailMutation) ClearEducation() {
	m.clearededucation = true
	m.clearedFields[educationdetail.FieldEducationID] = struct{}{}
}

// EducationCleared reports if the "education" edge to the Education entity was cleared.
func (m *EducationDetailMutation) EducationCleared() bool {
	return m.clearededucation
}

// EducationIDs returns the "education" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EducationID instead. It exists only for internal usage by the builders.
func (m *EducationDetailMutation) EducationIDs() (ids []uuid.UUID) {
	if id := m.education; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEducation resets all changes to the "education" edge.
func (m *EducationDetailMutation) ResetEducation() {
	m.education = nil
	m.clearededucation = false
}

// AddTranslationIDs adds the "translations" edge to the EducationDetailTranslation entity by ids.
func (m *EducationDetailMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the EducationDetailTranslation entity.
func (m *EducationDetailMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the EducationDetailTranslation entity was cleared.
func (m *EducationDetailMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the EducationDetailTranslation entity by IDs.
func (m *EducationDetailMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the EducationDetailTranslation entity.
func (m *EducationDetailMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *EducationDetailMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *EducationDetailMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the EducationDetailMutation builder.
func (m *EducationDetailMutation) Where(ps ...predicate.EducationDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EducationDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EducationDetail).
func (m *EducationDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationDetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.education != nil {
		fields = append(fields, educationdetail.FieldEducationID)
	}
	if m.detail_text != nil {
		fields = append(fields, educationdetail.FieldDetailText)
	}
	if m.sort_order != nil {
		fields = append(fields, educationdetail.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, educationdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, educationdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationdetail.FieldEducationID:
		return m.EducationID()
	case educationdetail.FieldDetailText:
		return m.DetailText()
	case educationdetail.FieldSortOrder:
		return m.SortOrder()
	case educationdetail.FieldCreatedAt:
		return m.CreatedAt()
	case educationdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationdetail.FieldEducationID:
		return m.OldEducationID(ctx)
	case educationdetail.FieldDetailText:
		return m.OldDetailText(ctx)
	case educationdetail.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case educationdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case educationdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EducationDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationdetail.FieldEducationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationID(v)
		return nil
	case educationdetail.FieldDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailText(v)
		return nil
	case educationdetail.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case educationdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case educationdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EducationDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationDetailMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, educationdetail.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case educationdetail.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case educationdetail.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown EducationDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EducationDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationDetailMutation) ResetField(name string) error {
	switch name {
	case educationdetail.FieldEducationID:
		m.ResetEducationID()
		return nil
	case educationdetail.FieldDetailText:
		m.ResetDetailText()
		return nil
	case educationdetail.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case educationdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case educationdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EducationDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.education != nil {
		edges = append(edges, educationdetail.EdgeEducation)
	}
	if m.translations != nil {
		edges = append(edges, educationdetail.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationdetail.EdgeEducation:
		if id := m.education; id != nil {
			return []ent.Value{*id}
		}
	case educationdetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, educationdetail.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case educationdetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearededucation {
		edges = append(edges, educationdetail.EdgeEducation)
	}
	if m.clearedtranslations {
		edges = append(edges, educationdetail.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case educationdetail.EdgeEducation:
		return m.clearededucation
	case educationdetail.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationDetailMutation) ClearEdge(name string) error {
	switch name {
	case educationdetail.EdgeEducation:
		m.ClearEducation()
		return nil
	}
	return fmt.Errorf("unknown EducationDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationDetailMutation) ResetEdge(name string) error {
	switch name {
	case educationdetail.EdgeEducation:
		m.ResetEducation()
		return nil
	case educationdetail.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown EducationDetail edge %s", name)
}

// EducationDetailTranslationMutation represents an operation that mutates the EducationDetailTranslation nodes in the graph.
type EducationDetailTranslationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	detail_text             *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	education_detail        *uuid.UUID
	clearededucation_detail bool
	language                *string
	clearedlanguage         bool
	done                    bool
	oldValue                func(context.Context) (*EducationDetailTranslation, error)
	predicates              []predicate.EducationDetailTranslation
}

var _ ent.Mutation = (*EducationDetailTranslationMutation)(nil)

// educationdetailtranslationOption allows management of the mutation configuration using functional options.
type educationdetailtranslationOption func(*EducationDetailTranslationMutation)

// newEducationDetailTranslationMutation creates new mutation for the EducationDetailTranslation entity.
func newEducationDetailTranslationMutation(c config, op Op, opts ...educationdetailtranslationOption) *EducationDetailTranslationMutation {
	m := &EducationDetailTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationDetailTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationDetailTranslationID sets the ID field of the mutation.
func withEducationDetailTranslationID(id uuid.UUID) educationdetailtranslationOption {
	return func(m *EducationDetailTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *EducationDetailTranslation
		)
		m.oldValue = func(ctx context.Context) (*EducationDetailTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EducationDetailTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationDetailTranslation sets the old EducationDetailTranslation of the mutation.
func withEducationDetailTranslation(node *EducationDetailTranslation) educationdetailtranslationOption {
	return func(m *EducationDetailTranslationMutation) {
		m.oldValue = func(context.Context) (*EducationDetailTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationDetailTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationDetailTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EducationDetailTranslation entities.
func (m *EducationDetailTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationDetailTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationDetailTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EducationDetailTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEducationDetailID sets the "education_detail_id" field.
func (m *EducationDetailTranslationMutation) SetEducationDetailID(u uuid.UUID) {
	m.education_detail = &u
}

// EducationDetailID returns the value of the "education_detail_id" field in the mutation.
func (m *EducationDetailTranslationMutation) EducationDetailID() (r uuid.UUID, exists bool) {
	v := m.education_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationDetailID returns the old "education_detail_id" field's value of the EducationDetailTranslation entity.
// If the EducationDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailTranslationMutation) OldEducationDetailID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationDetailID: %w", err)
	}
	return oldValue.EducationDetailID, nil
}

// ResetEducationDetailID resets all changes to the "education_detail_id" field.
func (m *EducationDetailTranslationMutation) ResetEducationDetailID() {
	m.education_detail = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *EducationDetailTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *EducationDetailTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the EducationDetailTranslation entity.
// If the EducationDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *EducationDetailTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetDetailText sets the "detail_text" field.
func (m *EducationDetailTranslationMutation) SetDetailText(s string) {
	m.detail_text = &s
}

// DetailText returns the value of the "detail_text" field in the mutation.
func (m *EducationDetailTranslationMutation) DetailText() (r string, exists bool) {
	v := m.detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailText returns the old "detail_text" field's value of the EducationDetailTranslation entity.
// If the EducationDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailTranslationMutation) OldDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailText: %w", err)
	}
	return oldValue.DetailText, nil
}

// ResetDetailText resets all changes to the "detail_text" field.
func (m *EducationDetailTranslationMutation) ResetDetailText() {
	m.detail_text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationDetailTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationDetailTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EducationDetailTranslation entity.
// If the EducationDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationDetailTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationDetailTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearEducationDetail clears the "education_detail" edge to the EducationDetail entity.
func (m *EducationDetailTranslationMutation) ClearEducationDetail() {
	m.clearededucation_detail = true
	m.clearedFields[educationdetailtranslation.FieldEducationDetailID] = struct{}{}
}

// EducationDetailCleared reports if the "education_detail" edge to the EducationDetail entity was cleared.
func (m *EducationDetailTranslationMutation) EducationDetailCleared() bool {
	return m.clearededucation_detail
}

// EducationDetailIDs returns the "education_detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EducationDetailID instead. It exists only for internal usage by the builders.
func (m *EducationDetailTranslationMutation) EducationDetailIDs() (ids []uuid.UUID) {
	if id := m.education_detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEducationDetail resets all changes to the "education_detail" edge.
func (m *EducationDetailTranslationMutation) ResetEducationDetail() {
	m.education_detail = nil
	m.clearededucation_detail = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *EducationDetailTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *EducationDetailTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[educationdetailtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *EducationDetailTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *EducationDetailTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *EducationDetailTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *EducationDetailTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the EducationDetailTranslationMutation builder.
func (m *EducationDetailTranslationMutation) Where(ps ...predicate.EducationDetailTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationDetailTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationDetailTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EducationDetailTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationDetailTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationDetailTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EducationDetailTranslation).
func (m *EducationDetailTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationDetailTranslationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.education_detail != nil {
		fields = append(fields, educationdetailtranslation.FieldEducationDetailID)
	}
	if m.language != nil {
		fields = append(fields, educationdetailtranslation.FieldLanguageCode)
	}
	if m.detail_text != nil {
		fields = append(fields, educationdetailtranslation.FieldDetailText)
	}
	if m.created_at != nil {
		fields = append(fields, educationdetailtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationDetailTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationdetailtranslation.FieldEducationDetailID:
		return m.EducationDetailID()
	case educationdetailtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case educationdetailtranslation.FieldDetailText:
		return m.DetailText()
	case educationdetailtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationDetailTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationdetailtranslation.FieldEducationDetailID:
		return m.OldEducationDetailID(ctx)
	case educationdetailtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case educationdetailtranslation.FieldDetailText:
		return m.OldDetailText(ctx)
	case educationdetailtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EducationDetailTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationDetailTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationdetailtranslation.FieldEducationDetailID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationDetailID(v)
		return nil
	case educationdetailtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case educationdetailtranslation.FieldDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailText(v)
		return nil
	case educationdetailtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EducationDetailTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationDetailTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationDetailTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationDetailTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EducationDetailTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationDetailTranslationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationDetailTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationDetailTranslationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EducationDetailTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationDetailTranslationMutation) ResetField(name string) error {
	switch name {
	case educationdetailtranslation.FieldEducationDetailID:
		m.ResetEducationDetailID()
		return nil
	case educationdetailtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case educationdetailtranslation.FieldDetailText:
		m.ResetDetailText()
		return nil
	case educationdetailtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown EducationDetailTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationDetailTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.education_detail != nil {
		edges = append(edges, educationdetailtranslation.EdgeEducationDetail)
	}
	if m.language != nil {
		edges = append(edges, educationdetailtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationDetailTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationdetailtranslation.EdgeEducationDetail:
		if id := m.education_detail; id != nil {
			return []ent.Value{*id}
		}
	case educationdetailtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationDetailTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationDetailTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationDetailTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearededucation_detail {
		edges = append(edges, educationdetailtranslation.EdgeEducationDetail)
	}
	if m.clearedlanguage {
		edges = append(edges, educationdetailtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationDetailTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case educationdetailtranslation.EdgeEducationDetail:
		return m.clearededucation_detail
	case educationdetailtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationDetailTranslationMutation) ClearEdge(name string) error {
	switch name {
	case educationdetailtranslation.EdgeEducationDetail:
		m.ClearEducationDetail()
		return nil
	case educationdetailtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown EducationDetailTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationDetailTranslationMutation) ResetEdge(name string) error {
	switch name {
	case educationdetailtranslation.EdgeEducationDetail:
		m.ResetEducationDetail()
		return nil
	case educationdetailtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown EducationDetailTranslation edge %s", name)
}

// EducationTranslationMutation represents an operation that mutates the EducationTranslation nodes in the graph.
type EducationTranslationMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	institution      *string
	degree           *string
	field_of_study   *string
	location         *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	education        *uuid.UUID
	clearededucation bool
	language         *string
	clearedlanguage  bool
	done             bool
	oldValue         func(context.Context) (*EducationTranslation, error)
	predicates       []predicate.EducationTranslation
}

var _ ent.Mutation = (*EducationTranslationMutation)(nil)

// educationtranslationOption allows management of the mutation configuration using functional options.
type educationtranslationOption func(*EducationTranslationMutation)

// newEducationTranslationMutation creates new mutation for the EducationTranslation entity.
func newEducationTranslationMutation(c config, op Op, opts ...educationtranslationOption) *EducationTranslationMutation {
	m := &EducationTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducationTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationTranslationID sets the ID field of the mutation.
func withEducationTranslationID(id uuid.UUID) educationtranslationOption {
	return func(m *EducationTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *EducationTranslation
		)
		m.oldValue = func(ctx context.Context) (*EducationTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EducationTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducationTranslation sets the old EducationTranslation of the mutation.
func withEducationTranslation(node *EducationTranslation) educationtranslationOption {
	return func(m *EducationTranslationMutation) {
		m.oldValue = func(context.Context) (*EducationTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EducationTranslation entities.
func (m *EducationTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EducationTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEducationID sets the "education_id" field.
func (m *EducationTranslationMutation) SetEducationID(u uuid.UUID) {
	m.education = &u
}

// EducationID returns the value of the "education_id" field in the mutation.
func (m *EducationTranslationMutation) EducationID() (r uuid.UUID, exists bool) {
	v := m.education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducationID returns the old "education_id" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldEducationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducationID: %w", err)
	}
	return oldValue.EducationID, nil
}

// ResetEducationID resets all changes to the "education_id" field.
func (m *EducationTranslationMutation) ResetEducationID() {
	m.education = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *EducationTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *EducationTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *EducationTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetInstitution sets the "institution" field.
func (m *EducationTranslationMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the value of the "institution" field in the mutation.
func (m *EducationTranslationMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old "institution" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ClearInstitution clears the value of the "institution" field.
func (m *EducationTranslationMutation) ClearInstitution() {
	m.institution = nil
	m.clearedFields[educationtranslation.FieldInstitution] = struct{}{}
}

// InstitutionCleared returns if the "institution" field was cleared in this mutation.
func (m *EducationTranslationMutation) InstitutionCleared() bool {
	_, ok := m.clearedFields[educationtranslation.FieldInstitution]
	return ok
}

// ResetInstitution resets all changes to the "institution" field.
func (m *EducationTranslationMutation) ResetInstitution() {
	m.institution = nil
	delete(m.clearedFields, educationtranslation.FieldInstitution)
}

// SetDegree sets the "degree" field.
func (m *EducationTranslationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *EducationTranslationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ClearDegree clears the value of the "degree" field.
func (m *EducationTranslationMutation) ClearDegree() {
	m.degree = nil
	m.clearedFields[educationtranslation.FieldDegree] = struct{}{}
}

// DegreeCleared returns if the "degree" field was cleared in this mutation.
func (m *EducationTranslationMutation) DegreeCleared() bool {
	_, ok := m.clearedFields[educationtranslation.FieldDegree]
	return ok
}

// ResetDegree resets all changes to the "degree" field.
func (m *EducationTranslationMutation) ResetDegree() {
	m.degree = nil
	delete(m.clearedFields, educationtranslation.FieldDegree)
}

// SetFieldOfStudy sets the "field_of_study" field.
func (m *EducationTranslationMutation) SetFieldOfStudy(s string) {
	m.field_of_study = &s
}

// FieldOfStudy returns the value of the "field_of_study" field in the mutation.
func (m *EducationTranslationMutation) FieldOfStudy() (r string, exists bool) {
	v := m.field_of_study
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldOfStudy returns the old "field_of_study" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldFieldOfStudy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldOfStudy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldOfStudy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldOfStudy: %w", err)
	}
	return oldValue.FieldOfStudy, nil
}

// ClearFieldOfStudy clears the value of the "field_of_study" field.
func (m *EducationTranslationMutation) ClearFieldOfStudy() {
	m.field_of_study = nil
	m.clearedFields[educationtranslation.FieldFieldOfStudy] = struct{}{}
}

// FieldOfStudyCleared returns if the "field_of_study" field was cleared in this mutation.
func (m *EducationTranslationMutation) FieldOfStudyCleared() bool {
	_, ok := m.clearedFields[educationtranslation.FieldFieldOfStudy]
	return ok
}

// ResetFieldOfStudy resets all changes to the "field_of_study" field.
func (m *EducationTranslationMutation) ResetFieldOfStudy() {
	m.field_of_study = nil
	delete(m.clearedFields, educationtranslation.FieldFieldOfStudy)
}

// SetLocation sets the "location" field.
func (m *EducationTranslationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EducationTranslationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *EducationTranslationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[educationtranslation.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *EducationTranslationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[educationtranslation.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *EducationTranslationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, educationtranslation.FieldLocation)
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EducationTranslation entity.
// If the EducationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearEducation clears the "education" edge to the Education entity.
func (m *EducationTranslationMutation) ClearEducation() {
	m.clearededucation = true
	m.clearedFields[educationtranslation.FieldEducationID] = struct{}{}
}

// EducationCleared reports if the "education" edge to the Education entity was cleared.
func (m *EducationTranslationMutation) EducationCleared() bool {
	return m.clearededucation
}

// EducationIDs returns the "education" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EducationID instead. It exists only for internal usage by the builders.
func (m *EducationTranslationMutation) EducationIDs() (ids []uuid.UUID) {
	if id := m.education; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEducation resets all changes to the "education" edge.
func (m *EducationTranslationMutation) ResetEducation() {
	m.education = nil
	m.clearededucation = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *EducationTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *EducationTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[educationtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *EducationTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *EducationTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *EducationTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *EducationTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the EducationTranslationMutation builder.
func (m *EducationTranslationMutation) Where(ps ...predicate.EducationTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EducationTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EducationTranslation).
func (m *EducationTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationTranslationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.education != nil {
		fields = append(fields, educationtranslation.FieldEducationID)
	}
	if m.language != nil {
		fields = append(fields, educationtranslation.FieldLanguageCode)
	}
	if m.institution != nil {
		fields = append(fields, educationtranslation.FieldInstitution)
	}
	if m.degree != nil {
		fields = append(fields, educationtranslation.FieldDegree)
	}
	if m.field_of_study != nil {
		fields = append(fields, educationtranslation.FieldFieldOfStudy)
	}
	if m.location != nil {
		fields = append(fields, educationtranslation.FieldLocation)
	}
	if m.created_at != nil {
		fields = append(fields, educationtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case educationtranslation.FieldEducationID:
		return m.EducationID()
	case educationtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case educationtranslation.FieldInstitution:
		return m.Institution()
	case educationtranslation.FieldDegree:
		return m.Degree()
	case educationtranslation.FieldFieldOfStudy:
		return m.FieldOfStudy()
	case educationtranslation.FieldLocation:
		return m.Location()
	case educationtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case educationtranslation.FieldEducationID:
		return m.OldEducationID(ctx)
	case educationtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case educationtranslation.FieldInstitution:
		return m.OldInstitution(ctx)
	case educationtranslation.FieldDegree:
		return m.OldDegree(ctx)
	case educationtranslation.FieldFieldOfStudy:
		return m.OldFieldOfStudy(ctx)
	case educationtranslation.FieldLocation:
		return m.OldLocation(ctx)
	case educationtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EducationTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case educationtranslation.FieldEducationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducationID(v)
		return nil
	case educationtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case educationtranslation.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	case educationtranslation.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case educationtranslation.FieldFieldOfStudy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldOfStudy(v)
		return nil
	case educationtranslation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case educationtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EducationTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EducationTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(educationtranslation.FieldInstitution) {
		fields = append(fields, educationtranslation.FieldInstitution)
	}
	if m.FieldCleared(educationtranslation.FieldDegree) {
		fields = append(fields, educationtranslation.FieldDegree)
	}
	if m.FieldCleared(educationtranslation.FieldFieldOfStudy) {
		fields = append(fields, educationtranslation.FieldFieldOfStudy)
	}
	if m.FieldCleared(educationtranslation.FieldLocation) {
		fields = append(fields, educationtranslation.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationTranslationMutation) ClearField(name string) error {
	switch name {
	case educationtranslation.FieldInstitution:
		m.ClearInstitution()
		return nil
	case educationtranslation.FieldDegree:
		m.ClearDegree()
		return nil
	case educationtranslation.FieldFieldOfStudy:
		m.ClearFieldOfStudy()
		return nil
	case educationtranslation.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown EducationTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationTranslationMutation) ResetField(name string) error {
	switch name {
	case educationtranslation.FieldEducationID:
		m.ResetEducationID()
		return nil
	case educationtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case educationtranslation.FieldInstitution:
		m.ResetInstitution()
		return nil
	case educationtranslation.FieldDegree:
		m.ResetDegree()
		return nil
	case educationtranslation.FieldFieldOfStudy:
		m.ResetFieldOfStudy()
		return nil
	case educationtranslation.FieldLocation:
		m.ResetLocation()
		return nil
	case educationtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown EducationTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.education != nil {
		edges = append(edges, educationtranslation.EdgeEducation)
	}
	if m.language != nil {
		edges = append(edges, educationtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case educationtranslation.EdgeEducation:
		if id := m.education; id != nil {
			return []ent.Value{*id}
		}
	case educationtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearededucation {
		edges = append(edges, educationtranslation.EdgeEducation)
	}
	if m.clearedlanguage {
		edges = append(edges, educationtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case educationtranslation.EdgeEducation:
		return m.clearededucation
	case educationtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationTranslationMutation) ClearEdge(name string) error {
	switch name {
	case educationtranslation.EdgeEducation:
		m.ClearEducation()
		return nil
	case educationtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown EducationTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationTranslationMutation) ResetEdge(name string) error {
	switch name {
	case educationtranslation.EdgeEducation:
		m.ResetEducation()
		return nil
	case educationtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown EducationTranslation edge %s", name)
}

// IdeaMutation represents an operation that mutates the Idea nodes in the graph.
type IdeaMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	title                        *string
	slug                         *string
	abstract                     *string
	motivation                   *string
	methodology                  *string
	expected_outcome             *string
	status                       *idea.Status
	priority                     *idea.Priority
	estimated_duration_months    *int
	addestimated_duration_months *int
	required_resources           *string
	collaboration_needed         *bool
	funding_required             *bool
	estimated_budget             *float64
	addestimated_budget          *float64
	is_public                    *bool
	view_count                   *int
	addview_count                *int
	like_count                   *int
	addlike_count                *int
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	user                         *uuid.UUID
	cleareduser                  bool
	translations                 map[uuid.UUID]struct{}
	removedtranslations          map[uuid.UUID]struct{}
	clearedtranslations          bool
	blog_posts                   map[uuid.UUID]struct{}
	removedblog_posts            map[uuid.UUID]struct{}
	clearedblog_posts            bool
	done                         bool
	oldValue                     func(context.Context) (*Idea, error)
	predicates                   []predicate.Idea
}

var _ ent.Mutation = (*IdeaMutation)(nil)

// ideaOption allows management of the mutation configuration using functional options.
type ideaOption func(*IdeaMutation)

// newIdeaMutation creates new mutation for the Idea entity.
func newIdeaMutation(c config, op Op, opts ...ideaOption) *IdeaMutation {
	m := &IdeaMutation{
		config:        c,
		op:            op,
		typ:           TypeIdea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdeaID sets the ID field of the mutation.
func withIdeaID(id uuid.UUID) ideaOption {
	return func(m *IdeaMutation) {
		var (
			err   error
			once  sync.Once
			value *Idea
		)
		m.oldValue = func(ctx context.Context) (*Idea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Idea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdea sets the old Idea of the mutation.
func withIdea(node *Idea) ideaOption {
	return func(m *IdeaMutation) {
		m.oldValue = func(context.Context) (*Idea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdeaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdeaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Idea entities.
func (m *IdeaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdeaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdeaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Idea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *IdeaMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *IdeaMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *IdeaMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *IdeaMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IdeaMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IdeaMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *IdeaMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *IdeaMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *IdeaMutation) ResetSlug() {
	m.slug = nil
}

// SetAbstract sets the "abstract" field.
func (m *IdeaMutation) SetAbstract(s string) {
	m.abstract = &s
}

// Abstract returns the value of the "abstract" field in the mutation.
func (m *IdeaMutation) Abstract() (r string, exists bool) {
	v := m.abstract
	if v == nil {
		return
	}
	return *v, true
}

// OldAbstract returns the old "abstract" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldAbstract(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbstract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbstract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbstract: %w", err)
	}
	return oldValue.Abstract, nil
}

// ClearAbstract clears the value of the "abstract" field.
func (m *IdeaMutation) ClearAbstract() {
	m.abstract = nil
	m.clearedFields[idea.FieldAbstract] = struct{}{}
}

// AbstractCleared returns if the "abstract" field was cleared in this mutation.
func (m *IdeaMutation) AbstractCleared() bool {
	_, ok := m.clearedFields[idea.FieldAbstract]
	return ok
}

// ResetAbstract resets all changes to the "abstract" field.
func (m *IdeaMutation) ResetAbstract() {
	m.abstract = nil
	delete(m.clearedFields, idea.FieldAbstract)
}

// SetMotivation sets the "motivation" field.
func (m *IdeaMutation) SetMotivation(s string) {
	m.motivation = &s
}

// Motivation returns the value of the "motivation" field in the mutation.
func (m *IdeaMutation) Motivation() (r string, exists bool) {
	v := m.motivation
	if v == nil {
		return
	}
	return *v, true
}

// OldMotivation returns the old "motivation" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldMotivation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotivation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotivation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotivation: %w", err)
	}
	return oldValue.Motivation, nil
}

// ClearMotivation clears the value of the "motivation" field.
func (m *IdeaMutation) ClearMotivation() {
	m.motivation = nil
	m.clearedFields[idea.FieldMotivation] = struct{}{}
}

// MotivationCleared returns if the "motivation" field was cleared in this mutation.
func (m *IdeaMutation) MotivationCleared() bool {
	_, ok := m.clearedFields[idea.FieldMotivation]
	return ok
}

// ResetMotivation resets all changes to the "motivation" field.
func (m *IdeaMutation) ResetMotivation() {
	m.motivation = nil
	delete(m.clearedFields, idea.FieldMotivation)
}

// SetMethodology sets the "methodology" field.
func (m *IdeaMutation) SetMethodology(s string) {
	m.methodology = &s
}

// Methodology returns the value of the "methodology" field in the mutation.
func (m *IdeaMutation) Methodology() (r string, exists bool) {
	v := m.methodology
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodology returns the old "methodology" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldMethodology(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethodology is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethodology requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodology: %w", err)
	}
	return oldValue.Methodology, nil
}

// ClearMethodology clears the value of the "methodology" field.
func (m *IdeaMutation) ClearMethodology() {
	m.methodology = nil
	m.clearedFields[idea.FieldMethodology] = struct{}{}
}

// MethodologyCleared returns if the "methodology" field was cleared in this mutation.
func (m *IdeaMutation) MethodologyCleared() bool {
	_, ok := m.clearedFields[idea.FieldMethodology]
	return ok
}

// ResetMethodology resets all changes to the "methodology" field.
func (m *IdeaMutation) ResetMethodology() {
	m.methodology = nil
	delete(m.clearedFields, idea.FieldMethodology)
}

// SetExpectedOutcome sets the "expected_outcome" field.
func (m *IdeaMutation) SetExpectedOutcome(s string) {
	m.expected_outcome = &s
}

// ExpectedOutcome returns the value of the "expected_outcome" field in the mutation.
func (m *IdeaMutation) ExpectedOutcome() (r string, exists bool) {
	v := m.expected_outcome
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedOutcome returns the old "expected_outcome" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldExpectedOutcome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedOutcome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedOutcome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedOutcome: %w", err)
	}
	return oldValue.ExpectedOutcome, nil
}

// ClearExpectedOutcome clears the value of the "expected_outcome" field.
func (m *IdeaMutation) ClearExpectedOutcome() {
	m.expected_outcome = nil
	m.clearedFields[idea.FieldExpectedOutcome] = struct{}{}
}

// ExpectedOutcomeCleared returns if the "expected_outcome" field was cleared in this mutation.
func (m *IdeaMutation) ExpectedOutcomeCleared() bool {
	_, ok := m.clearedFields[idea.FieldExpectedOutcome]
	return ok
}

// ResetExpectedOutcome resets all changes to the "expected_outcome" field.
func (m *IdeaMutation) ResetExpectedOutcome() {
	m.expected_outcome = nil
	delete(m.clearedFields, idea.FieldExpectedOutcome)
}

// SetStatus sets the "status" field.
func (m *IdeaMutation) SetStatus(i idea.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IdeaMutation) Status() (r idea.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldStatus(ctx context.Context) (v idea.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IdeaMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *IdeaMutation) SetPriority(i idea.Priority) {
	m.priority = &i
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IdeaMutation) Priority() (r idea.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldPriority(ctx context.Context) (v idea.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *IdeaMutation) ResetPriority() {
	m.priority = nil
}

// SetEstimatedDurationMonths sets the "estimated_duration_months" field.
func (m *IdeaMutation) SetEstimatedDurationMonths(i int) {
	m.estimated_duration_months = &i
	m.addestimated_duration_months = nil
}

// EstimatedDurationMonths returns the value of the "estimated_duration_months" field in the mutation.
func (m *IdeaMutation) EstimatedDurationMonths() (r int, exists bool) {
	v := m.estimated_duration_months
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedDurationMonths returns the old "estimated_duration_months" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldEstimatedDurationMonths(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedDurationMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedDurationMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedDurationMonths: %w", err)
	}
	return oldValue.EstimatedDurationMonths, nil
}

// AddEstimatedDurationMonths adds i to the "estimated_duration_months" field.
func (m *IdeaMutation) AddEstimatedDurationMonths(i int) {
	if m.addestimated_duration_months != nil {
		*m.addestimated_duration_months += i
	} else {
		m.addestimated_duration_months = &i
	}
}

// AddedEstimatedDurationMonths returns the value that was added to the "estimated_duration_months" field in this mutation.
func (m *IdeaMutation) AddedEstimatedDurationMonths() (r int, exists bool) {
	v := m.addestimated_duration_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedDurationMonths clears the value of the "estimated_duration_months" field.
func (m *IdeaMutation) ClearEstimatedDurationMonths() {
	m.estimated_duration_months = nil
	m.addestimated_duration_months = nil
	m.clearedFields[idea.FieldEstimatedDurationMonths] = struct{}{}
}

// EstimatedDurationMonthsCleared returns if the "estimated_duration_months" field was cleared in this mutation.
func (m *IdeaMutation) EstimatedDurationMonthsCleared() bool {
	_, ok := m.clearedFields[idea.FieldEstimatedDurationMonths]
	return ok
}

// ResetEstimatedDurationMonths resets all changes to the "estimated_duration_months" field.
func (m *IdeaMutation) ResetEstimatedDurationMonths() {
	m.estimated_duration_months = nil
	m.addestimated_duration_months = nil
	delete(m.clearedFields, idea.FieldEstimatedDurationMonths)
}

// SetRequiredResources sets the "required_resources" field.
func (m *IdeaMutation) SetRequiredResources(s string) {
	m.required_resources = &s
}

// RequiredResources returns the value of the "required_resources" field in the mutation.
func (m *IdeaMutation) RequiredResources() (r string, exists bool) {
	v := m.required_resources
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredResources returns the old "required_resources" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldRequiredResources(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredResources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredResources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredResources: %w", err)
	}
	return oldValue.RequiredResources, nil
}

// ClearRequiredResources clears the value of the "required_resources" field.
func (m *IdeaMutation) ClearRequiredResources() {
	m.required_resources = nil
	m.clearedFields[idea.FieldRequiredResources] = struct{}{}
}

// RequiredResourcesCleared returns if the "required_resources" field was cleared in this mutation.
func (m *IdeaMutation) RequiredResourcesCleared() bool {
	_, ok := m.clearedFields[idea.FieldRequiredResources]
	return ok
}

// ResetRequiredResources resets all changes to the "required_resources" field.
func (m *IdeaMutation) ResetRequiredResources() {
	m.required_resources = nil
	delete(m.clearedFields, idea.FieldRequiredResources)
}

// SetCollaborationNeeded sets the "collaboration_needed" field.
func (m *IdeaMutation) SetCollaborationNeeded(b bool) {
	m.collaboration_needed = &b
}

// CollaborationNeeded returns the value of the "collaboration_needed" field in the mutation.
func (m *IdeaMutation) CollaborationNeeded() (r bool, exists bool) {
	v := m.collaboration_needed
	if v == nil {
		return
	}
	return *v, true
}

// OldCollaborationNeeded returns the old "collaboration_needed" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldCollaborationNeeded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollaborationNeeded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollaborationNeeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollaborationNeeded: %w", err)
	}
	return oldValue.CollaborationNeeded, nil
}

// ResetCollaborationNeeded resets all changes to the "collaboration_needed" field.
func (m *IdeaMutation) ResetCollaborationNeeded() {
	m.collaboration_needed = nil
}

// SetFundingRequired sets the "funding_required" field.
func (m *IdeaMutation) SetFundingRequired(b bool) {
	m.funding_required = &b
}

// FundingRequired returns the value of the "funding_required" field in the mutation.
func (m *IdeaMutation) FundingRequired() (r bool, exists bool) {
	v := m.funding_required
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingRequired returns the old "funding_required" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldFundingRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingRequired: %w", err)
	}
	return oldValue.FundingRequired, nil
}

// ResetFundingRequired resets all changes to the "funding_required" field.
func (m *IdeaMutation) ResetFundingRequired() {
	m.funding_required = nil
}

// SetEstimatedBudget sets the "estimated_budget" field.
func (m *IdeaMutation) SetEstimatedBudget(f float64) {
	m.estimated_budget = &f
	m.addestimated_budget = nil
}

// EstimatedBudget returns the value of the "estimated_budget" field in the mutation.
func (m *IdeaMutation) EstimatedBudget() (r float64, exists bool) {
	v := m.estimated_budget
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedBudget returns the old "estimated_budget" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldEstimatedBudget(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedBudget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedBudget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedBudget: %w", err)
	}
	return oldValue.EstimatedBudget, nil
}

// AddEstimatedBudget adds f to the "estimated_budget" field.
func (m *IdeaMutation) AddEstimatedBudget(f float64) {
	if m.addestimated_budget != nil {
		*m.addestimated_budget += f
	} else {
		m.addestimated_budget = &f
	}
}

// AddedEstimatedBudget returns the value that was added to the "estimated_budget" field in this mutation.
func (m *IdeaMutation) AddedEstimatedBudget() (r float64, exists bool) {
	v := m.addestimated_budget
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedBudget clears the value of the "estimated_budget" field.
func (m *IdeaMutation) ClearEstimatedBudget() {
	m.estimated_budget = nil
	m.addestimated_budget = nil
	m.clearedFields[idea.FieldEstimatedBudget] = struct{}{}
}

// EstimatedBudgetCleared returns if the "estimated_budget" field was cleared in this mutation.
func (m *IdeaMutation) EstimatedBudgetCleared() bool {
	_, ok := m.clearedFields[idea.FieldEstimatedBudget]
	return ok
}

// ResetEstimatedBudget resets all changes to the "estimated_budget" field.
func (m *IdeaMutation) ResetEstimatedBudget() {
	m.estimated_budget = nil
	m.addestimated_budget = nil
	delete(m.clearedFields, idea.FieldEstimatedBudget)
}

// SetIsPublic sets the "is_public" field.
func (m *IdeaMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *IdeaMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *IdeaMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetViewCount sets the "view_count" field.
func (m *IdeaMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *IdeaMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *IdeaMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *IdeaMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *IdeaMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *IdeaMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *IdeaMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *IdeaMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *IdeaMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *IdeaMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IdeaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdeaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdeaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IdeaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IdeaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IdeaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *IdeaMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[idea.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IdeaMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IdeaMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IdeaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the IdeaTranslation entity by ids.
func (m *IdeaMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the IdeaTranslation entity.
func (m *IdeaMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the IdeaTranslation entity was cleared.
func (m *IdeaMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the IdeaTranslation entity by IDs.
func (m *IdeaMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the IdeaTranslation entity.
func (m *IdeaMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *IdeaMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *IdeaMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *IdeaMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *IdeaMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *IdeaMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *IdeaMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *IdeaMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *IdeaMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *IdeaMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// Where appends a list predicates to the IdeaMutation builder.
func (m *IdeaMutation) Where(ps ...predicate.Idea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdeaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdeaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Idea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdeaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdeaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Idea).
func (m *IdeaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdeaMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.user != nil {
		fields = append(fields, idea.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, idea.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, idea.FieldSlug)
	}
	if m.abstract != nil {
		fields = append(fields, idea.FieldAbstract)
	}
	if m.motivation != nil {
		fields = append(fields, idea.FieldMotivation)
	}
	if m.methodology != nil {
		fields = append(fields, idea.FieldMethodology)
	}
	if m.expected_outcome != nil {
		fields = append(fields, idea.FieldExpectedOutcome)
	}
	if m.status != nil {
		fields = append(fields, idea.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, idea.FieldPriority)
	}
	if m.estimated_duration_months != nil {
		fields = append(fields, idea.FieldEstimatedDurationMonths)
	}
	if m.required_resources != nil {
		fields = append(fields, idea.FieldRequiredResources)
	}
	if m.collaboration_needed != nil {
		fields = append(fields, idea.FieldCollaborationNeeded)
	}
	if m.funding_required != nil {
		fields = append(fields, idea.FieldFundingRequired)
	}
	if m.estimated_budget != nil {
		fields = append(fields, idea.FieldEstimatedBudget)
	}
	if m.is_public != nil {
		fields = append(fields, idea.FieldIsPublic)
	}
	if m.view_count != nil {
		fields = append(fields, idea.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, idea.FieldLikeCount)
	}
	if m.created_at != nil {
		fields = append(fields, idea.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, idea.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdeaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case idea.FieldUserID:
		return m.UserID()
	case idea.FieldTitle:
		return m.Title()
	case idea.FieldSlug:
		return m.Slug()
	case idea.FieldAbstract:
		return m.Abstract()
	case idea.FieldMotivation:
		return m.Motivation()
	case idea.FieldMethodology:
		return m.Methodology()
	case idea.FieldExpectedOutcome:
		return m.ExpectedOutcome()
	case idea.FieldStatus:
		return m.Status()
	case idea.FieldPriority:
		return m.Priority()
	case idea.FieldEstimatedDurationMonths:
		return m.EstimatedDurationMonths()
	case idea.FieldRequiredResources:
		return m.RequiredResources()
	case idea.FieldCollaborationNeeded:
		return m.CollaborationNeeded()
	case idea.FieldFundingRequired:
		return m.FundingRequired()
	case idea.FieldEstimatedBudget:
		return m.EstimatedBudget()
	case idea.FieldIsPublic:
		return m.IsPublic()
	case idea.FieldViewCount:
		return m.ViewCount()
	case idea.FieldLikeCount:
		return m.LikeCount()
	case idea.FieldCreatedAt:
		return m.CreatedAt()
	case idea.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdeaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case idea.FieldUserID:
		return m.OldUserID(ctx)
	case idea.FieldTitle:
		return m.OldTitle(ctx)
	case idea.FieldSlug:
		return m.OldSlug(ctx)
	case idea.FieldAbstract:
		return m.OldAbstract(ctx)
	case idea.FieldMotivation:
		return m.OldMotivation(ctx)
	case idea.FieldMethodology:
		return m.OldMethodology(ctx)
	case idea.FieldExpectedOutcome:
		return m.OldExpectedOutcome(ctx)
	case idea.FieldStatus:
		return m.OldStatus(ctx)
	case idea.FieldPriority:
		return m.OldPriority(ctx)
	case idea.FieldEstimatedDurationMonths:
		return m.OldEstimatedDurationMonths(ctx)
	case idea.FieldRequiredResources:
		return m.OldRequiredResources(ctx)
	case idea.FieldCollaborationNeeded:
		return m.OldCollaborationNeeded(ctx)
	case idea.FieldFundingRequired:
		return m.OldFundingRequired(ctx)
	case idea.FieldEstimatedBudget:
		return m.OldEstimatedBudget(ctx)
	case idea.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case idea.FieldViewCount:
		return m.OldViewCount(ctx)
	case idea.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case idea.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case idea.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Idea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case idea.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case idea.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case idea.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case idea.FieldAbstract:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbstract(v)
		return nil
	case idea.FieldMotivation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotivation(v)
		return nil
	case idea.FieldMethodology:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodology(v)
		return nil
	case idea.FieldExpectedOutcome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedOutcome(v)
		return nil
	case idea.FieldStatus:
		v, ok := value.(idea.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case idea.FieldPriority:
		v, ok := value.(idea.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case idea.FieldEstimatedDurationMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedDurationMonths(v)
		return nil
	case idea.FieldRequiredResources:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredResources(v)
		return nil
	case idea.FieldCollaborationNeeded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollaborationNeeded(v)
		return nil
	case idea.FieldFundingRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingRequired(v)
		return nil
	case idea.FieldEstimatedBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedBudget(v)
		return nil
	case idea.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case idea.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case idea.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case idea.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case idea.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Idea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdeaMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_duration_months != nil {
		fields = append(fields, idea.FieldEstimatedDurationMonths)
	}
	if m.addestimated_budget != nil {
		fields = append(fields, idea.FieldEstimatedBudget)
	}
	if m.addview_count != nil {
		fields = append(fields, idea.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, idea.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdeaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case idea.FieldEstimatedDurationMonths:
		return m.AddedEstimatedDurationMonths()
	case idea.FieldEstimatedBudget:
		return m.AddedEstimatedBudget()
	case idea.FieldViewCount:
		return m.AddedViewCount()
	case idea.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case idea.FieldEstimatedDurationMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedDurationMonths(v)
		return nil
	case idea.FieldEstimatedBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedBudget(v)
		return nil
	case idea.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case idea.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Idea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdeaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(idea.FieldAbstract) {
		fields = append(fields, idea.FieldAbstract)
	}
	if m.FieldCleared(idea.FieldMotivation) {
		fields = append(fields, idea.FieldMotivation)
	}
	if m.FieldCleared(idea.FieldMethodology) {
		fields = append(fields, idea.FieldMethodology)
	}
	if m.FieldCleared(idea.FieldExpectedOutcome) {
		fields = append(fields, idea.FieldExpectedOutcome)
	}
	if m.FieldCleared(idea.FieldEstimatedDurationMonths) {
		fields = append(fields, idea.FieldEstimatedDurationMonths)
	}
	if m.FieldCleared(idea.FieldRequiredResources) {
		fields = append(fields, idea.FieldRequiredResources)
	}
	if m.FieldCleared(idea.FieldEstimatedBudget) {
		fields = append(fields, idea.FieldEstimatedBudget)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdeaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdeaMutation) ClearField(name string) error {
	switch name {
	case idea.FieldAbstract:
		m.ClearAbstract()
		return nil
	case idea.FieldMotivation:
		m.ClearMotivation()
		return nil
	case idea.FieldMethodology:
		m.ClearMethodology()
		return nil
	case idea.FieldExpectedOutcome:
		m.ClearExpectedOutcome()
		return nil
	case idea.FieldEstimatedDurationMonths:
		m.ClearEstimatedDurationMonths()
		return nil
	case idea.FieldRequiredResources:
		m.ClearRequiredResources()
		return nil
	case idea.FieldEstimatedBudget:
		m.ClearEstimatedBudget()
		return nil
	}
	return fmt.Errorf("unknown Idea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdeaMutation) ResetField(name string) error {
	switch name {
	case idea.FieldUserID:
		m.ResetUserID()
		return nil
	case idea.FieldTitle:
		m.ResetTitle()
		return nil
	case idea.FieldSlug:
		m.ResetSlug()
		return nil
	case idea.FieldAbstract:
		m.ResetAbstract()
		return nil
	case idea.FieldMotivation:
		m.ResetMotivation()
		return nil
	case idea.FieldMethodology:
		m.ResetMethodology()
		return nil
	case idea.FieldExpectedOutcome:
		m.ResetExpectedOutcome()
		return nil
	case idea.FieldStatus:
		m.ResetStatus()
		return nil
	case idea.FieldPriority:
		m.ResetPriority()
		return nil
	case idea.FieldEstimatedDurationMonths:
		m.ResetEstimatedDurationMonths()
		return nil
	case idea.FieldRequiredResources:
		m.ResetRequiredResources()
		return nil
	case idea.FieldCollaborationNeeded:
		m.ResetCollaborationNeeded()
		return nil
	case idea.FieldFundingRequired:
		m.ResetFundingRequired()
		return nil
	case idea.FieldEstimatedBudget:
		m.ResetEstimatedBudget()
		return nil
	case idea.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case idea.FieldViewCount:
		m.ResetViewCount()
		return nil
	case idea.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case idea.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case idea.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Idea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdeaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, idea.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, idea.EdgeTranslations)
	}
	if m.blog_posts != nil {
		edges = append(edges, idea.EdgeBlogPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdeaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case idea.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case idea.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case idea.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdeaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtranslations != nil {
		edges = append(edges, idea.EdgeTranslations)
	}
	if m.removedblog_posts != nil {
		edges = append(edges, idea.EdgeBlogPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdeaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case idea.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case idea.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdeaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, idea.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, idea.EdgeTranslations)
	}
	if m.clearedblog_posts {
		edges = append(edges, idea.EdgeBlogPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdeaMutation) EdgeCleared(name string) bool {
	switch name {
	case idea.EdgeUser:
		return m.cleareduser
	case idea.EdgeTranslations:
		return m.clearedtranslations
	case idea.EdgeBlogPosts:
		return m.clearedblog_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdeaMutation) ClearEdge(name string) error {
	switch name {
	case idea.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Idea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdeaMutation) ResetEdge(name string) error {
	switch name {
	case idea.EdgeUser:
		m.ResetUser()
		return nil
	case idea.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case idea.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	}
	return fmt.Errorf("unknown Idea edge %s", name)
}

// IdeaTranslationMutation represents an operation that mutates the IdeaTranslation nodes in the graph.
type IdeaTranslationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	title              *string
	abstract           *string
	motivation         *string
	methodology        *string
	expected_outcome   *string
	required_resources *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	idea               *uuid.UUID
	clearedidea        bool
	language           *string
	clearedlanguage    bool
	done               bool
	oldValue           func(context.Context) (*IdeaTranslation, error)
	predicates         []predicate.IdeaTranslation
}

var _ ent.Mutation = (*IdeaTranslationMutation)(nil)

// ideatranslationOption allows management of the mutation configuration using functional options.
type ideatranslationOption func(*IdeaTranslationMutation)

// newIdeaTranslationMutation creates new mutation for the IdeaTranslation entity.
func newIdeaTranslationMutation(c config, op Op, opts ...ideatranslationOption) *IdeaTranslationMutation {
	m := &IdeaTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeIdeaTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdeaTranslationID sets the ID field of the mutation.
func withIdeaTranslationID(id uuid.UUID) ideatranslationOption {
	return func(m *IdeaTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *IdeaTranslation
		)
		m.oldValue = func(ctx context.Context) (*IdeaTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IdeaTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdeaTranslation sets the old IdeaTranslation of the mutation.
func withIdeaTranslation(node *IdeaTranslation) ideatranslationOption {
	return func(m *IdeaTranslationMutation) {
		m.oldValue = func(context.Context) (*IdeaTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdeaTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdeaTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IdeaTranslation entities.
func (m *IdeaTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdeaTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdeaTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IdeaTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIdeaID sets the "idea_id" field.
func (m *IdeaTranslationMutation) SetIdeaID(u uuid.UUID) {
	m.idea = &u
}

// IdeaID returns the value of the "idea_id" field in the mutation.
func (m *IdeaTranslationMutation) IdeaID() (r uuid.UUID, exists bool) {
	v := m.idea
	if v == nil {
		return
	}
	return *v, true
}

// OldIdeaID returns the old "idea_id" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldIdeaID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdeaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdeaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdeaID: %w", err)
	}
	return oldValue.IdeaID, nil
}

// ResetIdeaID resets all changes to the "idea_id" field.
func (m *IdeaTranslationMutation) ResetIdeaID() {
	m.idea = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *IdeaTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *IdeaTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *IdeaTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *IdeaTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IdeaTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IdeaTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetAbstract sets the "abstract" field.
func (m *IdeaTranslationMutation) SetAbstract(s string) {
	m.abstract = &s
}

// Abstract returns the value of the "abstract" field in the mutation.
func (m *IdeaTranslationMutation) Abstract() (r string, exists bool) {
	v := m.abstract
	if v == nil {
		return
	}
	return *v, true
}

// OldAbstract returns the old "abstract" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldAbstract(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbstract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbstract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbstract: %w", err)
	}
	return oldValue.Abstract, nil
}

// ClearAbstract clears the value of the "abstract" field.
func (m *IdeaTranslationMutation) ClearAbstract() {
	m.abstract = nil
	m.clearedFields[ideatranslation.FieldAbstract] = struct{}{}
}

// AbstractCleared returns if the "abstract" field was cleared in this mutation.
func (m *IdeaTranslationMutation) AbstractCleared() bool {
	_, ok := m.clearedFields[ideatranslation.FieldAbstract]
	return ok
}

// ResetAbstract resets all changes to the "abstract" field.
func (m *IdeaTranslationMutation) ResetAbstract() {
	m.abstract = nil
	delete(m.clearedFields, ideatranslation.FieldAbstract)
}

// SetMotivation sets the "motivation" field.
func (m *IdeaTranslationMutation) SetMotivation(s string) {
	m.motivation = &s
}

// Motivation returns the value of the "motivation" field in the mutation.
func (m *IdeaTranslationMutation) Motivation() (r string, exists bool) {
	v := m.motivation
	if v == nil {
		return
	}
	return *v, true
}

// OldMotivation returns the old "motivation" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldMotivation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotivation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotivation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotivation: %w", err)
	}
	return oldValue.Motivation, nil
}

// ClearMotivation clears the value of the "motivation" field.
func (m *IdeaTranslationMutation) ClearMotivation() {
	m.motivation = nil
	m.clearedFields[ideatranslation.FieldMotivation] = struct{}{}
}

// MotivationCleared returns if the "motivation" field was cleared in this mutation.
func (m *IdeaTranslationMutation) MotivationCleared() bool {
	_, ok := m.clearedFields[ideatranslation.FieldMotivation]
	return ok
}

// ResetMotivation resets all changes to the "motivation" field.
func (m *IdeaTranslationMutation) ResetMotivation() {
	m.motivation = nil
	delete(m.clearedFields, ideatranslation.FieldMotivation)
}

// SetMethodology sets the "methodology" field.
func (m *IdeaTranslationMutation) SetMethodology(s string) {
	m.methodology = &s
}

// Methodology returns the value of the "methodology" field in the mutation.
func (m *IdeaTranslationMutation) Methodology() (r string, exists bool) {
	v := m.methodology
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodology returns the old "methodology" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldMethodology(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethodology is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethodology requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodology: %w", err)
	}
	return oldValue.Methodology, nil
}

// ClearMethodology clears the value of the "methodology" field.
func (m *IdeaTranslationMutation) ClearMethodology() {
	m.methodology = nil
	m.clearedFields[ideatranslation.FieldMethodology] = struct{}{}
}

// MethodologyCleared returns if the "methodology" field was cleared in this mutation.
func (m *IdeaTranslationMutation) MethodologyCleared() bool {
	_, ok := m.clearedFields[ideatranslation.FieldMethodology]
	return ok
}

// ResetMethodology resets all changes to the "methodology" field.
func (m *IdeaTranslationMutation) ResetMethodology() {
	m.methodology = nil
	delete(m.clearedFields, ideatranslation.FieldMethodology)
}

// SetExpectedOutcome sets the "expected_outcome" field.
func (m *IdeaTranslationMutation) SetExpectedOutcome(s string) {
	m.expected_outcome = &s
}

// ExpectedOutcome returns the value of the "expected_outcome" field in the mutation.
func (m *IdeaTranslationMutation) ExpectedOutcome() (r string, exists bool) {
	v := m.expected_outcome
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedOutcome returns the old "expected_outcome" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldExpectedOutcome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedOutcome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedOutcome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedOutcome: %w", err)
	}
	return oldValue.ExpectedOutcome, nil
}

// ClearExpectedOutcome clears the value of the "expected_outcome" field.
func (m *IdeaTranslationMutation) ClearExpectedOutcome() {
	m.expected_outcome = nil
	m.clearedFields[ideatranslation.FieldExpectedOutcome] = struct{}{}
}

// ExpectedOutcomeCleared returns if the "expected_outcome" field was cleared in this mutation.
func (m *IdeaTranslationMutation) ExpectedOutcomeCleared() bool {
	_, ok := m.clearedFields[ideatranslation.FieldExpectedOutcome]
	return ok
}

// ResetExpectedOutcome resets all changes to the "expected_outcome" field.
func (m *IdeaTranslationMutation) ResetExpectedOutcome() {
	m.expected_outcome = nil
	delete(m.clearedFields, ideatranslation.FieldExpectedOutcome)
}

// SetRequiredResources sets the "required_resources" field.
func (m *IdeaTranslationMutation) SetRequiredResources(s string) {
	m.required_resources = &s
}

// RequiredResources returns the value of the "required_resources" field in the mutation.
func (m *IdeaTranslationMutation) RequiredResources() (r string, exists bool) {
	v := m.required_resources
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredResources returns the old "required_resources" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldRequiredResources(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredResources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredResources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredResources: %w", err)
	}
	return oldValue.RequiredResources, nil
}

// ClearRequiredResources clears the value of the "required_resources" field.
func (m *IdeaTranslationMutation) ClearRequiredResources() {
	m.required_resources = nil
	m.clearedFields[ideatranslation.FieldRequiredResources] = struct{}{}
}

// RequiredResourcesCleared returns if the "required_resources" field was cleared in this mutation.
func (m *IdeaTranslationMutation) RequiredResourcesCleared() bool {
	_, ok := m.clearedFields[ideatranslation.FieldRequiredResources]
	return ok
}

// ResetRequiredResources resets all changes to the "required_resources" field.
func (m *IdeaTranslationMutation) ResetRequiredResources() {
	m.required_resources = nil
	delete(m.clearedFields, ideatranslation.FieldRequiredResources)
}

// SetCreatedAt sets the "created_at" field.
func (m *IdeaTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdeaTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IdeaTranslation entity.
// If the IdeaTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdeaTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearIdea clears the "idea" edge to the Idea entity.
func (m *IdeaTranslationMutation) ClearIdea() {
	m.clearedidea = true
	m.clearedFields[ideatranslation.FieldIdeaID] = struct{}{}
}

// IdeaCleared reports if the "idea" edge to the Idea entity was cleared.
func (m *IdeaTranslationMutation) IdeaCleared() bool {
	return m.clearedidea
}

// IdeaIDs returns the "idea" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IdeaID instead. It exists only for internal usage by the builders.
func (m *IdeaTranslationMutation) IdeaIDs() (ids []uuid.UUID) {
	if id := m.idea; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIdea resets all changes to the "idea" edge.
func (m *IdeaTranslationMutation) ResetIdea() {
	m.idea = nil
	m.clearedidea = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *IdeaTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *IdeaTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[ideatranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *IdeaTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *IdeaTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *IdeaTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *IdeaTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the IdeaTranslationMutation builder.
func (m *IdeaTranslationMutation) Where(ps ...predicate.IdeaTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdeaTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdeaTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IdeaTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdeaTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdeaTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IdeaTranslation).
func (m *IdeaTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdeaTranslationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.idea != nil {
		fields = append(fields, ideatranslation.FieldIdeaID)
	}
	if m.language != nil {
		fields = append(fields, ideatranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, ideatranslation.FieldTitle)
	}
	if m.abstract != nil {
		fields = append(fields, ideatranslation.FieldAbstract)
	}
	if m.motivation != nil {
		fields = append(fields, ideatranslation.FieldMotivation)
	}
	if m.methodology != nil {
		fields = append(fields, ideatranslation.FieldMethodology)
	}
	if m.expected_outcome != nil {
		fields = append(fields, ideatranslation.FieldExpectedOutcome)
	}
	if m.required_resources != nil {
		fields = append(fields, ideatranslation.FieldRequiredResources)
	}
	if m.created_at != nil {
		fields = append(fields, ideatranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdeaTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ideatranslation.FieldIdeaID:
		return m.IdeaID()
	case ideatranslation.FieldLanguageCode:
		return m.LanguageCode()
	case ideatranslation.FieldTitle:
		return m.Title()
	case ideatranslation.FieldAbstract:
		return m.Abstract()
	case ideatranslation.FieldMotivation:
		return m.Motivation()
	case ideatranslation.FieldMethodology:
		return m.Methodology()
	case ideatranslation.FieldExpectedOutcome:
		return m.ExpectedOutcome()
	case ideatranslation.FieldRequiredResources:
		return m.RequiredResources()
	case ideatranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdeaTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ideatranslation.FieldIdeaID:
		return m.OldIdeaID(ctx)
	case ideatranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case ideatranslation.FieldTitle:
		return m.OldTitle(ctx)
	case ideatranslation.FieldAbstract:
		return m.OldAbstract(ctx)
	case ideatranslation.FieldMotivation:
		return m.OldMotivation(ctx)
	case ideatranslation.FieldMethodology:
		return m.OldMethodology(ctx)
	case ideatranslation.FieldExpectedOutcome:
		return m.OldExpectedOutcome(ctx)
	case ideatranslation.FieldRequiredResources:
		return m.OldRequiredResources(ctx)
	case ideatranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown IdeaTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ideatranslation.FieldIdeaID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdeaID(v)
		return nil
	case ideatranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case ideatranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case ideatranslation.FieldAbstract:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbstract(v)
		return nil
	case ideatranslation.FieldMotivation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotivation(v)
		return nil
	case ideatranslation.FieldMethodology:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodology(v)
		return nil
	case ideatranslation.FieldExpectedOutcome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedOutcome(v)
		return nil
	case ideatranslation.FieldRequiredResources:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredResources(v)
		return nil
	case ideatranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown IdeaTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdeaTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdeaTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IdeaTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdeaTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ideatranslation.FieldAbstract) {
		fields = append(fields, ideatranslation.FieldAbstract)
	}
	if m.FieldCleared(ideatranslation.FieldMotivation) {
		fields = append(fields, ideatranslation.FieldMotivation)
	}
	if m.FieldCleared(ideatranslation.FieldMethodology) {
		fields = append(fields, ideatranslation.FieldMethodology)
	}
	if m.FieldCleared(ideatranslation.FieldExpectedOutcome) {
		fields = append(fields, ideatranslation.FieldExpectedOutcome)
	}
	if m.FieldCleared(ideatranslation.FieldRequiredResources) {
		fields = append(fields, ideatranslation.FieldRequiredResources)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdeaTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdeaTranslationMutation) ClearField(name string) error {
	switch name {
	case ideatranslation.FieldAbstract:
		m.ClearAbstract()
		return nil
	case ideatranslation.FieldMotivation:
		m.ClearMotivation()
		return nil
	case ideatranslation.FieldMethodology:
		m.ClearMethodology()
		return nil
	case ideatranslation.FieldExpectedOutcome:
		m.ClearExpectedOutcome()
		return nil
	case ideatranslation.FieldRequiredResources:
		m.ClearRequiredResources()
		return nil
	}
	return fmt.Errorf("unknown IdeaTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdeaTranslationMutation) ResetField(name string) error {
	switch name {
	case ideatranslation.FieldIdeaID:
		m.ResetIdeaID()
		return nil
	case ideatranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case ideatranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case ideatranslation.FieldAbstract:
		m.ResetAbstract()
		return nil
	case ideatranslation.FieldMotivation:
		m.ResetMotivation()
		return nil
	case ideatranslation.FieldMethodology:
		m.ResetMethodology()
		return nil
	case ideatranslation.FieldExpectedOutcome:
		m.ResetExpectedOutcome()
		return nil
	case ideatranslation.FieldRequiredResources:
		m.ResetRequiredResources()
		return nil
	case ideatranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown IdeaTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdeaTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.idea != nil {
		edges = append(edges, ideatranslation.EdgeIdea)
	}
	if m.language != nil {
		edges = append(edges, ideatranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdeaTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ideatranslation.EdgeIdea:
		if id := m.idea; id != nil {
			return []ent.Value{*id}
		}
	case ideatranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdeaTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdeaTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdeaTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedidea {
		edges = append(edges, ideatranslation.EdgeIdea)
	}
	if m.clearedlanguage {
		edges = append(edges, ideatranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdeaTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case ideatranslation.EdgeIdea:
		return m.clearedidea
	case ideatranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdeaTranslationMutation) ClearEdge(name string) error {
	switch name {
	case ideatranslation.EdgeIdea:
		m.ClearIdea()
		return nil
	case ideatranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown IdeaTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdeaTranslationMutation) ResetEdge(name string) error {
	switch name {
	case ideatranslation.EdgeIdea:
		m.ResetIdea()
		return nil
	case ideatranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown IdeaTranslation edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *string
	name                                        *string
	native_name                                 *string
	is_active                                   *bool
	created_at                                  *time.Time
	clearedFields                               map[string]struct{}
	personal_info_translations                  map[uuid.UUID]struct{}
	removedpersonal_info_translations           map[uuid.UUID]struct{}
	clearedpersonal_info_translations           bool
	education_translations                      map[uuid.UUID]struct{}
	removededucation_translations               map[uuid.UUID]struct{}
	clearededucation_translations               bool
	education_detail_translations               map[uuid.UUID]struct{}
	removededucation_detail_translations        map[uuid.UUID]struct{}
	clearededucation_detail_translations        bool
	work_experience_translations                map[uuid.UUID]struct{}
	removedwork_experience_translations         map[uuid.UUID]struct{}
	clearedwork_experience_translations         bool
	work_experience_detail_translations         map[uuid.UUID]struct{}
	removedwork_experience_detail_translations  map[uuid.UUID]struct{}
	clearedwork_experience_detail_translations  bool
	project_translations                        map[uuid.UUID]struct{}
	removedproject_translations                 map[uuid.UUID]struct{}
	clearedproject_translations                 bool
	project_detail_translations                 map[uuid.UUID]struct{}
	removedproject_detail_translations          map[uuid.UUID]struct{}
	clearedproject_detail_translations          bool
	project_image_translations                  map[uuid.UUID]struct{}
	removedproject_image_translations           map[uuid.UUID]struct{}
	clearedproject_image_translations           bool
	blog_category_translations                  map[uuid.UUID]struct{}
	removedblog_category_translations           map[uuid.UUID]struct{}
	clearedblog_category_translations           bool
	blog_post_translations                      map[uuid.UUID]struct{}
	removedblog_post_translations               map[uuid.UUID]struct{}
	clearedblog_post_translations               bool
	blog_series_translations                    map[uuid.UUID]struct{}
	removedblog_series_translations             map[uuid.UUID]struct{}
	clearedblog_series_translations             bool
	idea_translations                           map[uuid.UUID]struct{}
	removedidea_translations                    map[uuid.UUID]struct{}
	clearedidea_translations                    bool
	research_project_translations               map[uuid.UUID]struct{}
	removedresearch_project_translations        map[uuid.UUID]struct{}
	clearedresearch_project_translations        bool
	research_project_detail_translations        map[uuid.UUID]struct{}
	removedresearch_project_detail_translations map[uuid.UUID]struct{}
	clearedresearch_project_detail_translations bool
	publication_translations                    map[uuid.UUID]struct{}
	removedpublication_translations             map[uuid.UUID]struct{}
	clearedpublication_translations             bool
	award_translations                          map[uuid.UUID]struct{}
	removedaward_translations                   map[uuid.UUID]struct{}
	clearedaward_translations                   bool
	recent_update_translations                  map[uuid.UUID]struct{}
	removedrecent_update_translations           map[uuid.UUID]struct{}
	clearedrecent_update_translations           bool
	done                                        bool
	oldValue                                    func(context.Context) (*Language, error)
	predicates                                  []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id string) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LanguageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LanguageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LanguageMutation) ResetName() {
	m.name = nil
}

// SetNativeName sets the "native_name" field.
func (m *LanguageMutation) SetNativeName(s string) {
	m.native_name = &s
}

// NativeName returns the value of the "native_name" field in the mutation.
func (m *LanguageMutation) NativeName() (r string, exists bool) {
	v := m.native_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNativeName returns the old "native_name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldNativeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNativeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNativeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNativeName: %w", err)
	}
	return oldValue.NativeName, nil
}

// ResetNativeName resets all changes to the "native_name" field.
func (m *LanguageMutation) ResetNativeName() {
	m.native_name = nil
}

// SetIsActive sets the "is_active" field.
func (m *LanguageMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *LanguageMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *LanguageMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LanguageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LanguageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LanguageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPersonalInfoTranslationIDs adds the "personal_info_translations" edge to the PersonalInfoTranslation entity by ids.
func (m *LanguageMutation) AddPersonalInfoTranslationIDs(ids ...uuid.UUID) {
	if m.personal_info_translations == nil {
		m.personal_info_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.personal_info_translations[ids[i]] = struct{}{}
	}
}

// ClearPersonalInfoTranslations clears the "personal_info_translations" edge to the PersonalInfoTranslation entity.
func (m *LanguageMutation) ClearPersonalInfoTranslations() {
	m.clearedpersonal_info_translations = true
}

// PersonalInfoTranslationsCleared reports if the "personal_info_translations" edge to the PersonalInfoTranslation entity was cleared.
func (m *LanguageMutation) PersonalInfoTranslationsCleared() bool {
	return m.clearedpersonal_info_translations
}

// RemovePersonalInfoTranslationIDs removes the "personal_info_translations" edge to the PersonalInfoTranslation entity by IDs.
func (m *LanguageMutation) RemovePersonalInfoTranslationIDs(ids ...uuid.UUID) {
	if m.removedpersonal_info_translations == nil {
		m.removedpersonal_info_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.personal_info_translations, ids[i])
		m.removedpersonal_info_translations[ids[i]] = struct{}{}
	}
}

// RemovedPersonalInfoTranslations returns the removed IDs of the "personal_info_translations" edge to the PersonalInfoTranslation entity.
func (m *LanguageMutation) RemovedPersonalInfoTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedpersonal_info_translations {
		ids = append(ids, id)
	}
	return
}

// PersonalInfoTranslationsIDs returns the "personal_info_translations" edge IDs in the mutation.
func (m *LanguageMutation) PersonalInfoTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.personal_info_translations {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalInfoTranslations resets all changes to the "personal_info_translations" edge.
func (m *LanguageMutation) ResetPersonalInfoTranslations() {
	m.personal_info_translations = nil
	m.clearedpersonal_info_translations = false
	m.removedpersonal_info_translations = nil
}

// AddEducationTranslationIDs adds the "education_translations" edge to the EducationTranslation entity by ids.
func (m *LanguageMutation) AddEducationTranslationIDs(ids ...uuid.UUID) {
	if m.education_translations == nil {
		m.education_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.education_translations[ids[i]] = struct{}{}
	}
}

// ClearEducationTranslations clears the "education_translations" edge to the EducationTranslation entity.
func (m *LanguageMutation) ClearEducationTranslations() {
	m.clearededucation_translations = true
}

// EducationTranslationsCleared reports if the "education_translations" edge to the EducationTranslation entity was cleared.
func (m *LanguageMutation) EducationTranslationsCleared() bool {
	return m.clearededucation_translations
}

// RemoveEducationTranslationIDs removes the "education_translations" edge to the EducationTranslation entity by IDs.
func (m *LanguageMutation) RemoveEducationTranslationIDs(ids ...uuid.UUID) {
	if m.removededucation_translations == nil {
		m.removededucation_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.education_translations, ids[i])
		m.removededucation_translations[ids[i]] = struct{}{}
	}
}

// RemovedEducationTranslations returns the removed IDs of the "education_translations" edge to the EducationTranslation entity.
func (m *LanguageMutation) RemovedEducationTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucation_translations {
		ids = append(ids, id)
	}
	return
}

// EducationTranslationsIDs returns the "education_translations" edge IDs in the mutation.
func (m *LanguageMutation) EducationTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.education_translations {
		ids = append(ids, id)
	}
	return
}

// ResetEducationTranslations resets all changes to the "education_translations" edge.
func (m *LanguageMutation) ResetEducationTranslations() {
	m.education_translations = nil
	m.clearededucation_translations = false
	m.removededucation_translations = nil
}

// AddEducationDetailTranslationIDs adds the "education_detail_translations" edge to the EducationDetailTranslation entity by ids.
func (m *LanguageMutation) AddEducationDetailTranslationIDs(ids ...uuid.UUID) {
	if m.education_detail_translations == nil {
		m.education_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.education_detail_translations[ids[i]] = struct{}{}
	}
}

// ClearEducationDetailTranslations clears the "education_detail_translations" edge to the EducationDetailTranslation entity.
func (m *LanguageMutation) ClearEducationDetailTranslations() {
	m.clearededucation_detail_translations = true
}

// EducationDetailTranslationsCleared reports if the "education_detail_translations" edge to the EducationDetailTranslation entity was cleared.
func (m *LanguageMutation) EducationDetailTranslationsCleared() bool {
	return m.clearededucation_detail_translations
}

// RemoveEducationDetailTranslationIDs removes the "education_detail_translations" edge to the EducationDetailTranslation entity by IDs.
func (m *LanguageMutation) RemoveEducationDetailTranslationIDs(ids ...uuid.UUID) {
	if m.removededucation_detail_translations == nil {
		m.removededucation_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.education_detail_translations, ids[i])
		m.removededucation_detail_translations[ids[i]] = struct{}{}
	}
}

// RemovedEducationDetailTranslations returns the removed IDs of the "education_detail_translations" edge to the EducationDetailTranslation entity.
func (m *LanguageMutation) RemovedEducationDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucation_detail_translations {
		ids = append(ids, id)
	}
	return
}

// EducationDetailTranslationsIDs returns the "education_detail_translations" edge IDs in the mutation.
func (m *LanguageMutation) EducationDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.education_detail_translations {
		ids = append(ids, id)
	}
	return
}

// ResetEducationDetailTranslations resets all changes to the "education_detail_translations" edge.
func (m *LanguageMutation) ResetEducationDetailTranslations() {
	m.education_detail_translations = nil
	m.clearededucation_detail_translations = false
	m.removededucation_detail_translations = nil
}

// AddWorkExperienceTranslationIDs adds the "work_experience_translations" edge to the WorkExperienceTranslation entity by ids.
func (m *LanguageMutation) AddWorkExperienceTranslationIDs(ids ...uuid.UUID) {
	if m.work_experience_translations == nil {
		m.work_experience_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.work_experience_translations[ids[i]] = struct{}{}
	}
}

// ClearWorkExperienceTranslations clears the "work_experience_translations" edge to the WorkExperienceTranslation entity.
func (m *LanguageMutation) ClearWorkExperienceTranslations() {
	m.clearedwork_experience_translations = true
}

// WorkExperienceTranslationsCleared reports if the "work_experience_translations" edge to the WorkExperienceTranslation entity was cleared.
func (m *LanguageMutation) WorkExperienceTranslationsCleared() bool {
	return m.clearedwork_experience_translations
}

// RemoveWorkExperienceTranslationIDs removes the "work_experience_translations" edge to the WorkExperienceTranslation entity by IDs.
func (m *LanguageMutation) RemoveWorkExperienceTranslationIDs(ids ...uuid.UUID) {
	if m.removedwork_experience_translations == nil {
		m.removedwork_experience_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.work_experience_translations, ids[i])
		m.removedwork_experience_translations[ids[i]] = struct{}{}
	}
}

// RemovedWorkExperienceTranslations returns the removed IDs of the "work_experience_translations" edge to the WorkExperienceTranslation entity.
func (m *LanguageMutation) RemovedWorkExperienceTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedwork_experience_translations {
		ids = append(ids, id)
	}
	return
}

// WorkExperienceTranslationsIDs returns the "work_experience_translations" edge IDs in the mutation.
func (m *LanguageMutation) WorkExperienceTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.work_experience_translations {
		ids = append(ids, id)
	}
	return
}

// ResetWorkExperienceTranslations resets all changes to the "work_experience_translations" edge.
func (m *LanguageMutation) ResetWorkExperienceTranslations() {
	m.work_experience_translations = nil
	m.clearedwork_experience_translations = false
	m.removedwork_experience_translations = nil
}

// AddWorkExperienceDetailTranslationIDs adds the "work_experience_detail_translations" edge to the WorkExperienceDetailTranslation entity by ids.
func (m *LanguageMutation) AddWorkExperienceDetailTranslationIDs(ids ...uuid.UUID) {
	if m.work_experience_detail_translations == nil {
		m.work_experience_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.work_experience_detail_translations[ids[i]] = struct{}{}
	}
}

// ClearWorkExperienceDetailTranslations clears the "work_experience_detail_translations" edge to the WorkExperienceDetailTranslation entity.
func (m *LanguageMutation) ClearWorkExperienceDetailTranslations() {
	m.clearedwork_experience_detail_translations = true
}

// WorkExperienceDetailTranslationsCleared reports if the "work_experience_detail_translations" edge to the WorkExperienceDetailTranslation entity was cleared.
func (m *LanguageMutation) WorkExperienceDetailTranslationsCleared() bool {
	return m.clearedwork_experience_detail_translations
}

// RemoveWorkExperienceDetailTranslationIDs removes the "work_experience_detail_translations" edge to the WorkExperienceDetailTranslation entity by IDs.
func (m *LanguageMutation) RemoveWorkExperienceDetailTranslationIDs(ids ...uuid.UUID) {
	if m.removedwork_experience_detail_translations == nil {
		m.removedwork_experience_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.work_experience_detail_translations, ids[i])
		m.removedwork_experience_detail_translations[ids[i]] = struct{}{}
	}
}

// RemovedWorkExperienceDetailTranslations returns the removed IDs of the "work_experience_detail_translations" edge to the WorkExperienceDetailTranslation entity.
func (m *LanguageMutation) RemovedWorkExperienceDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedwork_experience_detail_translations {
		ids = append(ids, id)
	}
	return
}

// WorkExperienceDetailTranslationsIDs returns the "work_experience_detail_translations" edge IDs in the mutation.
func (m *LanguageMutation) WorkExperienceDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.work_experience_detail_translations {
		ids = append(ids, id)
	}
	return
}

// ResetWorkExperienceDetailTranslations resets all changes to the "work_experience_detail_translations" edge.
func (m *LanguageMutation) ResetWorkExperienceDetailTranslations() {
	m.work_experience_detail_translations = nil
	m.clearedwork_experience_detail_translations = false
	m.removedwork_experience_detail_translations = nil
}

// AddProjectTranslationIDs adds the "project_translations" edge to the ProjectTranslation entity by ids.
func (m *LanguageMutation) AddProjectTranslationIDs(ids ...uuid.UUID) {
	if m.project_translations == nil {
		m.project_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.project_translations[ids[i]] = struct{}{}
	}
}

// ClearProjectTranslations clears the "project_translations" edge to the ProjectTranslation entity.
func (m *LanguageMutation) ClearProjectTranslations() {
	m.clearedproject_translations = true
}

// ProjectTranslationsCleared reports if the "project_translations" edge to the ProjectTranslation entity was cleared.
func (m *LanguageMutation) ProjectTranslationsCleared() bool {
	return m.clearedproject_translations
}

// RemoveProjectTranslationIDs removes the "project_translations" edge to the ProjectTranslation entity by IDs.
func (m *LanguageMutation) RemoveProjectTranslationIDs(ids ...uuid.UUID) {
	if m.removedproject_translations == nil {
		m.removedproject_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.project_translations, ids[i])
		m.removedproject_translations[ids[i]] = struct{}{}
	}
}

// RemovedProjectTranslations returns the removed IDs of the "project_translations" edge to the ProjectTranslation entity.
func (m *LanguageMutation) RemovedProjectTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedproject_translations {
		ids = append(ids, id)
	}
	return
}

// ProjectTranslationsIDs returns the "project_translations" edge IDs in the mutation.
func (m *LanguageMutation) ProjectTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.project_translations {
		ids = append(ids, id)
	}
	return
}

// ResetProjectTranslations resets all changes to the "project_translations" edge.
func (m *LanguageMutation) ResetProjectTranslations() {
	m.project_translations = nil
	m.clearedproject_translations = false
	m.removedproject_translations = nil
}

// AddProjectDetailTranslationIDs adds the "project_detail_translations" edge to the ProjectDetailTranslation entity by ids.
func (m *LanguageMutation) AddProjectDetailTranslationIDs(ids ...uuid.UUID) {
	if m.project_detail_translations == nil {
		m.project_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.project_detail_translations[ids[i]] = struct{}{}
	}
}

// ClearProjectDetailTranslations clears the "project_detail_translations" edge to the ProjectDetailTranslation entity.
func (m *LanguageMutation) ClearProjectDetailTranslations() {
	m.clearedproject_detail_translations = true
}

// ProjectDetailTranslationsCleared reports if the "project_detail_translations" edge to the ProjectDetailTranslation entity was cleared.
func (m *LanguageMutation) ProjectDetailTranslationsCleared() bool {
	return m.clearedproject_detail_translations
}

// RemoveProjectDetailTranslationIDs removes the "project_detail_translations" edge to the ProjectDetailTranslation entity by IDs.
func (m *LanguageMutation) RemoveProjectDetailTranslationIDs(ids ...uuid.UUID) {
	if m.removedproject_detail_translations == nil {
		m.removedproject_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.project_detail_translations, ids[i])
		m.removedproject_detail_translations[ids[i]] = struct{}{}
	}
}

// RemovedProjectDetailTranslations returns the removed IDs of the "project_detail_translations" edge to the ProjectDetailTranslation entity.
func (m *LanguageMutation) RemovedProjectDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedproject_detail_translations {
		ids = append(ids, id)
	}
	return
}

// ProjectDetailTranslationsIDs returns the "project_detail_translations" edge IDs in the mutation.
func (m *LanguageMutation) ProjectDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.project_detail_translations {
		ids = append(ids, id)
	}
	return
}

// ResetProjectDetailTranslations resets all changes to the "project_detail_translations" edge.
func (m *LanguageMutation) ResetProjectDetailTranslations() {
	m.project_detail_translations = nil
	m.clearedproject_detail_translations = false
	m.removedproject_detail_translations = nil
}

// AddProjectImageTranslationIDs adds the "project_image_translations" edge to the ProjectImageTranslation entity by ids.
func (m *LanguageMutation) AddProjectImageTranslationIDs(ids ...uuid.UUID) {
	if m.project_image_translations == nil {
		m.project_image_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.project_image_translations[ids[i]] = struct{}{}
	}
}

// ClearProjectImageTranslations clears the "project_image_translations" edge to the ProjectImageTranslation entity.
func (m *LanguageMutation) ClearProjectImageTranslations() {
	m.clearedproject_image_translations = true
}

// ProjectImageTranslationsCleared reports if the "project_image_translations" edge to the ProjectImageTranslation entity was cleared.
func (m *LanguageMutation) ProjectImageTranslationsCleared() bool {
	return m.clearedproject_image_translations
}

// RemoveProjectImageTranslationIDs removes the "project_image_translations" edge to the ProjectImageTranslation entity by IDs.
func (m *LanguageMutation) RemoveProjectImageTranslationIDs(ids ...uuid.UUID) {
	if m.removedproject_image_translations == nil {
		m.removedproject_image_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.project_image_translations, ids[i])
		m.removedproject_image_translations[ids[i]] = struct{}{}
	}
}

// RemovedProjectImageTranslations returns the removed IDs of the "project_image_translations" edge to the ProjectImageTranslation entity.
func (m *LanguageMutation) RemovedProjectImageTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedproject_image_translations {
		ids = append(ids, id)
	}
	return
}

// ProjectImageTranslationsIDs returns the "project_image_translations" edge IDs in the mutation.
func (m *LanguageMutation) ProjectImageTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.project_image_translations {
		ids = append(ids, id)
	}
	return
}

// ResetProjectImageTranslations resets all changes to the "project_image_translations" edge.
func (m *LanguageMutation) ResetProjectImageTranslations() {
	m.project_image_translations = nil
	m.clearedproject_image_translations = false
	m.removedproject_image_translations = nil
}

// AddBlogCategoryTranslationIDs adds the "blog_category_translations" edge to the BlogCategoryTranslation entity by ids.
func (m *LanguageMutation) AddBlogCategoryTranslationIDs(ids ...uuid.UUID) {
	if m.blog_category_translations == nil {
		m.blog_category_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_category_translations[ids[i]] = struct{}{}
	}
}

// ClearBlogCategoryTranslations clears the "blog_category_translations" edge to the BlogCategoryTranslation entity.
func (m *LanguageMutation) ClearBlogCategoryTranslations() {
	m.clearedblog_category_translations = true
}

// BlogCategoryTranslationsCleared reports if the "blog_category_translations" edge to the BlogCategoryTranslation entity was cleared.
func (m *LanguageMutation) BlogCategoryTranslationsCleared() bool {
	return m.clearedblog_category_translations
}

// RemoveBlogCategoryTranslationIDs removes the "blog_category_translations" edge to the BlogCategoryTranslation entity by IDs.
func (m *LanguageMutation) RemoveBlogCategoryTranslationIDs(ids ...uuid.UUID) {
	if m.removedblog_category_translations == nil {
		m.removedblog_category_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_category_translations, ids[i])
		m.removedblog_category_translations[ids[i]] = struct{}{}
	}
}

// RemovedBlogCategoryTranslations returns the removed IDs of the "blog_category_translations" edge to the BlogCategoryTranslation entity.
func (m *LanguageMutation) RemovedBlogCategoryTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_category_translations {
		ids = append(ids, id)
	}
	return
}

// BlogCategoryTranslationsIDs returns the "blog_category_translations" edge IDs in the mutation.
func (m *LanguageMutation) BlogCategoryTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.blog_category_translations {
		ids = append(ids, id)
	}
	return
}

// ResetBlogCategoryTranslations resets all changes to the "blog_category_translations" edge.
func (m *LanguageMutation) ResetBlogCategoryTranslations() {
	m.blog_category_translations = nil
	m.clearedblog_category_translations = false
	m.removedblog_category_translations = nil
}

// AddBlogPostTranslationIDs adds the "blog_post_translations" edge to the BlogPostTranslation entity by ids.
func (m *LanguageMutation) AddBlogPostTranslationIDs(ids ...uuid.UUID) {
	if m.blog_post_translations == nil {
		m.blog_post_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_post_translations[ids[i]] = struct{}{}
	}
}

// ClearBlogPostTranslations clears the "blog_post_translations" edge to the BlogPostTranslation entity.
func (m *LanguageMutation) ClearBlogPostTranslations() {
	m.clearedblog_post_translations = true
}

// BlogPostTranslationsCleared reports if the "blog_post_translations" edge to the BlogPostTranslation entity was cleared.
func (m *LanguageMutation) BlogPostTranslationsCleared() bool {
	return m.clearedblog_post_translations
}

// RemoveBlogPostTranslationIDs removes the "blog_post_translations" edge to the BlogPostTranslation entity by IDs.
func (m *LanguageMutation) RemoveBlogPostTranslationIDs(ids ...uuid.UUID) {
	if m.removedblog_post_translations == nil {
		m.removedblog_post_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_post_translations, ids[i])
		m.removedblog_post_translations[ids[i]] = struct{}{}
	}
}

// RemovedBlogPostTranslations returns the removed IDs of the "blog_post_translations" edge to the BlogPostTranslation entity.
func (m *LanguageMutation) RemovedBlogPostTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_post_translations {
		ids = append(ids, id)
	}
	return
}

// BlogPostTranslationsIDs returns the "blog_post_translations" edge IDs in the mutation.
func (m *LanguageMutation) BlogPostTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.blog_post_translations {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPostTranslations resets all changes to the "blog_post_translations" edge.
func (m *LanguageMutation) ResetBlogPostTranslations() {
	m.blog_post_translations = nil
	m.clearedblog_post_translations = false
	m.removedblog_post_translations = nil
}

// AddBlogSeriesTranslationIDs adds the "blog_series_translations" edge to the BlogSeriesTranslation entity by ids.
func (m *LanguageMutation) AddBlogSeriesTranslationIDs(ids ...uuid.UUID) {
	if m.blog_series_translations == nil {
		m.blog_series_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_series_translations[ids[i]] = struct{}{}
	}
}

// ClearBlogSeriesTranslations clears the "blog_series_translations" edge to the BlogSeriesTranslation entity.
func (m *LanguageMutation) ClearBlogSeriesTranslations() {
	m.clearedblog_series_translations = true
}

// BlogSeriesTranslationsCleared reports if the "blog_series_translations" edge to the BlogSeriesTranslation entity was cleared.
func (m *LanguageMutation) BlogSeriesTranslationsCleared() bool {
	return m.clearedblog_series_translations
}

// RemoveBlogSeriesTranslationIDs removes the "blog_series_translations" edge to the BlogSeriesTranslation entity by IDs.
func (m *LanguageMutation) RemoveBlogSeriesTranslationIDs(ids ...uuid.UUID) {
	if m.removedblog_series_translations == nil {
		m.removedblog_series_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_series_translations, ids[i])
		m.removedblog_series_translations[ids[i]] = struct{}{}
	}
}

// RemovedBlogSeriesTranslations returns the removed IDs of the "blog_series_translations" edge to the BlogSeriesTranslation entity.
func (m *LanguageMutation) RemovedBlogSeriesTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_series_translations {
		ids = append(ids, id)
	}
	return
}

// BlogSeriesTranslationsIDs returns the "blog_series_translations" edge IDs in the mutation.
func (m *LanguageMutation) BlogSeriesTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.blog_series_translations {
		ids = append(ids, id)
	}
	return
}

// ResetBlogSeriesTranslations resets all changes to the "blog_series_translations" edge.
func (m *LanguageMutation) ResetBlogSeriesTranslations() {
	m.blog_series_translations = nil
	m.clearedblog_series_translations = false
	m.removedblog_series_translations = nil
}

// AddIdeaTranslationIDs adds the "idea_translations" edge to the IdeaTranslation entity by ids.
func (m *LanguageMutation) AddIdeaTranslationIDs(ids ...uuid.UUID) {
	if m.idea_translations == nil {
		m.idea_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.idea_translations[ids[i]] = struct{}{}
	}
}

// ClearIdeaTranslations clears the "idea_translations" edge to the IdeaTranslation entity.
func (m *LanguageMutation) ClearIdeaTranslations() {
	m.clearedidea_translations = true
}

// IdeaTranslationsCleared reports if the "idea_translations" edge to the IdeaTranslation entity was cleared.
func (m *LanguageMutation) IdeaTranslationsCleared() bool {
	return m.clearedidea_translations
}

// RemoveIdeaTranslationIDs removes the "idea_translations" edge to the IdeaTranslation entity by IDs.
func (m *LanguageMutation) RemoveIdeaTranslationIDs(ids ...uuid.UUID) {
	if m.removedidea_translations == nil {
		m.removedidea_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.idea_translations, ids[i])
		m.removedidea_translations[ids[i]] = struct{}{}
	}
}

// RemovedIdeaTranslations returns the removed IDs of the "idea_translations" edge to the IdeaTranslation entity.
func (m *LanguageMutation) RemovedIdeaTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedidea_translations {
		ids = append(ids, id)
	}
	return
}

// IdeaTranslationsIDs returns the "idea_translations" edge IDs in the mutation.
func (m *LanguageMutation) IdeaTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.idea_translations {
		ids = append(ids, id)
	}
	return
}

// ResetIdeaTranslations resets all changes to the "idea_translations" edge.
func (m *LanguageMutation) ResetIdeaTranslations() {
	m.idea_translations = nil
	m.clearedidea_translations = false
	m.removedidea_translations = nil
}

// AddResearchProjectTranslationIDs adds the "research_project_translations" edge to the ResearchProjectTranslation entity by ids.
func (m *LanguageMutation) AddResearchProjectTranslationIDs(ids ...uuid.UUID) {
	if m.research_project_translations == nil {
		m.research_project_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.research_project_translations[ids[i]] = struct{}{}
	}
}

// ClearResearchProjectTranslations clears the "research_project_translations" edge to the ResearchProjectTranslation entity.
func (m *LanguageMutation) ClearResearchProjectTranslations() {
	m.clearedresearch_project_translations = true
}

// ResearchProjectTranslationsCleared reports if the "research_project_translations" edge to the ResearchProjectTranslation entity was cleared.
func (m *LanguageMutation) ResearchProjectTranslationsCleared() bool {
	return m.clearedresearch_project_translations
}

// RemoveResearchProjectTranslationIDs removes the "research_project_translations" edge to the ResearchProjectTranslation entity by IDs.
func (m *LanguageMutation) RemoveResearchProjectTranslationIDs(ids ...uuid.UUID) {
	if m.removedresearch_project_translations == nil {
		m.removedresearch_project_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.research_project_translations, ids[i])
		m.removedresearch_project_translations[ids[i]] = struct{}{}
	}
}

// RemovedResearchProjectTranslations returns the removed IDs of the "research_project_translations" edge to the ResearchProjectTranslation entity.
func (m *LanguageMutation) RemovedResearchProjectTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedresearch_project_translations {
		ids = append(ids, id)
	}
	return
}

// ResearchProjectTranslationsIDs returns the "research_project_translations" edge IDs in the mutation.
func (m *LanguageMutation) ResearchProjectTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.research_project_translations {
		ids = append(ids, id)
	}
	return
}

// ResetResearchProjectTranslations resets all changes to the "research_project_translations" edge.
func (m *LanguageMutation) ResetResearchProjectTranslations() {
	m.research_project_translations = nil
	m.clearedresearch_project_translations = false
	m.removedresearch_project_translations = nil
}

// AddResearchProjectDetailTranslationIDs adds the "research_project_detail_translations" edge to the ResearchProjectDetailTranslation entity by ids.
func (m *LanguageMutation) AddResearchProjectDetailTranslationIDs(ids ...uuid.UUID) {
	if m.research_project_detail_translations == nil {
		m.research_project_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.research_project_detail_translations[ids[i]] = struct{}{}
	}
}

// ClearResearchProjectDetailTranslations clears the "research_project_detail_translations" edge to the ResearchProjectDetailTranslation entity.
func (m *LanguageMutation) ClearResearchProjectDetailTranslations() {
	m.clearedresearch_project_detail_translations = true
}

// ResearchProjectDetailTranslationsCleared reports if the "research_project_detail_translations" edge to the ResearchProjectDetailTranslation entity was cleared.
func (m *LanguageMutation) ResearchProjectDetailTranslationsCleared() bool {
	return m.clearedresearch_project_detail_translations
}

// RemoveResearchProjectDetailTranslationIDs removes the "research_project_detail_translations" edge to the ResearchProjectDetailTranslation entity by IDs.
func (m *LanguageMutation) RemoveResearchProjectDetailTranslationIDs(ids ...uuid.UUID) {
	if m.removedresearch_project_detail_translations == nil {
		m.removedresearch_project_detail_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.research_project_detail_translations, ids[i])
		m.removedresearch_project_detail_translations[ids[i]] = struct{}{}
	}
}

// RemovedResearchProjectDetailTranslations returns the removed IDs of the "research_project_detail_translations" edge to the ResearchProjectDetailTranslation entity.
func (m *LanguageMutation) RemovedResearchProjectDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedresearch_project_detail_translations {
		ids = append(ids, id)
	}
	return
}

// ResearchProjectDetailTranslationsIDs returns the "research_project_detail_translations" edge IDs in the mutation.
func (m *LanguageMutation) ResearchProjectDetailTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.research_project_detail_translations {
		ids = append(ids, id)
	}
	return
}

// ResetResearchProjectDetailTranslations resets all changes to the "research_project_detail_translations" edge.
func (m *LanguageMutation) ResetResearchProjectDetailTranslations() {
	m.research_project_detail_translations = nil
	m.clearedresearch_project_detail_translations = false
	m.removedresearch_project_detail_translations = nil
}

// AddPublicationTranslationIDs adds the "publication_translations" edge to the PublicationTranslation entity by ids.
func (m *LanguageMutation) AddPublicationTranslationIDs(ids ...uuid.UUID) {
	if m.publication_translations == nil {
		m.publication_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.publication_translations[ids[i]] = struct{}{}
	}
}

// ClearPublicationTranslations clears the "publication_translations" edge to the PublicationTranslation entity.
func (m *LanguageMutation) ClearPublicationTranslations() {
	m.clearedpublication_translations = true
}

// PublicationTranslationsCleared reports if the "publication_translations" edge to the PublicationTranslation entity was cleared.
func (m *LanguageMutation) PublicationTranslationsCleared() bool {
	return m.clearedpublication_translations
}

// RemovePublicationTranslationIDs removes the "publication_translations" edge to the PublicationTranslation entity by IDs.
func (m *LanguageMutation) RemovePublicationTranslationIDs(ids ...uuid.UUID) {
	if m.removedpublication_translations == nil {
		m.removedpublication_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.publication_translations, ids[i])
		m.removedpublication_translations[ids[i]] = struct{}{}
	}
}

// RemovedPublicationTranslations returns the removed IDs of the "publication_translations" edge to the PublicationTranslation entity.
func (m *LanguageMutation) RemovedPublicationTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedpublication_translations {
		ids = append(ids, id)
	}
	return
}

// PublicationTranslationsIDs returns the "publication_translations" edge IDs in the mutation.
func (m *LanguageMutation) PublicationTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.publication_translations {
		ids = append(ids, id)
	}
	return
}

// ResetPublicationTranslations resets all changes to the "publication_translations" edge.
func (m *LanguageMutation) ResetPublicationTranslations() {
	m.publication_translations = nil
	m.clearedpublication_translations = false
	m.removedpublication_translations = nil
}

// AddAwardTranslationIDs adds the "award_translations" edge to the AwardTranslation entity by ids.
func (m *LanguageMutation) AddAwardTranslationIDs(ids ...uuid.UUID) {
	if m.award_translations == nil {
		m.award_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.award_translations[ids[i]] = struct{}{}
	}
}

// ClearAwardTranslations clears the "award_translations" edge to the AwardTranslation entity.
func (m *LanguageMutation) ClearAwardTranslations() {
	m.clearedaward_translations = true
}

// AwardTranslationsCleared reports if the "award_translations" edge to the AwardTranslation entity was cleared.
func (m *LanguageMutation) AwardTranslationsCleared() bool {
	return m.clearedaward_translations
}

// RemoveAwardTranslationIDs removes the "award_translations" edge to the AwardTranslation entity by IDs.
func (m *LanguageMutation) RemoveAwardTranslationIDs(ids ...uuid.UUID) {
	if m.removedaward_translations == nil {
		m.removedaward_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.award_translations, ids[i])
		m.removedaward_translations[ids[i]] = struct{}{}
	}
}

// RemovedAwardTranslations returns the removed IDs of the "award_translations" edge to the AwardTranslation entity.
func (m *LanguageMutation) RemovedAwardTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedaward_translations {
		ids = append(ids, id)
	}
	return
}

// AwardTranslationsIDs returns the "award_translations" edge IDs in the mutation.
func (m *LanguageMutation) AwardTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.award_translations {
		ids = append(ids, id)
	}
	return
}

// ResetAwardTranslations resets all changes to the "award_translations" edge.
func (m *LanguageMutation) ResetAwardTranslations() {
	m.award_translations = nil
	m.clearedaward_translations = false
	m.removedaward_translations = nil
}

// AddRecentUpdateTranslationIDs adds the "recent_update_translations" edge to the RecentUpdateTranslation entity by ids.
func (m *LanguageMutation) AddRecentUpdateTranslationIDs(ids ...uuid.UUID) {
	if m.recent_update_translations == nil {
		m.recent_update_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.recent_update_translations[ids[i]] = struct{}{}
	}
}

// ClearRecentUpdateTranslations clears the "recent_update_translations" edge to the RecentUpdateTranslation entity.
func (m *LanguageMutation) ClearRecentUpdateTranslations() {
	m.clearedrecent_update_translations = true
}

// RecentUpdateTranslationsCleared reports if the "recent_update_translations" edge to the RecentUpdateTranslation entity was cleared.
func (m *LanguageMutation) RecentUpdateTranslationsCleared() bool {
	return m.clearedrecent_update_translations
}

// RemoveRecentUpdateTranslationIDs removes the "recent_update_translations" edge to the RecentUpdateTranslation entity by IDs.
func (m *LanguageMutation) RemoveRecentUpdateTranslationIDs(ids ...uuid.UUID) {
	if m.removedrecent_update_translations == nil {
		m.removedrecent_update_translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.recent_update_translations, ids[i])
		m.removedrecent_update_translations[ids[i]] = struct{}{}
	}
}

// RemovedRecentUpdateTranslations returns the removed IDs of the "recent_update_translations" edge to the RecentUpdateTranslation entity.
func (m *LanguageMutation) RemovedRecentUpdateTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedrecent_update_translations {
		ids = append(ids, id)
	}
	return
}

// RecentUpdateTranslationsIDs returns the "recent_update_translations" edge IDs in the mutation.
func (m *LanguageMutation) RecentUpdateTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.recent_update_translations {
		ids = append(ids, id)
	}
	return
}

// ResetRecentUpdateTranslations resets all changes to the "recent_update_translations" edge.
func (m *LanguageMutation) ResetRecentUpdateTranslations() {
	m.recent_update_translations = nil
	m.clearedrecent_update_translations = false
	m.removedrecent_update_translations = nil
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, language.FieldName)
	}
	if m.native_name != nil {
		fields = append(fields, language.FieldNativeName)
	}
	if m.is_active != nil {
		fields = append(fields, language.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, language.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldName:
		return m.Name()
	case language.FieldNativeName:
		return m.NativeName()
	case language.FieldIsActive:
		return m.IsActive()
	case language.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldName:
		return m.OldName(ctx)
	case language.FieldNativeName:
		return m.OldNativeName(ctx)
	case language.FieldIsActive:
		return m.OldIsActive(ctx)
	case language.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case language.FieldNativeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNativeName(v)
		return nil
	case language.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case language.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldName:
		m.ResetName()
		return nil
	case language.FieldNativeName:
		m.ResetNativeName()
		return nil
	case language.FieldIsActive:
		m.ResetIsActive()
		return nil
	case language.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.personal_info_translations != nil {
		edges = append(edges, language.EdgePersonalInfoTranslations)
	}
	if m.education_translations != nil {
		edges = append(edges, language.EdgeEducationTranslations)
	}
	if m.education_detail_translations != nil {
		edges = append(edges, language.EdgeEducationDetailTranslations)
	}
	if m.work_experience_translations != nil {
		edges = append(edges, language.EdgeWorkExperienceTranslations)
	}
	if m.work_experience_detail_translations != nil {
		edges = append(edges, language.EdgeWorkExperienceDetailTranslations)
	}
	if m.project_translations != nil {
		edges = append(edges, language.EdgeProjectTranslations)
	}
	if m.project_detail_translations != nil {
		edges = append(edges, language.EdgeProjectDetailTranslations)
	}
	if m.project_image_translations != nil {
		edges = append(edges, language.EdgeProjectImageTranslations)
	}
	if m.blog_category_translations != nil {
		edges = append(edges, language.EdgeBlogCategoryTranslations)
	}
	if m.blog_post_translations != nil {
		edges = append(edges, language.EdgeBlogPostTranslations)
	}
	if m.blog_series_translations != nil {
		edges = append(edges, language.EdgeBlogSeriesTranslations)
	}
	if m.idea_translations != nil {
		edges = append(edges, language.EdgeIdeaTranslations)
	}
	if m.research_project_translations != nil {
		edges = append(edges, language.EdgeResearchProjectTranslations)
	}
	if m.research_project_detail_translations != nil {
		edges = append(edges, language.EdgeResearchProjectDetailTranslations)
	}
	if m.publication_translations != nil {
		edges = append(edges, language.EdgePublicationTranslations)
	}
	if m.award_translations != nil {
		edges = append(edges, language.EdgeAwardTranslations)
	}
	if m.recent_update_translations != nil {
		edges = append(edges, language.EdgeRecentUpdateTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case language.EdgePersonalInfoTranslations:
		ids := make([]ent.Value, 0, len(m.personal_info_translations))
		for id := range m.personal_info_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeEducationTranslations:
		ids := make([]ent.Value, 0, len(m.education_translations))
		for id := range m.education_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeEducationDetailTranslations:
		ids := make([]ent.Value, 0, len(m.education_detail_translations))
		for id := range m.education_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeWorkExperienceTranslations:
		ids := make([]ent.Value, 0, len(m.work_experience_translations))
		for id := range m.work_experience_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeWorkExperienceDetailTranslations:
		ids := make([]ent.Value, 0, len(m.work_experience_detail_translations))
		for id := range m.work_experience_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeProjectTranslations:
		ids := make([]ent.Value, 0, len(m.project_translations))
		for id := range m.project_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeProjectDetailTranslations:
		ids := make([]ent.Value, 0, len(m.project_detail_translations))
		for id := range m.project_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeProjectImageTranslations:
		ids := make([]ent.Value, 0, len(m.project_image_translations))
		for id := range m.project_image_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeBlogCategoryTranslations:
		ids := make([]ent.Value, 0, len(m.blog_category_translations))
		for id := range m.blog_category_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeBlogPostTranslations:
		ids := make([]ent.Value, 0, len(m.blog_post_translations))
		for id := range m.blog_post_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeBlogSeriesTranslations:
		ids := make([]ent.Value, 0, len(m.blog_series_translations))
		for id := range m.blog_series_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeIdeaTranslations:
		ids := make([]ent.Value, 0, len(m.idea_translations))
		for id := range m.idea_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeResearchProjectTranslations:
		ids := make([]ent.Value, 0, len(m.research_project_translations))
		for id := range m.research_project_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeResearchProjectDetailTranslations:
		ids := make([]ent.Value, 0, len(m.research_project_detail_translations))
		for id := range m.research_project_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgePublicationTranslations:
		ids := make([]ent.Value, 0, len(m.publication_translations))
		for id := range m.publication_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeAwardTranslations:
		ids := make([]ent.Value, 0, len(m.award_translations))
		for id := range m.award_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeRecentUpdateTranslations:
		ids := make([]ent.Value, 0, len(m.recent_update_translations))
		for id := range m.recent_update_translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedpersonal_info_translations != nil {
		edges = append(edges, language.EdgePersonalInfoTranslations)
	}
	if m.removededucation_translations != nil {
		edges = append(edges, language.EdgeEducationTranslations)
	}
	if m.removededucation_detail_translations != nil {
		edges = append(edges, language.EdgeEducationDetailTranslations)
	}
	if m.removedwork_experience_translations != nil {
		edges = append(edges, language.EdgeWorkExperienceTranslations)
	}
	if m.removedwork_experience_detail_translations != nil {
		edges = append(edges, language.EdgeWorkExperienceDetailTranslations)
	}
	if m.removedproject_translations != nil {
		edges = append(edges, language.EdgeProjectTranslations)
	}
	if m.removedproject_detail_translations != nil {
		edges = append(edges, language.EdgeProjectDetailTranslations)
	}
	if m.removedproject_image_translations != nil {
		edges = append(edges, language.EdgeProjectImageTranslations)
	}
	if m.removedblog_category_translations != nil {
		edges = append(edges, language.EdgeBlogCategoryTranslations)
	}
	if m.removedblog_post_translations != nil {
		edges = append(edges, language.EdgeBlogPostTranslations)
	}
	if m.removedblog_series_translations != nil {
		edges = append(edges, language.EdgeBlogSeriesTranslations)
	}
	if m.removedidea_translations != nil {
		edges = append(edges, language.EdgeIdeaTranslations)
	}
	if m.removedresearch_project_translations != nil {
		edges = append(edges, language.EdgeResearchProjectTranslations)
	}
	if m.removedresearch_project_detail_translations != nil {
		edges = append(edges, language.EdgeResearchProjectDetailTranslations)
	}
	if m.removedpublication_translations != nil {
		edges = append(edges, language.EdgePublicationTranslations)
	}
	if m.removedaward_translations != nil {
		edges = append(edges, language.EdgeAwardTranslations)
	}
	if m.removedrecent_update_translations != nil {
		edges = append(edges, language.EdgeRecentUpdateTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case language.EdgePersonalInfoTranslations:
		ids := make([]ent.Value, 0, len(m.removedpersonal_info_translations))
		for id := range m.removedpersonal_info_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeEducationTranslations:
		ids := make([]ent.Value, 0, len(m.removededucation_translations))
		for id := range m.removededucation_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeEducationDetailTranslations:
		ids := make([]ent.Value, 0, len(m.removededucation_detail_translations))
		for id := range m.removededucation_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeWorkExperienceTranslations:
		ids := make([]ent.Value, 0, len(m.removedwork_experience_translations))
		for id := range m.removedwork_experience_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeWorkExperienceDetailTranslations:
		ids := make([]ent.Value, 0, len(m.removedwork_experience_detail_translations))
		for id := range m.removedwork_experience_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeProjectTranslations:
		ids := make([]ent.Value, 0, len(m.removedproject_translations))
		for id := range m.removedproject_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeProjectDetailTranslations:
		ids := make([]ent.Value, 0, len(m.removedproject_detail_translations))
		for id := range m.removedproject_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeProjectImageTranslations:
		ids := make([]ent.Value, 0, len(m.removedproject_image_translations))
		for id := range m.removedproject_image_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeBlogCategoryTranslations:
		ids := make([]ent.Value, 0, len(m.removedblog_category_translations))
		for id := range m.removedblog_category_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeBlogPostTranslations:
		ids := make([]ent.Value, 0, len(m.removedblog_post_translations))
		for id := range m.removedblog_post_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeBlogSeriesTranslations:
		ids := make([]ent.Value, 0, len(m.removedblog_series_translations))
		for id := range m.removedblog_series_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeIdeaTranslations:
		ids := make([]ent.Value, 0, len(m.removedidea_translations))
		for id := range m.removedidea_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeResearchProjectTranslations:
		ids := make([]ent.Value, 0, len(m.removedresearch_project_translations))
		for id := range m.removedresearch_project_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeResearchProjectDetailTranslations:
		ids := make([]ent.Value, 0, len(m.removedresearch_project_detail_translations))
		for id := range m.removedresearch_project_detail_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgePublicationTranslations:
		ids := make([]ent.Value, 0, len(m.removedpublication_translations))
		for id := range m.removedpublication_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeAwardTranslations:
		ids := make([]ent.Value, 0, len(m.removedaward_translations))
		for id := range m.removedaward_translations {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeRecentUpdateTranslations:
		ids := make([]ent.Value, 0, len(m.removedrecent_update_translations))
		for id := range m.removedrecent_update_translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedpersonal_info_translations {
		edges = append(edges, language.EdgePersonalInfoTranslations)
	}
	if m.clearededucation_translations {
		edges = append(edges, language.EdgeEducationTranslations)
	}
	if m.clearededucation_detail_translations {
		edges = append(edges, language.EdgeEducationDetailTranslations)
	}
	if m.clearedwork_experience_translations {
		edges = append(edges, language.EdgeWorkExperienceTranslations)
	}
	if m.clearedwork_experience_detail_translations {
		edges = append(edges, language.EdgeWorkExperienceDetailTranslations)
	}
	if m.clearedproject_translations {
		edges = append(edges, language.EdgeProjectTranslations)
	}
	if m.clearedproject_detail_translations {
		edges = append(edges, language.EdgeProjectDetailTranslations)
	}
	if m.clearedproject_image_translations {
		edges = append(edges, language.EdgeProjectImageTranslations)
	}
	if m.clearedblog_category_translations {
		edges = append(edges, language.EdgeBlogCategoryTranslations)
	}
	if m.clearedblog_post_translations {
		edges = append(edges, language.EdgeBlogPostTranslations)
	}
	if m.clearedblog_series_translations {
		edges = append(edges, language.EdgeBlogSeriesTranslations)
	}
	if m.clearedidea_translations {
		edges = append(edges, language.EdgeIdeaTranslations)
	}
	if m.clearedresearch_project_translations {
		edges = append(edges, language.EdgeResearchProjectTranslations)
	}
	if m.clearedresearch_project_detail_translations {
		edges = append(edges, language.EdgeResearchProjectDetailTranslations)
	}
	if m.clearedpublication_translations {
		edges = append(edges, language.EdgePublicationTranslations)
	}
	if m.clearedaward_translations {
		edges = append(edges, language.EdgeAwardTranslations)
	}
	if m.clearedrecent_update_translations {
		edges = append(edges, language.EdgeRecentUpdateTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case language.EdgePersonalInfoTranslations:
		return m.clearedpersonal_info_translations
	case language.EdgeEducationTranslations:
		return m.clearededucation_translations
	case language.EdgeEducationDetailTranslations:
		return m.clearededucation_detail_translations
	case language.EdgeWorkExperienceTranslations:
		return m.clearedwork_experience_translations
	case language.EdgeWorkExperienceDetailTranslations:
		return m.clearedwork_experience_detail_translations
	case language.EdgeProjectTranslations:
		return m.clearedproject_translations
	case language.EdgeProjectDetailTranslations:
		return m.clearedproject_detail_translations
	case language.EdgeProjectImageTranslations:
		return m.clearedproject_image_translations
	case language.EdgeBlogCategoryTranslations:
		return m.clearedblog_category_translations
	case language.EdgeBlogPostTranslations:
		return m.clearedblog_post_translations
	case language.EdgeBlogSeriesTranslations:
		return m.clearedblog_series_translations
	case language.EdgeIdeaTranslations:
		return m.clearedidea_translations
	case language.EdgeResearchProjectTranslations:
		return m.clearedresearch_project_translations
	case language.EdgeResearchProjectDetailTranslations:
		return m.clearedresearch_project_detail_translations
	case language.EdgePublicationTranslations:
		return m.clearedpublication_translations
	case language.EdgeAwardTranslations:
		return m.clearedaward_translations
	case language.EdgeRecentUpdateTranslations:
		return m.clearedrecent_update_translations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	switch name {
	case language.EdgePersonalInfoTranslations:
		m.ResetPersonalInfoTranslations()
		return nil
	case language.EdgeEducationTranslations:
		m.ResetEducationTranslations()
		return nil
	case language.EdgeEducationDetailTranslations:
		m.ResetEducationDetailTranslations()
		return nil
	case language.EdgeWorkExperienceTranslations:
		m.ResetWorkExperienceTranslations()
		return nil
	case language.EdgeWorkExperienceDetailTranslations:
		m.ResetWorkExperienceDetailTranslations()
		return nil
	case language.EdgeProjectTranslations:
		m.ResetProjectTranslations()
		return nil
	case language.EdgeProjectDetailTranslations:
		m.ResetProjectDetailTranslations()
		return nil
	case language.EdgeProjectImageTranslations:
		m.ResetProjectImageTranslations()
		return nil
	case language.EdgeBlogCategoryTranslations:
		m.ResetBlogCategoryTranslations()
		return nil
	case language.EdgeBlogPostTranslations:
		m.ResetBlogPostTranslations()
		return nil
	case language.EdgeBlogSeriesTranslations:
		m.ResetBlogSeriesTranslations()
		return nil
	case language.EdgeIdeaTranslations:
		m.ResetIdeaTranslations()
		return nil
	case language.EdgeResearchProjectTranslations:
		m.ResetResearchProjectTranslations()
		return nil
	case language.EdgeResearchProjectDetailTranslations:
		m.ResetResearchProjectDetailTranslations()
		return nil
	case language.EdgePublicationTranslations:
		m.ResetPublicationTranslations()
		return nil
	case language.EdgeAwardTranslations:
		m.ResetAwardTranslations()
		return nil
	case language.EdgeRecentUpdateTranslations:
		m.ResetRecentUpdateTranslations()
		return nil
	}
	return fmt.Errorf("unknown Language edge %s", name)
}

// PersonalInfoMutation represents an operation that mutates the PersonalInfo nodes in the graph.
type PersonalInfoMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	full_name           *string
	title               *string
	current_status      *string
	phone               *string
	email               *string
	location            *string
	website             *string
	avatar_url          *string
	is_primary          *bool
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	social_links        map[uuid.UUID]struct{}
	removedsocial_links map[uuid.UUID]struct{}
	clearedsocial_links bool
	done                bool
	oldValue            func(context.Context) (*PersonalInfo, error)
	predicates          []predicate.PersonalInfo
}

var _ ent.Mutation = (*PersonalInfoMutation)(nil)

// personalinfoOption allows management of the mutation configuration using functional options.
type personalinfoOption func(*PersonalInfoMutation)

// newPersonalInfoMutation creates new mutation for the PersonalInfo entity.
func newPersonalInfoMutation(c config, op Op, opts ...personalinfoOption) *PersonalInfoMutation {
	m := &PersonalInfoMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalInfoID sets the ID field of the mutation.
func withPersonalInfoID(id uuid.UUID) personalinfoOption {
	return func(m *PersonalInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalInfo
		)
		m.oldValue = func(ctx context.Context) (*PersonalInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalInfo sets the old PersonalInfo of the mutation.
func withPersonalInfo(node *PersonalInfo) personalinfoOption {
	return func(m *PersonalInfoMutation) {
		m.oldValue = func(context.Context) (*PersonalInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalInfo entities.
func (m *PersonalInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PersonalInfoMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PersonalInfoMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PersonalInfoMutation) ResetUserID() {
	m.user = nil
}

// SetFullName sets the "full_name" field.
func (m *PersonalInfoMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *PersonalInfoMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *PersonalInfoMutation) ResetFullName() {
	m.full_name = nil
}

// SetTitle sets the "title" field.
func (m *PersonalInfoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PersonalInfoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PersonalInfoMutation) ResetTitle() {
	m.title = nil
}

// SetCurrentStatus sets the "current_status" field.
func (m *PersonalInfoMutation) SetCurrentStatus(s string) {
	m.current_status = &s
}

// CurrentStatus returns the value of the "current_status" field in the mutation.
func (m *PersonalInfoMutation) CurrentStatus() (r string, exists bool) {
	v := m.current_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStatus returns the old "current_status" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldCurrentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStatus: %w", err)
	}
	return oldValue.CurrentStatus, nil
}

// ClearCurrentStatus clears the value of the "current_status" field.
func (m *PersonalInfoMutation) ClearCurrentStatus() {
	m.current_status = nil
	m.clearedFields[personalinfo.FieldCurrentStatus] = struct{}{}
}

// CurrentStatusCleared returns if the "current_status" field was cleared in this mutation.
func (m *PersonalInfoMutation) CurrentStatusCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldCurrentStatus]
	return ok
}

// ResetCurrentStatus resets all changes to the "current_status" field.
func (m *PersonalInfoMutation) ResetCurrentStatus() {
	m.current_status = nil
	delete(m.clearedFields, personalinfo.FieldCurrentStatus)
}

// SetPhone sets the "phone" field.
func (m *PersonalInfoMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PersonalInfoMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PersonalInfoMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[personalinfo.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PersonalInfoMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PersonalInfoMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, personalinfo.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *PersonalInfoMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PersonalInfoMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *PersonalInfoMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[personalinfo.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *PersonalInfoMutation) EmailCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *PersonalInfoMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, personalinfo.FieldEmail)
}

// SetLocation sets the "location" field.
func (m *PersonalInfoMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PersonalInfoMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *PersonalInfoMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[personalinfo.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *PersonalInfoMutation) LocationCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *PersonalInfoMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, personalinfo.FieldLocation)
}

// SetWebsite sets the "website" field.
func (m *PersonalInfoMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PersonalInfoMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PersonalInfoMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[personalinfo.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PersonalInfoMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PersonalInfoMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, personalinfo.FieldWebsite)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *PersonalInfoMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *PersonalInfoMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *PersonalInfoMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[personalinfo.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *PersonalInfoMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *PersonalInfoMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, personalinfo.FieldAvatarURL)
}

// SetIsPrimary sets the "is_primary" field.
func (m *PersonalInfoMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *PersonalInfoMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *PersonalInfoMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonalInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonalInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonalInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PersonalInfoMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[personalinfo.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PersonalInfoMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PersonalInfoMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PersonalInfoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the PersonalInfoTranslation entity by ids.
func (m *PersonalInfoMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the PersonalInfoTranslation entity.
func (m *PersonalInfoMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the PersonalInfoTranslation entity was cleared.
func (m *PersonalInfoMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the PersonalInfoTranslation entity by IDs.
func (m *PersonalInfoMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the PersonalInfoTranslation entity.
func (m *PersonalInfoMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *PersonalInfoMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *PersonalInfoMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddSocialLinkIDs adds the "social_links" edge to the SocialLink entity by ids.
func (m *PersonalInfoMutation) AddSocialLinkIDs(ids ...uuid.UUID) {
	if m.social_links == nil {
		m.social_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.social_links[ids[i]] = struct{}{}
	}
}

// ClearSocialLinks clears the "social_links" edge to the SocialLink entity.
func (m *PersonalInfoMutation) ClearSocialLinks() {
	m.clearedsocial_links = true
}

// SocialLinksCleared reports if the "social_links" edge to the SocialLink entity was cleared.
func (m *PersonalInfoMutation) SocialLinksCleared() bool {
	return m.clearedsocial_links
}

// RemoveSocialLinkIDs removes the "social_links" edge to the SocialLink entity by IDs.
func (m *PersonalInfoMutation) RemoveSocialLinkIDs(ids ...uuid.UUID) {
	if m.removedsocial_links == nil {
		m.removedsocial_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.social_links, ids[i])
		m.removedsocial_links[ids[i]] = struct{}{}
	}
}

// RemovedSocialLinks returns the removed IDs of the "social_links" edge to the SocialLink entity.
func (m *PersonalInfoMutation) RemovedSocialLinksIDs() (ids []uuid.UUID) {
	for id := range m.removedsocial_links {
		ids = append(ids, id)
	}
	return
}

// SocialLinksIDs returns the "social_links" edge IDs in the mutation.
func (m *PersonalInfoMutation) SocialLinksIDs() (ids []uuid.UUID) {
	for id := range m.social_links {
		ids = append(ids, id)
	}
	return
}

// ResetSocialLinks resets all changes to the "social_links" edge.
func (m *PersonalInfoMutation) ResetSocialLinks() {
	m.social_links = nil
	m.clearedsocial_links = false
	m.removedsocial_links = nil
}

// Where appends a list predicates to the PersonalInfoMutation builder.
func (m *PersonalInfoMutation) Where(ps ...predicate.PersonalInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalInfo).
func (m *PersonalInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalInfoMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, personalinfo.FieldUserID)
	}
	if m.full_name != nil {
		fields = append(fields, personalinfo.FieldFullName)
	}
	if m.title != nil {
		fields = append(fields, personalinfo.FieldTitle)
	}
	if m.current_status != nil {
		fields = append(fields, personalinfo.FieldCurrentStatus)
	}
	if m.phone != nil {
		fields = append(fields, personalinfo.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, personalinfo.FieldEmail)
	}
	if m.location != nil {
		fields = append(fields, personalinfo.FieldLocation)
	}
	if m.website != nil {
		fields = append(fields, personalinfo.FieldWebsite)
	}
	if m.avatar_url != nil {
		fields = append(fields, personalinfo.FieldAvatarURL)
	}
	if m.is_primary != nil {
		fields = append(fields, personalinfo.FieldIsPrimary)
	}
	if m.created_at != nil {
		fields = append(fields, personalinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personalinfo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalinfo.FieldUserID:
		return m.UserID()
	case personalinfo.FieldFullName:
		return m.FullName()
	case personalinfo.FieldTitle:
		return m.Title()
	case personalinfo.FieldCurrentStatus:
		return m.CurrentStatus()
	case personalinfo.FieldPhone:
		return m.Phone()
	case personalinfo.FieldEmail:
		return m.Email()
	case personalinfo.FieldLocation:
		return m.Location()
	case personalinfo.FieldWebsite:
		return m.Website()
	case personalinfo.FieldAvatarURL:
		return m.AvatarURL()
	case personalinfo.FieldIsPrimary:
		return m.IsPrimary()
	case personalinfo.FieldCreatedAt:
		return m.CreatedAt()
	case personalinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalinfo.FieldUserID:
		return m.OldUserID(ctx)
	case personalinfo.FieldFullName:
		return m.OldFullName(ctx)
	case personalinfo.FieldTitle:
		return m.OldTitle(ctx)
	case personalinfo.FieldCurrentStatus:
		return m.OldCurrentStatus(ctx)
	case personalinfo.FieldPhone:
		return m.OldPhone(ctx)
	case personalinfo.FieldEmail:
		return m.OldEmail(ctx)
	case personalinfo.FieldLocation:
		return m.OldLocation(ctx)
	case personalinfo.FieldWebsite:
		return m.OldWebsite(ctx)
	case personalinfo.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case personalinfo.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case personalinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personalinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalinfo.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case personalinfo.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case personalinfo.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case personalinfo.FieldCurrentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStatus(v)
		return nil
	case personalinfo.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case personalinfo.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case personalinfo.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case personalinfo.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case personalinfo.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case personalinfo.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case personalinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personalinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalinfo.FieldCurrentStatus) {
		fields = append(fields, personalinfo.FieldCurrentStatus)
	}
	if m.FieldCleared(personalinfo.FieldPhone) {
		fields = append(fields, personalinfo.FieldPhone)
	}
	if m.FieldCleared(personalinfo.FieldEmail) {
		fields = append(fields, personalinfo.FieldEmail)
	}
	if m.FieldCleared(personalinfo.FieldLocation) {
		fields = append(fields, personalinfo.FieldLocation)
	}
	if m.FieldCleared(personalinfo.FieldWebsite) {
		fields = append(fields, personalinfo.FieldWebsite)
	}
	if m.FieldCleared(personalinfo.FieldAvatarURL) {
		fields = append(fields, personalinfo.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalInfoMutation) ClearField(name string) error {
	switch name {
	case personalinfo.FieldCurrentStatus:
		m.ClearCurrentStatus()
		return nil
	case personalinfo.FieldPhone:
		m.ClearPhone()
		return nil
	case personalinfo.FieldEmail:
		m.ClearEmail()
		return nil
	case personalinfo.FieldLocation:
		m.ClearLocation()
		return nil
	case personalinfo.FieldWebsite:
		m.ClearWebsite()
		return nil
	case personalinfo.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalInfoMutation) ResetField(name string) error {
	switch name {
	case personalinfo.FieldUserID:
		m.ResetUserID()
		return nil
	case personalinfo.FieldFullName:
		m.ResetFullName()
		return nil
	case personalinfo.FieldTitle:
		m.ResetTitle()
		return nil
	case personalinfo.FieldCurrentStatus:
		m.ResetCurrentStatus()
		return nil
	case personalinfo.FieldPhone:
		m.ResetPhone()
		return nil
	case personalinfo.FieldEmail:
		m.ResetEmail()
		return nil
	case personalinfo.FieldLocation:
		m.ResetLocation()
		return nil
	case personalinfo.FieldWebsite:
		m.ResetWebsite()
		return nil
	case personalinfo.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case personalinfo.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case personalinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personalinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, personalinfo.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, personalinfo.EdgeTranslations)
	}
	if m.social_links != nil {
		edges = append(edges, personalinfo.EdgeSocialLinks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalinfo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case personalinfo.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case personalinfo.EdgeSocialLinks:
		ids := make([]ent.Value, 0, len(m.social_links))
		for id := range m.social_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtranslations != nil {
		edges = append(edges, personalinfo.EdgeTranslations)
	}
	if m.removedsocial_links != nil {
		edges = append(edges, personalinfo.EdgeSocialLinks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case personalinfo.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case personalinfo.EdgeSocialLinks:
		ids := make([]ent.Value, 0, len(m.removedsocial_links))
		for id := range m.removedsocial_links {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, personalinfo.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, personalinfo.EdgeTranslations)
	}
	if m.clearedsocial_links {
		edges = append(edges, personalinfo.EdgeSocialLinks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case personalinfo.EdgeUser:
		return m.cleareduser
	case personalinfo.EdgeTranslations:
		return m.clearedtranslations
	case personalinfo.EdgeSocialLinks:
		return m.clearedsocial_links
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalInfoMutation) ClearEdge(name string) error {
	switch name {
	case personalinfo.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalInfoMutation) ResetEdge(name string) error {
	switch name {
	case personalinfo.EdgeUser:
		m.ResetUser()
		return nil
	case personalinfo.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case personalinfo.EdgeSocialLinks:
		m.ResetSocialLinks()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo edge %s", name)
}

// PersonalInfoTranslationMutation represents an operation that mutates the PersonalInfoTranslation nodes in the graph.
type PersonalInfoTranslationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	full_name            *string
	title                *string
	current_status       *string
	location             *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	personal_info        *uuid.UUID
	clearedpersonal_info bool
	language             *string
	clearedlanguage      bool
	done                 bool
	oldValue             func(context.Context) (*PersonalInfoTranslation, error)
	predicates           []predicate.PersonalInfoTranslation
}

var _ ent.Mutation = (*PersonalInfoTranslationMutation)(nil)

// personalinfotranslationOption allows management of the mutation configuration using functional options.
type personalinfotranslationOption func(*PersonalInfoTranslationMutation)

// newPersonalInfoTranslationMutation creates new mutation for the PersonalInfoTranslation entity.
func newPersonalInfoTranslationMutation(c config, op Op, opts ...personalinfotranslationOption) *PersonalInfoTranslationMutation {
	m := &PersonalInfoTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalInfoTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalInfoTranslationID sets the ID field of the mutation.
func withPersonalInfoTranslationID(id uuid.UUID) personalinfotranslationOption {
	return func(m *PersonalInfoTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalInfoTranslation
		)
		m.oldValue = func(ctx context.Context) (*PersonalInfoTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalInfoTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalInfoTranslation sets the old PersonalInfoTranslation of the mutation.
func withPersonalInfoTranslation(node *PersonalInfoTranslation) personalinfotranslationOption {
	return func(m *PersonalInfoTranslationMutation) {
		m.oldValue = func(context.Context) (*PersonalInfoTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalInfoTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalInfoTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalInfoTranslation entities.
func (m *PersonalInfoTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalInfoTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalInfoTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalInfoTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPersonalInfoID sets the "personal_info_id" field.
func (m *PersonalInfoTranslationMutation) SetPersonalInfoID(u uuid.UUID) {
	m.personal_info = &u
}

// PersonalInfoID returns the value of the "personal_info_id" field in the mutation.
func (m *PersonalInfoTranslationMutation) PersonalInfoID() (r uuid.UUID, exists bool) {
	v := m.personal_info
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalInfoID returns the old "personal_info_id" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldPersonalInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalInfoID: %w", err)
	}
	return oldValue.PersonalInfoID, nil
}

// ResetPersonalInfoID resets all changes to the "personal_info_id" field.
func (m *PersonalInfoTranslationMutation) ResetPersonalInfoID() {
	m.personal_info = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *PersonalInfoTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *PersonalInfoTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *PersonalInfoTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetFullName sets the "full_name" field.
func (m *PersonalInfoTranslationMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *PersonalInfoTranslationMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ClearFullName clears the value of the "full_name" field.
func (m *PersonalInfoTranslationMutation) ClearFullName() {
	m.full_name = nil
	m.clearedFields[personalinfotranslation.FieldFullName] = struct{}{}
}

// FullNameCleared returns if the "full_name" field was cleared in this mutation.
func (m *PersonalInfoTranslationMutation) FullNameCleared() bool {
	_, ok := m.clearedFields[personalinfotranslation.FieldFullName]
	return ok
}

// ResetFullName resets all changes to the "full_name" field.
func (m *PersonalInfoTranslationMutation) ResetFullName() {
	m.full_name = nil
	delete(m.clearedFields, personalinfotranslation.FieldFullName)
}

// SetTitle sets the "title" field.
func (m *PersonalInfoTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PersonalInfoTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PersonalInfoTranslationMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[personalinfotranslation.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PersonalInfoTranslationMutation) TitleCleared() bool {
	_, ok := m.clearedFields[personalinfotranslation.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PersonalInfoTranslationMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, personalinfotranslation.FieldTitle)
}

// SetCurrentStatus sets the "current_status" field.
func (m *PersonalInfoTranslationMutation) SetCurrentStatus(s string) {
	m.current_status = &s
}

// CurrentStatus returns the value of the "current_status" field in the mutation.
func (m *PersonalInfoTranslationMutation) CurrentStatus() (r string, exists bool) {
	v := m.current_status
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentStatus returns the old "current_status" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldCurrentStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentStatus: %w", err)
	}
	return oldValue.CurrentStatus, nil
}

// ClearCurrentStatus clears the value of the "current_status" field.
func (m *PersonalInfoTranslationMutation) ClearCurrentStatus() {
	m.current_status = nil
	m.clearedFields[personalinfotranslation.FieldCurrentStatus] = struct{}{}
}

// CurrentStatusCleared returns if the "current_status" field was cleared in this mutation.
func (m *PersonalInfoTranslationMutation) CurrentStatusCleared() bool {
	_, ok := m.clearedFields[personalinfotranslation.FieldCurrentStatus]
	return ok
}

// ResetCurrentStatus resets all changes to the "current_status" field.
func (m *PersonalInfoTranslationMutation) ResetCurrentStatus() {
	m.current_status = nil
	delete(m.clearedFields, personalinfotranslation.FieldCurrentStatus)
}

// SetLocation sets the "location" field.
func (m *PersonalInfoTranslationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PersonalInfoTranslationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *PersonalInfoTranslationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[personalinfotranslation.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *PersonalInfoTranslationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[personalinfotranslation.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *PersonalInfoTranslationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, personalinfotranslation.FieldLocation)
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalInfoTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalInfoTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonalInfoTranslation entity.
// If the PersonalInfoTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalInfoTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearPersonalInfo clears the "personal_info" edge to the PersonalInfo entity.
func (m *PersonalInfoTranslationMutation) ClearPersonalInfo() {
	m.clearedpersonal_info = true
	m.clearedFields[personalinfotranslation.FieldPersonalInfoID] = struct{}{}
}

// PersonalInfoCleared reports if the "personal_info" edge to the PersonalInfo entity was cleared.
func (m *PersonalInfoTranslationMutation) PersonalInfoCleared() bool {
	return m.clearedpersonal_info
}

// PersonalInfoIDs returns the "personal_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonalInfoID instead. It exists only for internal usage by the builders.
func (m *PersonalInfoTranslationMutation) PersonalInfoIDs() (ids []uuid.UUID) {
	if id := m.personal_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonalInfo resets all changes to the "personal_info" edge.
func (m *PersonalInfoTranslationMutation) ResetPersonalInfo() {
	m.personal_info = nil
	m.clearedpersonal_info = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *PersonalInfoTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *PersonalInfoTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[personalinfotranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *PersonalInfoTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *PersonalInfoTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *PersonalInfoTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *PersonalInfoTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the PersonalInfoTranslationMutation builder.
func (m *PersonalInfoTranslationMutation) Where(ps ...predicate.PersonalInfoTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalInfoTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalInfoTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalInfoTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalInfoTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalInfoTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalInfoTranslation).
func (m *PersonalInfoTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalInfoTranslationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.personal_info != nil {
		fields = append(fields, personalinfotranslation.FieldPersonalInfoID)
	}
	if m.language != nil {
		fields = append(fields, personalinfotranslation.FieldLanguageCode)
	}
	if m.full_name != nil {
		fields = append(fields, personalinfotranslation.FieldFullName)
	}
	if m.title != nil {
		fields = append(fields, personalinfotranslation.FieldTitle)
	}
	if m.current_status != nil {
		fields = append(fields, personalinfotranslation.FieldCurrentStatus)
	}
	if m.location != nil {
		fields = append(fields, personalinfotranslation.FieldLocation)
	}
	if m.created_at != nil {
		fields = append(fields, personalinfotranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalInfoTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalinfotranslation.FieldPersonalInfoID:
		return m.PersonalInfoID()
	case personalinfotranslation.FieldLanguageCode:
		return m.LanguageCode()
	case personalinfotranslation.FieldFullName:
		return m.FullName()
	case personalinfotranslation.FieldTitle:
		return m.Title()
	case personalinfotranslation.FieldCurrentStatus:
		return m.CurrentStatus()
	case personalinfotranslation.FieldLocation:
		return m.Location()
	case personalinfotranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalInfoTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalinfotranslation.FieldPersonalInfoID:
		return m.OldPersonalInfoID(ctx)
	case personalinfotranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case personalinfotranslation.FieldFullName:
		return m.OldFullName(ctx)
	case personalinfotranslation.FieldTitle:
		return m.OldTitle(ctx)
	case personalinfotranslation.FieldCurrentStatus:
		return m.OldCurrentStatus(ctx)
	case personalinfotranslation.FieldLocation:
		return m.OldLocation(ctx)
	case personalinfotranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalInfoTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalinfotranslation.FieldPersonalInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalInfoID(v)
		return nil
	case personalinfotranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case personalinfotranslation.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case personalinfotranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case personalinfotranslation.FieldCurrentStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentStatus(v)
		return nil
	case personalinfotranslation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case personalinfotranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalInfoTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalInfoTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalInfoTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalInfoTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalInfoTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalinfotranslation.FieldFullName) {
		fields = append(fields, personalinfotranslation.FieldFullName)
	}
	if m.FieldCleared(personalinfotranslation.FieldTitle) {
		fields = append(fields, personalinfotranslation.FieldTitle)
	}
	if m.FieldCleared(personalinfotranslation.FieldCurrentStatus) {
		fields = append(fields, personalinfotranslation.FieldCurrentStatus)
	}
	if m.FieldCleared(personalinfotranslation.FieldLocation) {
		fields = append(fields, personalinfotranslation.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalInfoTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalInfoTranslationMutation) ClearField(name string) error {
	switch name {
	case personalinfotranslation.FieldFullName:
		m.ClearFullName()
		return nil
	case personalinfotranslation.FieldTitle:
		m.ClearTitle()
		return nil
	case personalinfotranslation.FieldCurrentStatus:
		m.ClearCurrentStatus()
		return nil
	case personalinfotranslation.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfoTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalInfoTranslationMutation) ResetField(name string) error {
	switch name {
	case personalinfotranslation.FieldPersonalInfoID:
		m.ResetPersonalInfoID()
		return nil
	case personalinfotranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case personalinfotranslation.FieldFullName:
		m.ResetFullName()
		return nil
	case personalinfotranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case personalinfotranslation.FieldCurrentStatus:
		m.ResetCurrentStatus()
		return nil
	case personalinfotranslation.FieldLocation:
		m.ResetLocation()
		return nil
	case personalinfotranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfoTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalInfoTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.personal_info != nil {
		edges = append(edges, personalinfotranslation.EdgePersonalInfo)
	}
	if m.language != nil {
		edges = append(edges, personalinfotranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalInfoTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalinfotranslation.EdgePersonalInfo:
		if id := m.personal_info; id != nil {
			return []ent.Value{*id}
		}
	case personalinfotranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalInfoTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalInfoTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalInfoTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpersonal_info {
		edges = append(edges, personalinfotranslation.EdgePersonalInfo)
	}
	if m.clearedlanguage {
		edges = append(edges, personalinfotranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalInfoTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case personalinfotranslation.EdgePersonalInfo:
		return m.clearedpersonal_info
	case personalinfotranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalInfoTranslationMutation) ClearEdge(name string) error {
	switch name {
	case personalinfotranslation.EdgePersonalInfo:
		m.ClearPersonalInfo()
		return nil
	case personalinfotranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfoTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalInfoTranslationMutation) ResetEdge(name string) error {
	switch name {
	case personalinfotranslation.EdgePersonalInfo:
		m.ResetPersonalInfo()
		return nil
	case personalinfotranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfoTranslation edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	title                       *string
	slug                        *string
	description                 *string
	project_type                *string
	status                      *project.Status
	start_date                  *time.Time
	end_date                    *time.Time
	github_url                  *string
	demo_url                    *string
	documentation_url           *string
	thumbnail_url               *string
	is_featured                 *bool
	is_public                   *bool
	view_count                  *int
	addview_count               *int
	star_count                  *int
	addstar_count               *int
	sort_order                  *int
	addsort_order               *int
	created_at                  *time.Time
	updated_at                  *time.Time
	clearedFields               map[string]struct{}
	user                        *uuid.UUID
	cleareduser                 bool
	translations                map[uuid.UUID]struct{}
	removedtranslations         map[uuid.UUID]struct{}
	clearedtranslations         bool
	technologies                map[uuid.UUID]struct{}
	removedtechnologies         map[uuid.UUID]struct{}
	clearedtechnologies         bool
	details                     *uuid.UUID
	cleareddetails              bool
	images                      map[uuid.UUID]struct{}
	removedimages               map[uuid.UUID]struct{}
	clearedimages               bool
	source_relationships        map[uuid.UUID]struct{}
	removedsource_relationships map[uuid.UUID]struct{}
	clearedsource_relationships bool
	target_relationships        map[uuid.UUID]struct{}
	removedtarget_relationships map[uuid.UUID]struct{}
	clearedtarget_relationships bool
	done                        bool
	oldValue                    func(context.Context) (*Project, error)
	predicates                  []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ProjectMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProjectMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProjectMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *ProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *ProjectMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProjectMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProjectMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetProjectType sets the "project_type" field.
func (m *ProjectMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *ProjectMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *ProjectMutation) ResetProjectType() {
	m.project_type = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProjectMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[project.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProjectMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[project.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, project.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// SetGithubURL sets the "github_url" field.
func (m *ProjectMutation) SetGithubURL(s string) {
	m.github_url = &s
}

// GithubURL returns the value of the "github_url" field in the mutation.
func (m *ProjectMutation) GithubURL() (r string, exists bool) {
	v := m.github_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubURL returns the old "github_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubURL: %w", err)
	}
	return oldValue.GithubURL, nil
}

// ClearGithubURL clears the value of the "github_url" field.
func (m *ProjectMutation) ClearGithubURL() {
	m.github_url = nil
	m.clearedFields[project.FieldGithubURL] = struct{}{}
}

// GithubURLCleared returns if the "github_url" field was cleared in this mutation.
func (m *ProjectMutation) GithubURLCleared() bool {
	_, ok := m.clearedFields[project.FieldGithubURL]
	return ok
}

// ResetGithubURL resets all changes to the "github_url" field.
func (m *ProjectMutation) ResetGithubURL() {
	m.github_url = nil
	delete(m.clearedFields, project.FieldGithubURL)
}

// SetDemoURL sets the "demo_url" field.
func (m *ProjectMutation) SetDemoURL(s string) {
	m.demo_url = &s
}

// DemoURL returns the value of the "demo_url" field in the mutation.
func (m *ProjectMutation) DemoURL() (r string, exists bool) {
	v := m.demo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDemoURL returns the old "demo_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDemoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDemoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDemoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDemoURL: %w", err)
	}
	return oldValue.DemoURL, nil
}

// ClearDemoURL clears the value of the "demo_url" field.
func (m *ProjectMutation) ClearDemoURL() {
	m.demo_url = nil
	m.clearedFields[project.FieldDemoURL] = struct{}{}
}

// DemoURLCleared returns if the "demo_url" field was cleared in this mutation.
func (m *ProjectMutation) DemoURLCleared() bool {
	_, ok := m.clearedFields[project.FieldDemoURL]
	return ok
}

// ResetDemoURL resets all changes to the "demo_url" field.
func (m *ProjectMutation) ResetDemoURL() {
	m.demo_url = nil
	delete(m.clearedFields, project.FieldDemoURL)
}

// SetDocumentationURL sets the "documentation_url" field.
func (m *ProjectMutation) SetDocumentationURL(s string) {
	m.documentation_url = &s
}

// DocumentationURL returns the value of the "documentation_url" field in the mutation.
func (m *ProjectMutation) DocumentationURL() (r string, exists bool) {
	v := m.documentation_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationURL returns the old "documentation_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDocumentationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationURL: %w", err)
	}
	return oldValue.DocumentationURL, nil
}

// ClearDocumentationURL clears the value of the "documentation_url" field.
func (m *ProjectMutation) ClearDocumentationURL() {
	m.documentation_url = nil
	m.clearedFields[project.FieldDocumentationURL] = struct{}{}
}

// DocumentationURLCleared returns if the "documentation_url" field was cleared in this mutation.
func (m *ProjectMutation) DocumentationURLCleared() bool {
	_, ok := m.clearedFields[project.FieldDocumentationURL]
	return ok
}

// ResetDocumentationURL resets all changes to the "documentation_url" field.
func (m *ProjectMutation) ResetDocumentationURL() {
	m.documentation_url = nil
	delete(m.clearedFields, project.FieldDocumentationURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *ProjectMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *ProjectMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *ProjectMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[project.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *ProjectMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[project.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *ProjectMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, project.FieldThumbnailURL)
}

// SetIsFeatured sets the "is_featured" field.
func (m *ProjectMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *ProjectMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *ProjectMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// SetIsPublic sets the "is_public" field.
func (m *ProjectMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ProjectMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ProjectMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetViewCount sets the "view_count" field.
func (m *ProjectMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *ProjectMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *ProjectMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *ProjectMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *ProjectMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetStarCount sets the "star_count" field.
func (m *ProjectMutation) SetStarCount(i int) {
	m.star_count = &i
	m.addstar_count = nil
}

// StarCount returns the value of the "star_count" field in the mutation.
func (m *ProjectMutation) StarCount() (r int, exists bool) {
	v := m.star_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStarCount returns the old "star_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStarCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarCount: %w", err)
	}
	return oldValue.StarCount, nil
}

// AddStarCount adds i to the "star_count" field.
func (m *ProjectMutation) AddStarCount(i int) {
	if m.addstar_count != nil {
		*m.addstar_count += i
	} else {
		m.addstar_count = &i
	}
}

// AddedStarCount returns the value that was added to the "star_count" field in this mutation.
func (m *ProjectMutation) AddedStarCount() (r int, exists bool) {
	v := m.addstar_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStarCount resets all changes to the "star_count" field.
func (m *ProjectMutation) ResetStarCount() {
	m.star_count = nil
	m.addstar_count = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *ProjectMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProjectMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProjectMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProjectMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProjectMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[project.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the ProjectTranslation entity by ids.
func (m *ProjectMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the ProjectTranslation entity.
func (m *ProjectMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the ProjectTranslation entity was cleared.
func (m *ProjectMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the ProjectTranslation entity by IDs.
func (m *ProjectMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the ProjectTranslation entity.
func (m *ProjectMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *ProjectMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *ProjectMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddTechnologyIDs adds the "technologies" edge to the ProjectTechnology entity by ids.
func (m *ProjectMutation) AddTechnologyIDs(ids ...uuid.UUID) {
	if m.technologies == nil {
		m.technologies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.technologies[ids[i]] = struct{}{}
	}
}

// ClearTechnologies clears the "technologies" edge to the ProjectTechnology entity.
func (m *ProjectMutation) ClearTechnologies() {
	m.clearedtechnologies = true
}

// TechnologiesCleared reports if the "technologies" edge to the ProjectTechnology entity was cleared.
func (m *ProjectMutation) TechnologiesCleared() bool {
	return m.clearedtechnologies
}

// RemoveTechnologyIDs removes the "technologies" edge to the ProjectTechnology entity by IDs.
func (m *ProjectMutation) RemoveTechnologyIDs(ids ...uuid.UUID) {
	if m.removedtechnologies == nil {
		m.removedtechnologies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.technologies, ids[i])
		m.removedtechnologies[ids[i]] = struct{}{}
	}
}

// RemovedTechnologies returns the removed IDs of the "technologies" edge to the ProjectTechnology entity.
func (m *ProjectMutation) RemovedTechnologiesIDs() (ids []uuid.UUID) {
	for id := range m.removedtechnologies {
		ids = append(ids, id)
	}
	return
}

// TechnologiesIDs returns the "technologies" edge IDs in the mutation.
func (m *ProjectMutation) TechnologiesIDs() (ids []uuid.UUID) {
	for id := range m.technologies {
		ids = append(ids, id)
	}
	return
}

// ResetTechnologies resets all changes to the "technologies" edge.
func (m *ProjectMutation) ResetTechnologies() {
	m.technologies = nil
	m.clearedtechnologies = false
	m.removedtechnologies = nil
}

// SetDetailsID sets the "details" edge to the ProjectDetail entity by id.
func (m *ProjectMutation) SetDetailsID(id uuid.UUID) {
	m.details = &id
}

// ClearDetails clears the "details" edge to the ProjectDetail entity.
func (m *ProjectMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the ProjectDetail entity was cleared.
func (m *ProjectMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// DetailsID returns the "details" edge ID in the mutation.
func (m *ProjectMutation) DetailsID() (id uuid.UUID, exists bool) {
	if m.details != nil {
		return *m.details, true
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DetailsID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) DetailsIDs() (ids []uuid.UUID) {
	if id := m.details; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *ProjectMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
}

// AddImageIDs adds the "images" edge to the ProjectImage entity by ids.
func (m *ProjectMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the ProjectImage entity.
func (m *ProjectMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the ProjectImage entity was cleared.
func (m *ProjectMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the ProjectImage entity by IDs.
func (m *ProjectMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the ProjectImage entity.
func (m *ProjectMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ProjectMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ProjectMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// AddSourceRelationshipIDs adds the "source_relationships" edge to the ProjectRelationship entity by ids.
func (m *ProjectMutation) AddSourceRelationshipIDs(ids ...uuid.UUID) {
	if m.source_relationships == nil {
		m.source_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.source_relationships[ids[i]] = struct{}{}
	}
}

// ClearSourceRelationships clears the "source_relationships" edge to the ProjectRelationship entity.
func (m *ProjectMutation) ClearSourceRelationships() {
	m.clearedsource_relationships = true
}

// SourceRelationshipsCleared reports if the "source_relationships" edge to the ProjectRelationship entity was cleared.
func (m *ProjectMutation) SourceRelationshipsCleared() bool {
	return m.clearedsource_relationships
}

// RemoveSourceRelationshipIDs removes the "source_relationships" edge to the ProjectRelationship entity by IDs.
func (m *ProjectMutation) RemoveSourceRelationshipIDs(ids ...uuid.UUID) {
	if m.removedsource_relationships == nil {
		m.removedsource_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.source_relationships, ids[i])
		m.removedsource_relationships[ids[i]] = struct{}{}
	}
}

// RemovedSourceRelationships returns the removed IDs of the "source_relationships" edge to the ProjectRelationship entity.
func (m *ProjectMutation) RemovedSourceRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedsource_relationships {
		ids = append(ids, id)
	}
	return
}

// SourceRelationshipsIDs returns the "source_relationships" edge IDs in the mutation.
func (m *ProjectMutation) SourceRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.source_relationships {
		ids = append(ids, id)
	}
	return
}

// ResetSourceRelationships resets all changes to the "source_relationships" edge.
func (m *ProjectMutation) ResetSourceRelationships() {
	m.source_relationships = nil
	m.clearedsource_relationships = false
	m.removedsource_relationships = nil
}

// AddTargetRelationshipIDs adds the "target_relationships" edge to the ProjectRelationship entity by ids.
func (m *ProjectMutation) AddTargetRelationshipIDs(ids ...uuid.UUID) {
	if m.target_relationships == nil {
		m.target_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.target_relationships[ids[i]] = struct{}{}
	}
}

// ClearTargetRelationships clears the "target_relationships" edge to the ProjectRelationship entity.
func (m *ProjectMutation) ClearTargetRelationships() {
	m.clearedtarget_relationships = true
}

// TargetRelationshipsCleared reports if the "target_relationships" edge to the ProjectRelationship entity was cleared.
func (m *ProjectMutation) TargetRelationshipsCleared() bool {
	return m.clearedtarget_relationships
}

// RemoveTargetRelationshipIDs removes the "target_relationships" edge to the ProjectRelationship entity by IDs.
func (m *ProjectMutation) RemoveTargetRelationshipIDs(ids ...uuid.UUID) {
	if m.removedtarget_relationships == nil {
		m.removedtarget_relationships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.target_relationships, ids[i])
		m.removedtarget_relationships[ids[i]] = struct{}{}
	}
}

// RemovedTargetRelationships returns the removed IDs of the "target_relationships" edge to the ProjectRelationship entity.
func (m *ProjectMutation) RemovedTargetRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.removedtarget_relationships {
		ids = append(ids, id)
	}
	return
}

// TargetRelationshipsIDs returns the "target_relationships" edge IDs in the mutation.
func (m *ProjectMutation) TargetRelationshipsIDs() (ids []uuid.UUID) {
	for id := range m.target_relationships {
		ids = append(ids, id)
	}
	return
}

// ResetTargetRelationships resets all changes to the "target_relationships" edge.
func (m *ProjectMutation) ResetTargetRelationships() {
	m.target_relationships = nil
	m.clearedtarget_relationships = false
	m.removedtarget_relationships = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.user != nil {
		fields = append(fields, project.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, project.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, project.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.project_type != nil {
		fields = append(fields, project.FieldProjectType)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	if m.github_url != nil {
		fields = append(fields, project.FieldGithubURL)
	}
	if m.demo_url != nil {
		fields = append(fields, project.FieldDemoURL)
	}
	if m.documentation_url != nil {
		fields = append(fields, project.FieldDocumentationURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, project.FieldThumbnailURL)
	}
	if m.is_featured != nil {
		fields = append(fields, project.FieldIsFeatured)
	}
	if m.is_public != nil {
		fields = append(fields, project.FieldIsPublic)
	}
	if m.view_count != nil {
		fields = append(fields, project.FieldViewCount)
	}
	if m.star_count != nil {
		fields = append(fields, project.FieldStarCount)
	}
	if m.sort_order != nil {
		fields = append(fields, project.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldUserID:
		return m.UserID()
	case project.FieldTitle:
		return m.Title()
	case project.FieldSlug:
		return m.Slug()
	case project.FieldDescription:
		return m.Description()
	case project.FieldProjectType:
		return m.ProjectType()
	case project.FieldStatus:
		return m.Status()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	case project.FieldGithubURL:
		return m.GithubURL()
	case project.FieldDemoURL:
		return m.DemoURL()
	case project.FieldDocumentationURL:
		return m.DocumentationURL()
	case project.FieldThumbnailURL:
		return m.ThumbnailURL()
	case project.FieldIsFeatured:
		return m.IsFeatured()
	case project.FieldIsPublic:
		return m.IsPublic()
	case project.FieldViewCount:
		return m.ViewCount()
	case project.FieldStarCount:
		return m.StarCount()
	case project.FieldSortOrder:
		return m.SortOrder()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldUserID:
		return m.OldUserID(ctx)
	case project.FieldTitle:
		return m.OldTitle(ctx)
	case project.FieldSlug:
		return m.OldSlug(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldProjectType:
		return m.OldProjectType(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	case project.FieldGithubURL:
		return m.OldGithubURL(ctx)
	case project.FieldDemoURL:
		return m.OldDemoURL(ctx)
	case project.FieldDocumentationURL:
		return m.OldDocumentationURL(ctx)
	case project.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case project.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case project.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case project.FieldViewCount:
		return m.OldViewCount(ctx)
	case project.FieldStarCount:
		return m.OldStarCount(ctx)
	case project.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case project.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case project.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case project.FieldGithubURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubURL(v)
		return nil
	case project.FieldDemoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDemoURL(v)
		return nil
	case project.FieldDocumentationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationURL(v)
		return nil
	case project.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case project.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case project.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case project.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case project.FieldStarCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarCount(v)
		return nil
	case project.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, project.FieldViewCount)
	}
	if m.addstar_count != nil {
		fields = append(fields, project.FieldStarCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, project.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldViewCount:
		return m.AddedViewCount()
	case project.FieldStarCount:
		return m.AddedStarCount()
	case project.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case project.FieldStarCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarCount(v)
		return nil
	case project.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldStartDate) {
		fields = append(fields, project.FieldStartDate)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	if m.FieldCleared(project.FieldGithubURL) {
		fields = append(fields, project.FieldGithubURL)
	}
	if m.FieldCleared(project.FieldDemoURL) {
		fields = append(fields, project.FieldDemoURL)
	}
	if m.FieldCleared(project.FieldDocumentationURL) {
		fields = append(fields, project.FieldDocumentationURL)
	}
	if m.FieldCleared(project.FieldThumbnailURL) {
		fields = append(fields, project.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldStartDate:
		m.ClearStartDate()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	case project.FieldGithubURL:
		m.ClearGithubURL()
		return nil
	case project.FieldDemoURL:
		m.ClearDemoURL()
		return nil
	case project.FieldDocumentationURL:
		m.ClearDocumentationURL()
		return nil
	case project.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldUserID:
		m.ResetUserID()
		return nil
	case project.FieldTitle:
		m.ResetTitle()
		return nil
	case project.FieldSlug:
		m.ResetSlug()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldProjectType:
		m.ResetProjectType()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	case project.FieldGithubURL:
		m.ResetGithubURL()
		return nil
	case project.FieldDemoURL:
		m.ResetDemoURL()
		return nil
	case project.FieldDocumentationURL:
		m.ResetDocumentationURL()
		return nil
	case project.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case project.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case project.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case project.FieldViewCount:
		m.ResetViewCount()
		return nil
	case project.FieldStarCount:
		m.ResetStarCount()
		return nil
	case project.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.user != nil {
		edges = append(edges, project.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, project.EdgeTranslations)
	}
	if m.technologies != nil {
		edges = append(edges, project.EdgeTechnologies)
	}
	if m.details != nil {
		edges = append(edges, project.EdgeDetails)
	}
	if m.images != nil {
		edges = append(edges, project.EdgeImages)
	}
	if m.source_relationships != nil {
		edges = append(edges, project.EdgeSourceRelationships)
	}
	if m.target_relationships != nil {
		edges = append(edges, project.EdgeTargetRelationships)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTechnologies:
		ids := make([]ent.Value, 0, len(m.technologies))
		for id := range m.technologies {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeDetails:
		if id := m.details; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSourceRelationships:
		ids := make([]ent.Value, 0, len(m.source_relationships))
		for id := range m.source_relationships {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTargetRelationships:
		ids := make([]ent.Value, 0, len(m.target_relationships))
		for id := range m.target_relationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedtranslations != nil {
		edges = append(edges, project.EdgeTranslations)
	}
	if m.removedtechnologies != nil {
		edges = append(edges, project.EdgeTechnologies)
	}
	if m.removedimages != nil {
		edges = append(edges, project.EdgeImages)
	}
	if m.removedsource_relationships != nil {
		edges = append(edges, project.EdgeSourceRelationships)
	}
	if m.removedtarget_relationships != nil {
		edges = append(edges, project.EdgeTargetRelationships)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTechnologies:
		ids := make([]ent.Value, 0, len(m.removedtechnologies))
		for id := range m.removedtechnologies {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSourceRelationships:
		ids := make([]ent.Value, 0, len(m.removedsource_relationships))
		for id := range m.removedsource_relationships {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTargetRelationships:
		ids := make([]ent.Value, 0, len(m.removedtarget_relationships))
		for id := range m.removedtarget_relationships {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareduser {
		edges = append(edges, project.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, project.EdgeTranslations)
	}
	if m.clearedtechnologies {
		edges = append(edges, project.EdgeTechnologies)
	}
	if m.cleareddetails {
		edges = append(edges, project.EdgeDetails)
	}
	if m.clearedimages {
		edges = append(edges, project.EdgeImages)
	}
	if m.clearedsource_relationships {
		edges = append(edges, project.EdgeSourceRelationships)
	}
	if m.clearedtarget_relationships {
		edges = append(edges, project.EdgeTargetRelationships)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUser:
		return m.cleareduser
	case project.EdgeTranslations:
		return m.clearedtranslations
	case project.EdgeTechnologies:
		return m.clearedtechnologies
	case project.EdgeDetails:
		return m.cleareddetails
	case project.EdgeImages:
		return m.clearedimages
	case project.EdgeSourceRelationships:
		return m.clearedsource_relationships
	case project.EdgeTargetRelationships:
		return m.clearedtarget_relationships
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ClearUser()
		return nil
	case project.EdgeDetails:
		m.ClearDetails()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ResetUser()
		return nil
	case project.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case project.EdgeTechnologies:
		m.ResetTechnologies()
		return nil
	case project.EdgeDetails:
		m.ResetDetails()
		return nil
	case project.EdgeImages:
		m.ResetImages()
		return nil
	case project.EdgeSourceRelationships:
		m.ResetSourceRelationships()
		return nil
	case project.EdgeTargetRelationships:
		m.ResetTargetRelationships()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectDetailMutation represents an operation that mutates the ProjectDetail nodes in the graph.
type ProjectDetailMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	detailed_description *string
	goals                *string
	challenges           *string
	solutions            *string
	lessons_learned      *string
	future_enhancements  *string
	license              *string
	version              *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	project              *uuid.UUID
	clearedproject       bool
	translations         map[uuid.UUID]struct{}
	removedtranslations  map[uuid.UUID]struct{}
	clearedtranslations  bool
	done                 bool
	oldValue             func(context.Context) (*ProjectDetail, error)
	predicates           []predicate.ProjectDetail
}

var _ ent.Mutation = (*ProjectDetailMutation)(nil)

// projectdetailOption allows management of the mutation configuration using functional options.
type projectdetailOption func(*ProjectDetailMutation)

// newProjectDetailMutation creates new mutation for the ProjectDetail entity.
func newProjectDetailMutation(c config, op Op, opts ...projectdetailOption) *ProjectDetailMutation {
	m := &ProjectDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectDetailID sets the ID field of the mutation.
func withProjectDetailID(id uuid.UUID) projectdetailOption {
	return func(m *ProjectDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectDetail
		)
		m.oldValue = func(ctx context.Context) (*ProjectDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectDetail sets the old ProjectDetail of the mutation.
func withProjectDetail(node *ProjectDetail) projectdetailOption {
	return func(m *ProjectDetailMutation) {
		m.oldValue = func(context.Context) (*ProjectDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectDetail entities.
func (m *ProjectDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectDetailMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectDetailMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectDetailMutation) ResetProjectID() {
	m.project = nil
}

// SetDetailedDescription sets the "detailed_description" field.
func (m *ProjectDetailMutation) SetDetailedDescription(s string) {
	m.detailed_description = &s
}

// DetailedDescription returns the value of the "detailed_description" field in the mutation.
func (m *ProjectDetailMutation) DetailedDescription() (r string, exists bool) {
	v := m.detailed_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailedDescription returns the old "detailed_description" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldDetailedDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailedDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailedDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailedDescription: %w", err)
	}
	return oldValue.DetailedDescription, nil
}

// ClearDetailedDescription clears the value of the "detailed_description" field.
func (m *ProjectDetailMutation) ClearDetailedDescription() {
	m.detailed_description = nil
	m.clearedFields[projectdetail.FieldDetailedDescription] = struct{}{}
}

// DetailedDescriptionCleared returns if the "detailed_description" field was cleared in this mutation.
func (m *ProjectDetailMutation) DetailedDescriptionCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldDetailedDescription]
	return ok
}

// ResetDetailedDescription resets all changes to the "detailed_description" field.
func (m *ProjectDetailMutation) ResetDetailedDescription() {
	m.detailed_description = nil
	delete(m.clearedFields, projectdetail.FieldDetailedDescription)
}

// SetGoals sets the "goals" field.
func (m *ProjectDetailMutation) SetGoals(s string) {
	m.goals = &s
}

// Goals returns the value of the "goals" field in the mutation.
func (m *ProjectDetailMutation) Goals() (r string, exists bool) {
	v := m.goals
	if v == nil {
		return
	}
	return *v, true
}

// OldGoals returns the old "goals" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldGoals(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoals: %w", err)
	}
	return oldValue.Goals, nil
}

// ClearGoals clears the value of the "goals" field.
func (m *ProjectDetailMutation) ClearGoals() {
	m.goals = nil
	m.clearedFields[projectdetail.FieldGoals] = struct{}{}
}

// GoalsCleared returns if the "goals" field was cleared in this mutation.
func (m *ProjectDetailMutation) GoalsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldGoals]
	return ok
}

// ResetGoals resets all changes to the "goals" field.
func (m *ProjectDetailMutation) ResetGoals() {
	m.goals = nil
	delete(m.clearedFields, projectdetail.FieldGoals)
}

// SetChallenges sets the "challenges" field.
func (m *ProjectDetailMutation) SetChallenges(s string) {
	m.challenges = &s
}

// Challenges returns the value of the "challenges" field in the mutation.
func (m *ProjectDetailMutation) Challenges() (r string, exists bool) {
	v := m.challenges
	if v == nil {
		return
	}
	return *v, true
}

// OldChallenges returns the old "challenges" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldChallenges(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallenges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallenges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallenges: %w", err)
	}
	return oldValue.Challenges, nil
}

// ClearChallenges clears the value of the "challenges" field.
func (m *ProjectDetailMutation) ClearChallenges() {
	m.challenges = nil
	m.clearedFields[projectdetail.FieldChallenges] = struct{}{}
}

// ChallengesCleared returns if the "challenges" field was cleared in this mutation.
func (m *ProjectDetailMutation) ChallengesCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldChallenges]
	return ok
}

// ResetChallenges resets all changes to the "challenges" field.
func (m *ProjectDetailMutation) ResetChallenges() {
	m.challenges = nil
	delete(m.clearedFields, projectdetail.FieldChallenges)
}

// SetSolutions sets the "solutions" field.
func (m *ProjectDetailMutation) SetSolutions(s string) {
	m.solutions = &s
}

// Solutions returns the value of the "solutions" field in the mutation.
func (m *ProjectDetailMutation) Solutions() (r string, exists bool) {
	v := m.solutions
	if v == nil {
		return
	}
	return *v, true
}

// OldSolutions returns the old "solutions" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldSolutions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSolutions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSolutions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSolutions: %w", err)
	}
	return oldValue.Solutions, nil
}

// ClearSolutions clears the value of the "solutions" field.
func (m *ProjectDetailMutation) ClearSolutions() {
	m.solutions = nil
	m.clearedFields[projectdetail.FieldSolutions] = struct{}{}
}

// SolutionsCleared returns if the "solutions" field was cleared in this mutation.
func (m *ProjectDetailMutation) SolutionsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldSolutions]
	return ok
}

// ResetSolutions resets all changes to the "solutions" field.
func (m *ProjectDetailMutation) ResetSolutions() {
	m.solutions = nil
	delete(m.clearedFields, projectdetail.FieldSolutions)
}

// SetLessonsLearned sets the "lessons_learned" field.
func (m *ProjectDetailMutation) SetLessonsLearned(s string) {
	m.lessons_learned = &s
}

// LessonsLearned returns the value of the "lessons_learned" field in the mutation.
func (m *ProjectDetailMutation) LessonsLearned() (r string, exists bool) {
	v := m.lessons_learned
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonsLearned returns the old "lessons_learned" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldLessonsLearned(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonsLearned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonsLearned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonsLearned: %w", err)
	}
	return oldValue.LessonsLearned, nil
}

// ClearLessonsLearned clears the value of the "lessons_learned" field.
func (m *ProjectDetailMutation) ClearLessonsLearned() {
	m.lessons_learned = nil
	m.clearedFields[projectdetail.FieldLessonsLearned] = struct{}{}
}

// LessonsLearnedCleared returns if the "lessons_learned" field was cleared in this mutation.
func (m *ProjectDetailMutation) LessonsLearnedCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldLessonsLearned]
	return ok
}

// ResetLessonsLearned resets all changes to the "lessons_learned" field.
func (m *ProjectDetailMutation) ResetLessonsLearned() {
	m.lessons_learned = nil
	delete(m.clearedFields, projectdetail.FieldLessonsLearned)
}

// SetFutureEnhancements sets the "future_enhancements" field.
func (m *ProjectDetailMutation) SetFutureEnhancements(s string) {
	m.future_enhancements = &s
}

// FutureEnhancements returns the value of the "future_enhancements" field in the mutation.
func (m *ProjectDetailMutation) FutureEnhancements() (r string, exists bool) {
	v := m.future_enhancements
	if v == nil {
		return
	}
	return *v, true
}

// OldFutureEnhancements returns the old "future_enhancements" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldFutureEnhancements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFutureEnhancements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFutureEnhancements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFutureEnhancements: %w", err)
	}
	return oldValue.FutureEnhancements, nil
}

// ClearFutureEnhancements clears the value of the "future_enhancements" field.
func (m *ProjectDetailMutation) ClearFutureEnhancements() {
	m.future_enhancements = nil
	m.clearedFields[projectdetail.FieldFutureEnhancements] = struct{}{}
}

// FutureEnhancementsCleared returns if the "future_enhancements" field was cleared in this mutation.
func (m *ProjectDetailMutation) FutureEnhancementsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldFutureEnhancements]
	return ok
}

// ResetFutureEnhancements resets all changes to the "future_enhancements" field.
func (m *ProjectDetailMutation) ResetFutureEnhancements() {
	m.future_enhancements = nil
	delete(m.clearedFields, projectdetail.FieldFutureEnhancements)
}

// SetLicense sets the "license" field.
func (m *ProjectDetailMutation) SetLicense(s string) {
	m.license = &s
}

// License returns the value of the "license" field in the mutation.
func (m *ProjectDetailMutation) License() (r string, exists bool) {
	v := m.license
	if v == nil {
		return
	}
	return *v, true
}

// OldLicense returns the old "license" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldLicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicense is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicense: %w", err)
	}
	return oldValue.License, nil
}

// ClearLicense clears the value of the "license" field.
func (m *ProjectDetailMutation) ClearLicense() {
	m.license = nil
	m.clearedFields[projectdetail.FieldLicense] = struct{}{}
}

// LicenseCleared returns if the "license" field was cleared in this mutation.
func (m *ProjectDetailMutation) LicenseCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldLicense]
	return ok
}

// ResetLicense resets all changes to the "license" field.
func (m *ProjectDetailMutation) ResetLicense() {
	m.license = nil
	delete(m.clearedFields, projectdetail.FieldLicense)
}

// SetVersion sets the "version" field.
func (m *ProjectDetailMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProjectDetailMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ProjectDetailMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[projectdetail.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProjectDetailMutation) VersionCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProjectDetailMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, projectdetail.FieldVersion)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectDetailMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[projectdetail.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectDetailMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectDetailMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectDetailMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddTranslationIDs adds the "translations" edge to the ProjectDetailTranslation entity by ids.
func (m *ProjectDetailMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the ProjectDetailTranslation entity.
func (m *ProjectDetailMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the ProjectDetailTranslation entity was cleared.
func (m *ProjectDetailMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the ProjectDetailTranslation entity by IDs.
func (m *ProjectDetailMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the ProjectDetailTranslation entity.
func (m *ProjectDetailMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *ProjectDetailMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *ProjectDetailMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the ProjectDetailMutation builder.
func (m *ProjectDetailMutation) Where(ps ...predicate.ProjectDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectDetail).
func (m *ProjectDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectDetailMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.project != nil {
		fields = append(fields, projectdetail.FieldProjectID)
	}
	if m.detailed_description != nil {
		fields = append(fields, projectdetail.FieldDetailedDescription)
	}
	if m.goals != nil {
		fields = append(fields, projectdetail.FieldGoals)
	}
	if m.challenges != nil {
		fields = append(fields, projectdetail.FieldChallenges)
	}
	if m.solutions != nil {
		fields = append(fields, projectdetail.FieldSolutions)
	}
	if m.lessons_learned != nil {
		fields = append(fields, projectdetail.FieldLessonsLearned)
	}
	if m.future_enhancements != nil {
		fields = append(fields, projectdetail.FieldFutureEnhancements)
	}
	if m.license != nil {
		fields = append(fields, projectdetail.FieldLicense)
	}
	if m.version != nil {
		fields = append(fields, projectdetail.FieldVersion)
	}
	if m.created_at != nil {
		fields = append(fields, projectdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectdetail.FieldProjectID:
		return m.ProjectID()
	case projectdetail.FieldDetailedDescription:
		return m.DetailedDescription()
	case projectdetail.FieldGoals:
		return m.Goals()
	case projectdetail.FieldChallenges:
		return m.Challenges()
	case projectdetail.FieldSolutions:
		return m.Solutions()
	case projectdetail.FieldLessonsLearned:
		return m.LessonsLearned()
	case projectdetail.FieldFutureEnhancements:
		return m.FutureEnhancements()
	case projectdetail.FieldLicense:
		return m.License()
	case projectdetail.FieldVersion:
		return m.Version()
	case projectdetail.FieldCreatedAt:
		return m.CreatedAt()
	case projectdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectdetail.FieldProjectID:
		return m.OldProjectID(ctx)
	case projectdetail.FieldDetailedDescription:
		return m.OldDetailedDescription(ctx)
	case projectdetail.FieldGoals:
		return m.OldGoals(ctx)
	case projectdetail.FieldChallenges:
		return m.OldChallenges(ctx)
	case projectdetail.FieldSolutions:
		return m.OldSolutions(ctx)
	case projectdetail.FieldLessonsLearned:
		return m.OldLessonsLearned(ctx)
	case projectdetail.FieldFutureEnhancements:
		return m.OldFutureEnhancements(ctx)
	case projectdetail.FieldLicense:
		return m.OldLicense(ctx)
	case projectdetail.FieldVersion:
		return m.OldVersion(ctx)
	case projectdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectdetail.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projectdetail.FieldDetailedDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailedDescription(v)
		return nil
	case projectdetail.FieldGoals:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoals(v)
		return nil
	case projectdetail.FieldChallenges:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallenges(v)
		return nil
	case projectdetail.FieldSolutions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSolutions(v)
		return nil
	case projectdetail.FieldLessonsLearned:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonsLearned(v)
		return nil
	case projectdetail.FieldFutureEnhancements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFutureEnhancements(v)
		return nil
	case projectdetail.FieldLicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicense(v)
		return nil
	case projectdetail.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case projectdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectDetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectDetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectdetail.FieldDetailedDescription) {
		fields = append(fields, projectdetail.FieldDetailedDescription)
	}
	if m.FieldCleared(projectdetail.FieldGoals) {
		fields = append(fields, projectdetail.FieldGoals)
	}
	if m.FieldCleared(projectdetail.FieldChallenges) {
		fields = append(fields, projectdetail.FieldChallenges)
	}
	if m.FieldCleared(projectdetail.FieldSolutions) {
		fields = append(fields, projectdetail.FieldSolutions)
	}
	if m.FieldCleared(projectdetail.FieldLessonsLearned) {
		fields = append(fields, projectdetail.FieldLessonsLearned)
	}
	if m.FieldCleared(projectdetail.FieldFutureEnhancements) {
		fields = append(fields, projectdetail.FieldFutureEnhancements)
	}
	if m.FieldCleared(projectdetail.FieldLicense) {
		fields = append(fields, projectdetail.FieldLicense)
	}
	if m.FieldCleared(projectdetail.FieldVersion) {
		fields = append(fields, projectdetail.FieldVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectDetailMutation) ClearField(name string) error {
	switch name {
	case projectdetail.FieldDetailedDescription:
		m.ClearDetailedDescription()
		return nil
	case projectdetail.FieldGoals:
		m.ClearGoals()
		return nil
	case projectdetail.FieldChallenges:
		m.ClearChallenges()
		return nil
	case projectdetail.FieldSolutions:
		m.ClearSolutions()
		return nil
	case projectdetail.FieldLessonsLearned:
		m.ClearLessonsLearned()
		return nil
	case projectdetail.FieldFutureEnhancements:
		m.ClearFutureEnhancements()
		return nil
	case projectdetail.FieldLicense:
		m.ClearLicense()
		return nil
	case projectdetail.FieldVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectDetailMutation) ResetField(name string) error {
	switch name {
	case projectdetail.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projectdetail.FieldDetailedDescription:
		m.ResetDetailedDescription()
		return nil
	case projectdetail.FieldGoals:
		m.ResetGoals()
		return nil
	case projectdetail.FieldChallenges:
		m.ResetChallenges()
		return nil
	case projectdetail.FieldSolutions:
		m.ResetSolutions()
		return nil
	case projectdetail.FieldLessonsLearned:
		m.ResetLessonsLearned()
		return nil
	case projectdetail.FieldFutureEnhancements:
		m.ResetFutureEnhancements()
		return nil
	case projectdetail.FieldLicense:
		m.ResetLicense()
		return nil
	case projectdetail.FieldVersion:
		m.ResetVersion()
		return nil
	case projectdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projectdetail.EdgeProject)
	}
	if m.translations != nil {
		edges = append(edges, projectdetail.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectdetail.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectdetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, projectdetail.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectdetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projectdetail.EdgeProject)
	}
	if m.clearedtranslations {
		edges = append(edges, projectdetail.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case projectdetail.EdgeProject:
		return m.clearedproject
	case projectdetail.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectDetailMutation) ClearEdge(name string) error {
	switch name {
	case projectdetail.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectDetailMutation) ResetEdge(name string) error {
	switch name {
	case projectdetail.EdgeProject:
		m.ResetProject()
		return nil
	case projectdetail.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail edge %s", name)
}

// ProjectDetailTranslationMutation represents an operation that mutates the ProjectDetailTranslation nodes in the graph.
type ProjectDetailTranslationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	detailed_description  *string
	goals                 *string
	challenges            *string
	solutions             *string
	lessons_learned       *string
	future_enhancements   *string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	project_detail        *uuid.UUID
	clearedproject_detail bool
	language              *string
	clearedlanguage       bool
	done                  bool
	oldValue              func(context.Context) (*ProjectDetailTranslation, error)
	predicates            []predicate.ProjectDetailTranslation
}

var _ ent.Mutation = (*ProjectDetailTranslationMutation)(nil)

// projectdetailtranslationOption allows management of the mutation configuration using functional options.
type projectdetailtranslationOption func(*ProjectDetailTranslationMutation)

// newProjectDetailTranslationMutation creates new mutation for the ProjectDetailTranslation entity.
func newProjectDetailTranslationMutation(c config, op Op, opts ...projectdetailtranslationOption) *ProjectDetailTranslationMutation {
	m := &ProjectDetailTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectDetailTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectDetailTranslationID sets the ID field of the mutation.
func withProjectDetailTranslationID(id uuid.UUID) projectdetailtranslationOption {
	return func(m *ProjectDetailTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectDetailTranslation
		)
		m.oldValue = func(ctx context.Context) (*ProjectDetailTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectDetailTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectDetailTranslation sets the old ProjectDetailTranslation of the mutation.
func withProjectDetailTranslation(node *ProjectDetailTranslation) projectdetailtranslationOption {
	return func(m *ProjectDetailTranslationMutation) {
		m.oldValue = func(context.Context) (*ProjectDetailTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectDetailTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectDetailTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectDetailTranslation entities.
func (m *ProjectDetailTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectDetailTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectDetailTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectDetailTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectDetailID sets the "project_detail_id" field.
func (m *ProjectDetailTranslationMutation) SetProjectDetailID(u uuid.UUID) {
	m.project_detail = &u
}

// ProjectDetailID returns the value of the "project_detail_id" field in the mutation.
func (m *ProjectDetailTranslationMutation) ProjectDetailID() (r uuid.UUID, exists bool) {
	v := m.project_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectDetailID returns the old "project_detail_id" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldProjectDetailID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectDetailID: %w", err)
	}
	return oldValue.ProjectDetailID, nil
}

// ResetProjectDetailID resets all changes to the "project_detail_id" field.
func (m *ProjectDetailTranslationMutation) ResetProjectDetailID() {
	m.project_detail = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *ProjectDetailTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *ProjectDetailTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *ProjectDetailTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetDetailedDescription sets the "detailed_description" field.
func (m *ProjectDetailTranslationMutation) SetDetailedDescription(s string) {
	m.detailed_description = &s
}

// DetailedDescription returns the value of the "detailed_description" field in the mutation.
func (m *ProjectDetailTranslationMutation) DetailedDescription() (r string, exists bool) {
	v := m.detailed_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailedDescription returns the old "detailed_description" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldDetailedDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailedDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailedDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailedDescription: %w", err)
	}
	return oldValue.DetailedDescription, nil
}

// ClearDetailedDescription clears the value of the "detailed_description" field.
func (m *ProjectDetailTranslationMutation) ClearDetailedDescription() {
	m.detailed_description = nil
	m.clearedFields[projectdetailtranslation.FieldDetailedDescription] = struct{}{}
}

// DetailedDescriptionCleared returns if the "detailed_description" field was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) DetailedDescriptionCleared() bool {
	_, ok := m.clearedFields[projectdetailtranslation.FieldDetailedDescription]
	return ok
}

// ResetDetailedDescription resets all changes to the "detailed_description" field.
func (m *ProjectDetailTranslationMutation) ResetDetailedDescription() {
	m.detailed_description = nil
	delete(m.clearedFields, projectdetailtranslation.FieldDetailedDescription)
}

// SetGoals sets the "goals" field.
func (m *ProjectDetailTranslationMutation) SetGoals(s string) {
	m.goals = &s
}

// Goals returns the value of the "goals" field in the mutation.
func (m *ProjectDetailTranslationMutation) Goals() (r string, exists bool) {
	v := m.goals
	if v == nil {
		return
	}
	return *v, true
}

// OldGoals returns the old "goals" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldGoals(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoals: %w", err)
	}
	return oldValue.Goals, nil
}

// ClearGoals clears the value of the "goals" field.
func (m *ProjectDetailTranslationMutation) ClearGoals() {
	m.goals = nil
	m.clearedFields[projectdetailtranslation.FieldGoals] = struct{}{}
}

// GoalsCleared returns if the "goals" field was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) GoalsCleared() bool {
	_, ok := m.clearedFields[projectdetailtranslation.FieldGoals]
	return ok
}

// ResetGoals resets all changes to the "goals" field.
func (m *ProjectDetailTranslationMutation) ResetGoals() {
	m.goals = nil
	delete(m.clearedFields, projectdetailtranslation.FieldGoals)
}

// SetChallenges sets the "challenges" field.
func (m *ProjectDetailTranslationMutation) SetChallenges(s string) {
	m.challenges = &s
}

// Challenges returns the value of the "challenges" field in the mutation.
func (m *ProjectDetailTranslationMutation) Challenges() (r string, exists bool) {
	v := m.challenges
	if v == nil {
		return
	}
	return *v, true
}

// OldChallenges returns the old "challenges" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldChallenges(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallenges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallenges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallenges: %w", err)
	}
	return oldValue.Challenges, nil
}

// ClearChallenges clears the value of the "challenges" field.
func (m *ProjectDetailTranslationMutation) ClearChallenges() {
	m.challenges = nil
	m.clearedFields[projectdetailtranslation.FieldChallenges] = struct{}{}
}

// ChallengesCleared returns if the "challenges" field was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) ChallengesCleared() bool {
	_, ok := m.clearedFields[projectdetailtranslation.FieldChallenges]
	return ok
}

// ResetChallenges resets all changes to the "challenges" field.
func (m *ProjectDetailTranslationMutation) ResetChallenges() {
	m.challenges = nil
	delete(m.clearedFields, projectdetailtranslation.FieldChallenges)
}

// SetSolutions sets the "solutions" field.
func (m *ProjectDetailTranslationMutation) SetSolutions(s string) {
	m.solutions = &s
}

// Solutions returns the value of the "solutions" field in the mutation.
func (m *ProjectDetailTranslationMutation) Solutions() (r string, exists bool) {
	v := m.solutions
	if v == nil {
		return
	}
	return *v, true
}

// OldSolutions returns the old "solutions" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldSolutions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSolutions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSolutions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSolutions: %w", err)
	}
	return oldValue.Solutions, nil
}

// ClearSolutions clears the value of the "solutions" field.
func (m *ProjectDetailTranslationMutation) ClearSolutions() {
	m.solutions = nil
	m.clearedFields[projectdetailtranslation.FieldSolutions] = struct{}{}
}

// SolutionsCleared returns if the "solutions" field was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) SolutionsCleared() bool {
	_, ok := m.clearedFields[projectdetailtranslation.FieldSolutions]
	return ok
}

// ResetSolutions resets all changes to the "solutions" field.
func (m *ProjectDetailTranslationMutation) ResetSolutions() {
	m.solutions = nil
	delete(m.clearedFields, projectdetailtranslation.FieldSolutions)
}

// SetLessonsLearned sets the "lessons_learned" field.
func (m *ProjectDetailTranslationMutation) SetLessonsLearned(s string) {
	m.lessons_learned = &s
}

// LessonsLearned returns the value of the "lessons_learned" field in the mutation.
func (m *ProjectDetailTranslationMutation) LessonsLearned() (r string, exists bool) {
	v := m.lessons_learned
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonsLearned returns the old "lessons_learned" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldLessonsLearned(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonsLearned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonsLearned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonsLearned: %w", err)
	}
	return oldValue.LessonsLearned, nil
}

// ClearLessonsLearned clears the value of the "lessons_learned" field.
func (m *ProjectDetailTranslationMutation) ClearLessonsLearned() {
	m.lessons_learned = nil
	m.clearedFields[projectdetailtranslation.FieldLessonsLearned] = struct{}{}
}

// LessonsLearnedCleared returns if the "lessons_learned" field was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) LessonsLearnedCleared() bool {
	_, ok := m.clearedFields[projectdetailtranslation.FieldLessonsLearned]
	return ok
}

// ResetLessonsLearned resets all changes to the "lessons_learned" field.
func (m *ProjectDetailTranslationMutation) ResetLessonsLearned() {
	m.lessons_learned = nil
	delete(m.clearedFields, projectdetailtranslation.FieldLessonsLearned)
}

// SetFutureEnhancements sets the "future_enhancements" field.
func (m *ProjectDetailTranslationMutation) SetFutureEnhancements(s string) {
	m.future_enhancements = &s
}

// FutureEnhancements returns the value of the "future_enhancements" field in the mutation.
func (m *ProjectDetailTranslationMutation) FutureEnhancements() (r string, exists bool) {
	v := m.future_enhancements
	if v == nil {
		return
	}
	return *v, true
}

// OldFutureEnhancements returns the old "future_enhancements" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldFutureEnhancements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFutureEnhancements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFutureEnhancements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFutureEnhancements: %w", err)
	}
	return oldValue.FutureEnhancements, nil
}

// ClearFutureEnhancements clears the value of the "future_enhancements" field.
func (m *ProjectDetailTranslationMutation) ClearFutureEnhancements() {
	m.future_enhancements = nil
	m.clearedFields[projectdetailtranslation.FieldFutureEnhancements] = struct{}{}
}

// FutureEnhancementsCleared returns if the "future_enhancements" field was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) FutureEnhancementsCleared() bool {
	_, ok := m.clearedFields[projectdetailtranslation.FieldFutureEnhancements]
	return ok
}

// ResetFutureEnhancements resets all changes to the "future_enhancements" field.
func (m *ProjectDetailTranslationMutation) ResetFutureEnhancements() {
	m.future_enhancements = nil
	delete(m.clearedFields, projectdetailtranslation.FieldFutureEnhancements)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectDetailTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectDetailTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectDetailTranslation entity.
// If the ProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectDetailTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearProjectDetail clears the "project_detail" edge to the ProjectDetail entity.
func (m *ProjectDetailTranslationMutation) ClearProjectDetail() {
	m.clearedproject_detail = true
	m.clearedFields[projectdetailtranslation.FieldProjectDetailID] = struct{}{}
}

// ProjectDetailCleared reports if the "project_detail" edge to the ProjectDetail entity was cleared.
func (m *ProjectDetailTranslationMutation) ProjectDetailCleared() bool {
	return m.clearedproject_detail
}

// ProjectDetailIDs returns the "project_detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectDetailID instead. It exists only for internal usage by the builders.
func (m *ProjectDetailTranslationMutation) ProjectDetailIDs() (ids []uuid.UUID) {
	if id := m.project_detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectDetail resets all changes to the "project_detail" edge.
func (m *ProjectDetailTranslationMutation) ResetProjectDetail() {
	m.project_detail = nil
	m.clearedproject_detail = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *ProjectDetailTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *ProjectDetailTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[projectdetailtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *ProjectDetailTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *ProjectDetailTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *ProjectDetailTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *ProjectDetailTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the ProjectDetailTranslationMutation builder.
func (m *ProjectDetailTranslationMutation) Where(ps ...predicate.ProjectDetailTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectDetailTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectDetailTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectDetailTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectDetailTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectDetailTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectDetailTranslation).
func (m *ProjectDetailTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectDetailTranslationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.project_detail != nil {
		fields = append(fields, projectdetailtranslation.FieldProjectDetailID)
	}
	if m.language != nil {
		fields = append(fields, projectdetailtranslation.FieldLanguageCode)
	}
	if m.detailed_description != nil {
		fields = append(fields, projectdetailtranslation.FieldDetailedDescription)
	}
	if m.goals != nil {
		fields = append(fields, projectdetailtranslation.FieldGoals)
	}
	if m.challenges != nil {
		fields = append(fields, projectdetailtranslation.FieldChallenges)
	}
	if m.solutions != nil {
		fields = append(fields, projectdetailtranslation.FieldSolutions)
	}
	if m.lessons_learned != nil {
		fields = append(fields, projectdetailtranslation.FieldLessonsLearned)
	}
	if m.future_enhancements != nil {
		fields = append(fields, projectdetailtranslation.FieldFutureEnhancements)
	}
	if m.created_at != nil {
		fields = append(fields, projectdetailtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectDetailTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectdetailtranslation.FieldProjectDetailID:
		return m.ProjectDetailID()
	case projectdetailtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case projectdetailtranslation.FieldDetailedDescription:
		return m.DetailedDescription()
	case projectdetailtranslation.FieldGoals:
		return m.Goals()
	case projectdetailtranslation.FieldChallenges:
		return m.Challenges()
	case projectdetailtranslation.FieldSolutions:
		return m.Solutions()
	case projectdetailtranslation.FieldLessonsLearned:
		return m.LessonsLearned()
	case projectdetailtranslation.FieldFutureEnhancements:
		return m.FutureEnhancements()
	case projectdetailtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectDetailTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectdetailtranslation.FieldProjectDetailID:
		return m.OldProjectDetailID(ctx)
	case projectdetailtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case projectdetailtranslation.FieldDetailedDescription:
		return m.OldDetailedDescription(ctx)
	case projectdetailtranslation.FieldGoals:
		return m.OldGoals(ctx)
	case projectdetailtranslation.FieldChallenges:
		return m.OldChallenges(ctx)
	case projectdetailtranslation.FieldSolutions:
		return m.OldSolutions(ctx)
	case projectdetailtranslation.FieldLessonsLearned:
		return m.OldLessonsLearned(ctx)
	case projectdetailtranslation.FieldFutureEnhancements:
		return m.OldFutureEnhancements(ctx)
	case projectdetailtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectDetailTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectDetailTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectdetailtranslation.FieldProjectDetailID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectDetailID(v)
		return nil
	case projectdetailtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case projectdetailtranslation.FieldDetailedDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailedDescription(v)
		return nil
	case projectdetailtranslation.FieldGoals:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoals(v)
		return nil
	case projectdetailtranslation.FieldChallenges:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallenges(v)
		return nil
	case projectdetailtranslation.FieldSolutions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSolutions(v)
		return nil
	case projectdetailtranslation.FieldLessonsLearned:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonsLearned(v)
		return nil
	case projectdetailtranslation.FieldFutureEnhancements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFutureEnhancements(v)
		return nil
	case projectdetailtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectDetailTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectDetailTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectDetailTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectDetailTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectDetailTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectDetailTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectdetailtranslation.FieldDetailedDescription) {
		fields = append(fields, projectdetailtranslation.FieldDetailedDescription)
	}
	if m.FieldCleared(projectdetailtranslation.FieldGoals) {
		fields = append(fields, projectdetailtranslation.FieldGoals)
	}
	if m.FieldCleared(projectdetailtranslation.FieldChallenges) {
		fields = append(fields, projectdetailtranslation.FieldChallenges)
	}
	if m.FieldCleared(projectdetailtranslation.FieldSolutions) {
		fields = append(fields, projectdetailtranslation.FieldSolutions)
	}
	if m.FieldCleared(projectdetailtranslation.FieldLessonsLearned) {
		fields = append(fields, projectdetailtranslation.FieldLessonsLearned)
	}
	if m.FieldCleared(projectdetailtranslation.FieldFutureEnhancements) {
		fields = append(fields, projectdetailtranslation.FieldFutureEnhancements)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectDetailTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectDetailTranslationMutation) ClearField(name string) error {
	switch name {
	case projectdetailtranslation.FieldDetailedDescription:
		m.ClearDetailedDescription()
		return nil
	case projectdetailtranslation.FieldGoals:
		m.ClearGoals()
		return nil
	case projectdetailtranslation.FieldChallenges:
		m.ClearChallenges()
		return nil
	case projectdetailtranslation.FieldSolutions:
		m.ClearSolutions()
		return nil
	case projectdetailtranslation.FieldLessonsLearned:
		m.ClearLessonsLearned()
		return nil
	case projectdetailtranslation.FieldFutureEnhancements:
		m.ClearFutureEnhancements()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetailTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectDetailTranslationMutation) ResetField(name string) error {
	switch name {
	case projectdetailtranslation.FieldProjectDetailID:
		m.ResetProjectDetailID()
		return nil
	case projectdetailtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case projectdetailtranslation.FieldDetailedDescription:
		m.ResetDetailedDescription()
		return nil
	case projectdetailtranslation.FieldGoals:
		m.ResetGoals()
		return nil
	case projectdetailtranslation.FieldChallenges:
		m.ResetChallenges()
		return nil
	case projectdetailtranslation.FieldSolutions:
		m.ResetSolutions()
		return nil
	case projectdetailtranslation.FieldLessonsLearned:
		m.ResetLessonsLearned()
		return nil
	case projectdetailtranslation.FieldFutureEnhancements:
		m.ResetFutureEnhancements()
		return nil
	case projectdetailtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetailTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectDetailTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project_detail != nil {
		edges = append(edges, projectdetailtranslation.EdgeProjectDetail)
	}
	if m.language != nil {
		edges = append(edges, projectdetailtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectDetailTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectdetailtranslation.EdgeProjectDetail:
		if id := m.project_detail; id != nil {
			return []ent.Value{*id}
		}
	case projectdetailtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectDetailTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectDetailTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectDetailTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject_detail {
		edges = append(edges, projectdetailtranslation.EdgeProjectDetail)
	}
	if m.clearedlanguage {
		edges = append(edges, projectdetailtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectDetailTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case projectdetailtranslation.EdgeProjectDetail:
		return m.clearedproject_detail
	case projectdetailtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectDetailTranslationMutation) ClearEdge(name string) error {
	switch name {
	case projectdetailtranslation.EdgeProjectDetail:
		m.ClearProjectDetail()
		return nil
	case projectdetailtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetailTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectDetailTranslationMutation) ResetEdge(name string) error {
	switch name {
	case projectdetailtranslation.EdgeProjectDetail:
		m.ResetProjectDetail()
		return nil
	case projectdetailtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetailTranslation edge %s", name)
}

// ProjectImageMutation represents an operation that mutates the ProjectImage nodes in the graph.
type ProjectImageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	image_url           *string
	alt_text            *string
	caption             *string
	image_type          *string
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	project             *uuid.UUID
	clearedproject      bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	done                bool
	oldValue            func(context.Context) (*ProjectImage, error)
	predicates          []predicate.ProjectImage
}

var _ ent.Mutation = (*ProjectImageMutation)(nil)

// projectimageOption allows management of the mutation configuration using functional options.
type projectimageOption func(*ProjectImageMutation)

// newProjectImageMutation creates new mutation for the ProjectImage entity.
func newProjectImageMutation(c config, op Op, opts ...projectimageOption) *ProjectImageMutation {
	m := &ProjectImageMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectImageID sets the ID field of the mutation.
func withProjectImageID(id uuid.UUID) projectimageOption {
	return func(m *ProjectImageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectImage
		)
		m.oldValue = func(ctx context.Context) (*ProjectImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectImage sets the old ProjectImage of the mutation.
func withProjectImage(node *ProjectImage) projectimageOption {
	return func(m *ProjectImageMutation) {
		m.oldValue = func(context.Context) (*ProjectImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectImage entities.
func (m *ProjectImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectImageMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectImageMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectImageMutation) ResetProjectID() {
	m.project = nil
}

// SetImageURL sets the "image_url" field.
func (m *ProjectImageMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ProjectImageMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ProjectImageMutation) ResetImageURL() {
	m.image_url = nil
}

// SetAltText sets the "alt_text" field.
func (m *ProjectImageMutation) SetAltText(s string) {
	m.alt_text = &s
}

// AltText returns the value of the "alt_text" field in the mutation.
func (m *ProjectImageMutation) AltText() (r string, exists bool) {
	v := m.alt_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAltText returns the old "alt_text" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldAltText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltText: %w", err)
	}
	return oldValue.AltText, nil
}

// ClearAltText clears the value of the "alt_text" field.
func (m *ProjectImageMutation) ClearAltText() {
	m.alt_text = nil
	m.clearedFields[projectimage.FieldAltText] = struct{}{}
}

// AltTextCleared returns if the "alt_text" field was cleared in this mutation.
func (m *ProjectImageMutation) AltTextCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldAltText]
	return ok
}

// ResetAltText resets all changes to the "alt_text" field.
func (m *ProjectImageMutation) ResetAltText() {
	m.alt_text = nil
	delete(m.clearedFields, projectimage.FieldAltText)
}

// SetCaption sets the "caption" field.
func (m *ProjectImageMutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *ProjectImageMutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldCaption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ClearCaption clears the value of the "caption" field.
func (m *ProjectImageMutation) ClearCaption() {
	m.caption = nil
	m.clearedFields[projectimage.FieldCaption] = struct{}{}
}

// CaptionCleared returns if the "caption" field was cleared in this mutation.
func (m *ProjectImageMutation) CaptionCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldCaption]
	return ok
}

// ResetCaption resets all changes to the "caption" field.
func (m *ProjectImageMutation) ResetCaption() {
	m.caption = nil
	delete(m.clearedFields, projectimage.FieldCaption)
}

// SetImageType sets the "image_type" field.
func (m *ProjectImageMutation) SetImageType(s string) {
	m.image_type = &s
}

// ImageType returns the value of the "image_type" field in the mutation.
func (m *ProjectImageMutation) ImageType() (r string, exists bool) {
	v := m.image_type
	if v == nil {
		return
	}
	return *v, true
}

// OldImageType returns the old "image_type" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldImageType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageType: %w", err)
	}
	return oldValue.ImageType, nil
}

// ClearImageType clears the value of the "image_type" field.
func (m *ProjectImageMutation) ClearImageType() {
	m.image_type = nil
	m.clearedFields[projectimage.FieldImageType] = struct{}{}
}

// ImageTypeCleared returns if the "image_type" field was cleared in this mutation.
func (m *ProjectImageMutation) ImageTypeCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldImageType]
	return ok
}

// ResetImageType resets all changes to the "image_type" field.
func (m *ProjectImageMutation) ResetImageType() {
	m.image_type = nil
	delete(m.clearedFields, projectimage.FieldImageType)
}

// SetSortOrder sets the "sort_order" field.
func (m *ProjectImageMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProjectImageMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProjectImageMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProjectImageMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProjectImageMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectImageMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[projectimage.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectImageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectImageMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectImageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddTranslationIDs adds the "translations" edge to the ProjectImageTranslation entity by ids.
func (m *ProjectImageMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the ProjectImageTranslation entity.
func (m *ProjectImageMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the ProjectImageTranslation entity was cleared.
func (m *ProjectImageMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the ProjectImageTranslation entity by IDs.
func (m *ProjectImageMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the ProjectImageTranslation entity.
func (m *ProjectImageMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *ProjectImageMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *ProjectImageMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the ProjectImageMutation builder.
func (m *ProjectImageMutation) Where(ps ...predicate.ProjectImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectImage).
func (m *ProjectImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectImageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.project != nil {
		fields = append(fields, projectimage.FieldProjectID)
	}
	if m.image_url != nil {
		fields = append(fields, projectimage.FieldImageURL)
	}
	if m.alt_text != nil {
		fields = append(fields, projectimage.FieldAltText)
	}
	if m.caption != nil {
		fields = append(fields, projectimage.FieldCaption)
	}
	if m.image_type != nil {
		fields = append(fields, projectimage.FieldImageType)
	}
	if m.sort_order != nil {
		fields = append(fields, projectimage.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, projectimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectimage.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectimage.FieldProjectID:
		return m.ProjectID()
	case projectimage.FieldImageURL:
		return m.ImageURL()
	case projectimage.FieldAltText:
		return m.AltText()
	case projectimage.FieldCaption:
		return m.Caption()
	case projectimage.FieldImageType:
		return m.ImageType()
	case projectimage.FieldSortOrder:
		return m.SortOrder()
	case projectimage.FieldCreatedAt:
		return m.CreatedAt()
	case projectimage.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectimage.FieldProjectID:
		return m.OldProjectID(ctx)
	case projectimage.FieldImageURL:
		return m.OldImageURL(ctx)
	case projectimage.FieldAltText:
		return m.OldAltText(ctx)
	case projectimage.FieldCaption:
		return m.OldCaption(ctx)
	case projectimage.FieldImageType:
		return m.OldImageType(ctx)
	case projectimage.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case projectimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectimage.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projectimage.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case projectimage.FieldAltText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltText(v)
		return nil
	case projectimage.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case projectimage.FieldImageType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageType(v)
		return nil
	case projectimage.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case projectimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectImageMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, projectimage.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projectimage.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projectimage.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectimage.FieldAltText) {
		fields = append(fields, projectimage.FieldAltText)
	}
	if m.FieldCleared(projectimage.FieldCaption) {
		fields = append(fields, projectimage.FieldCaption)
	}
	if m.FieldCleared(projectimage.FieldImageType) {
		fields = append(fields, projectimage.FieldImageType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectImageMutation) ClearField(name string) error {
	switch name {
	case projectimage.FieldAltText:
		m.ClearAltText()
		return nil
	case projectimage.FieldCaption:
		m.ClearCaption()
		return nil
	case projectimage.FieldImageType:
		m.ClearImageType()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectImageMutation) ResetField(name string) error {
	switch name {
	case projectimage.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projectimage.FieldImageURL:
		m.ResetImageURL()
		return nil
	case projectimage.FieldAltText:
		m.ResetAltText()
		return nil
	case projectimage.FieldCaption:
		m.ResetCaption()
		return nil
	case projectimage.FieldImageType:
		m.ResetImageType()
		return nil
	case projectimage.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case projectimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projectimage.EdgeProject)
	}
	if m.translations != nil {
		edges = append(edges, projectimage.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectimage.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectimage.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, projectimage.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectimage.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projectimage.EdgeProject)
	}
	if m.clearedtranslations {
		edges = append(edges, projectimage.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectImageMutation) EdgeCleared(name string) bool {
	switch name {
	case projectimage.EdgeProject:
		return m.clearedproject
	case projectimage.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectImageMutation) ClearEdge(name string) error {
	switch name {
	case projectimage.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectImageMutation) ResetEdge(name string) error {
	switch name {
	case projectimage.EdgeProject:
		m.ResetProject()
		return nil
	case projectimage.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage edge %s", name)
}

// ProjectImageTranslationMutation represents an operation that mutates the ProjectImageTranslation nodes in the graph.
type ProjectImageTranslationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	alt_text             *string
	caption              *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	project_image        *uuid.UUID
	clearedproject_image bool
	language             *string
	clearedlanguage      bool
	done                 bool
	oldValue             func(context.Context) (*ProjectImageTranslation, error)
	predicates           []predicate.ProjectImageTranslation
}

var _ ent.Mutation = (*ProjectImageTranslationMutation)(nil)

// projectimagetranslationOption allows management of the mutation configuration using functional options.
type projectimagetranslationOption func(*ProjectImageTranslationMutation)

// newProjectImageTranslationMutation creates new mutation for the ProjectImageTranslation entity.
func newProjectImageTranslationMutation(c config, op Op, opts ...projectimagetranslationOption) *ProjectImageTranslationMutation {
	m := &ProjectImageTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectImageTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectImageTranslationID sets the ID field of the mutation.
func withProjectImageTranslationID(id uuid.UUID) projectimagetranslationOption {
	return func(m *ProjectImageTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectImageTranslation
		)
		m.oldValue = func(ctx context.Context) (*ProjectImageTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectImageTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectImageTranslation sets the old ProjectImageTranslation of the mutation.
func withProjectImageTranslation(node *ProjectImageTranslation) projectimagetranslationOption {
	return func(m *ProjectImageTranslationMutation) {
		m.oldValue = func(context.Context) (*ProjectImageTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectImageTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectImageTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectImageTranslation entities.
func (m *ProjectImageTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectImageTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectImageTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectImageTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectImageID sets the "project_image_id" field.
func (m *ProjectImageTranslationMutation) SetProjectImageID(u uuid.UUID) {
	m.project_image = &u
}

// ProjectImageID returns the value of the "project_image_id" field in the mutation.
func (m *ProjectImageTranslationMutation) ProjectImageID() (r uuid.UUID, exists bool) {
	v := m.project_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectImageID returns the old "project_image_id" field's value of the ProjectImageTranslation entity.
// If the ProjectImageTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageTranslationMutation) OldProjectImageID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectImageID: %w", err)
	}
	return oldValue.ProjectImageID, nil
}

// ResetProjectImageID resets all changes to the "project_image_id" field.
func (m *ProjectImageTranslationMutation) ResetProjectImageID() {
	m.project_image = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *ProjectImageTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *ProjectImageTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the ProjectImageTranslation entity.
// If the ProjectImageTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *ProjectImageTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetAltText sets the "alt_text" field.
func (m *ProjectImageTranslationMutation) SetAltText(s string) {
	m.alt_text = &s
}

// AltText returns the value of the "alt_text" field in the mutation.
func (m *ProjectImageTranslationMutation) AltText() (r string, exists bool) {
	v := m.alt_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAltText returns the old "alt_text" field's value of the ProjectImageTranslation entity.
// If the ProjectImageTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageTranslationMutation) OldAltText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltText: %w", err)
	}
	return oldValue.AltText, nil
}

// ClearAltText clears the value of the "alt_text" field.
func (m *ProjectImageTranslationMutation) ClearAltText() {
	m.alt_text = nil
	m.clearedFields[projectimagetranslation.FieldAltText] = struct{}{}
}

// AltTextCleared returns if the "alt_text" field was cleared in this mutation.
func (m *ProjectImageTranslationMutation) AltTextCleared() bool {
	_, ok := m.clearedFields[projectimagetranslation.FieldAltText]
	return ok
}

// ResetAltText resets all changes to the "alt_text" field.
func (m *ProjectImageTranslationMutation) ResetAltText() {
	m.alt_text = nil
	delete(m.clearedFields, projectimagetranslation.FieldAltText)
}

// SetCaption sets the "caption" field.
func (m *ProjectImageTranslationMutation) SetCaption(s string) {
	m.caption = &s
}

// Caption returns the value of the "caption" field in the mutation.
func (m *ProjectImageTranslationMutation) Caption() (r string, exists bool) {
	v := m.caption
	if v == nil {
		return
	}
	return *v, true
}

// OldCaption returns the old "caption" field's value of the ProjectImageTranslation entity.
// If the ProjectImageTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageTranslationMutation) OldCaption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCaption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCaption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCaption: %w", err)
	}
	return oldValue.Caption, nil
}

// ClearCaption clears the value of the "caption" field.
func (m *ProjectImageTranslationMutation) ClearCaption() {
	m.caption = nil
	m.clearedFields[projectimagetranslation.FieldCaption] = struct{}{}
}

// CaptionCleared returns if the "caption" field was cleared in this mutation.
func (m *ProjectImageTranslationMutation) CaptionCleared() bool {
	_, ok := m.clearedFields[projectimagetranslation.FieldCaption]
	return ok
}

// ResetCaption resets all changes to the "caption" field.
func (m *ProjectImageTranslationMutation) ResetCaption() {
	m.caption = nil
	delete(m.clearedFields, projectimagetranslation.FieldCaption)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectImageTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectImageTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectImageTranslation entity.
// If the ProjectImageTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectImageTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearProjectImage clears the "project_image" edge to the ProjectImage entity.
func (m *ProjectImageTranslationMutation) ClearProjectImage() {
	m.clearedproject_image = true
	m.clearedFields[projectimagetranslation.FieldProjectImageID] = struct{}{}
}

// ProjectImageCleared reports if the "project_image" edge to the ProjectImage entity was cleared.
func (m *ProjectImageTranslationMutation) ProjectImageCleared() bool {
	return m.clearedproject_image
}

// ProjectImageIDs returns the "project_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectImageID instead. It exists only for internal usage by the builders.
func (m *ProjectImageTranslationMutation) ProjectImageIDs() (ids []uuid.UUID) {
	if id := m.project_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectImage resets all changes to the "project_image" edge.
func (m *ProjectImageTranslationMutation) ResetProjectImage() {
	m.project_image = nil
	m.clearedproject_image = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *ProjectImageTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *ProjectImageTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[projectimagetranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *ProjectImageTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *ProjectImageTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *ProjectImageTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *ProjectImageTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the ProjectImageTranslationMutation builder.
func (m *ProjectImageTranslationMutation) Where(ps ...predicate.ProjectImageTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectImageTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectImageTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectImageTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectImageTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectImageTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectImageTranslation).
func (m *ProjectImageTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectImageTranslationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.project_image != nil {
		fields = append(fields, projectimagetranslation.FieldProjectImageID)
	}
	if m.language != nil {
		fields = append(fields, projectimagetranslation.FieldLanguageCode)
	}
	if m.alt_text != nil {
		fields = append(fields, projectimagetranslation.FieldAltText)
	}
	if m.caption != nil {
		fields = append(fields, projectimagetranslation.FieldCaption)
	}
	if m.created_at != nil {
		fields = append(fields, projectimagetranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectImageTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectimagetranslation.FieldProjectImageID:
		return m.ProjectImageID()
	case projectimagetranslation.FieldLanguageCode:
		return m.LanguageCode()
	case projectimagetranslation.FieldAltText:
		return m.AltText()
	case projectimagetranslation.FieldCaption:
		return m.Caption()
	case projectimagetranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectImageTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectimagetranslation.FieldProjectImageID:
		return m.OldProjectImageID(ctx)
	case projectimagetranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case projectimagetranslation.FieldAltText:
		return m.OldAltText(ctx)
	case projectimagetranslation.FieldCaption:
		return m.OldCaption(ctx)
	case projectimagetranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectImageTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectImageTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectimagetranslation.FieldProjectImageID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectImageID(v)
		return nil
	case projectimagetranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case projectimagetranslation.FieldAltText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltText(v)
		return nil
	case projectimagetranslation.FieldCaption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCaption(v)
		return nil
	case projectimagetranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectImageTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectImageTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectImageTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectImageTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectImageTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectImageTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectimagetranslation.FieldAltText) {
		fields = append(fields, projectimagetranslation.FieldAltText)
	}
	if m.FieldCleared(projectimagetranslation.FieldCaption) {
		fields = append(fields, projectimagetranslation.FieldCaption)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectImageTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectImageTranslationMutation) ClearField(name string) error {
	switch name {
	case projectimagetranslation.FieldAltText:
		m.ClearAltText()
		return nil
	case projectimagetranslation.FieldCaption:
		m.ClearCaption()
		return nil
	}
	return fmt.Errorf("unknown ProjectImageTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectImageTranslationMutation) ResetField(name string) error {
	switch name {
	case projectimagetranslation.FieldProjectImageID:
		m.ResetProjectImageID()
		return nil
	case projectimagetranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case projectimagetranslation.FieldAltText:
		m.ResetAltText()
		return nil
	case projectimagetranslation.FieldCaption:
		m.ResetCaption()
		return nil
	case projectimagetranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectImageTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectImageTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project_image != nil {
		edges = append(edges, projectimagetranslation.EdgeProjectImage)
	}
	if m.language != nil {
		edges = append(edges, projectimagetranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectImageTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectimagetranslation.EdgeProjectImage:
		if id := m.project_image; id != nil {
			return []ent.Value{*id}
		}
	case projectimagetranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectImageTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectImageTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectImageTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject_image {
		edges = append(edges, projectimagetranslation.EdgeProjectImage)
	}
	if m.clearedlanguage {
		edges = append(edges, projectimagetranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectImageTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case projectimagetranslation.EdgeProjectImage:
		return m.clearedproject_image
	case projectimagetranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectImageTranslationMutation) ClearEdge(name string) error {
	switch name {
	case projectimagetranslation.EdgeProjectImage:
		m.ClearProjectImage()
		return nil
	case projectimagetranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown ProjectImageTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectImageTranslationMutation) ResetEdge(name string) error {
	switch name {
	case projectimagetranslation.EdgeProjectImage:
		m.ResetProjectImage()
		return nil
	case projectimagetranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown ProjectImageTranslation edge %s", name)
}

// ProjectRelationshipMutation represents an operation that mutates the ProjectRelationship nodes in the graph.
type ProjectRelationshipMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	relationship_type     *string
	created_at            *time.Time
	clearedFields         map[string]struct{}
	source_project        *uuid.UUID
	clearedsource_project bool
	target_project        *uuid.UUID
	clearedtarget_project bool
	done                  bool
	oldValue              func(context.Context) (*ProjectRelationship, error)
	predicates            []predicate.ProjectRelationship
}

var _ ent.Mutation = (*ProjectRelationshipMutation)(nil)

// projectrelationshipOption allows management of the mutation configuration using functional options.
type projectrelationshipOption func(*ProjectRelationshipMutation)

// newProjectRelationshipMutation creates new mutation for the ProjectRelationship entity.
func newProjectRelationshipMutation(c config, op Op, opts ...projectrelationshipOption) *ProjectRelationshipMutation {
	m := &ProjectRelationshipMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectRelationship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectRelationshipID sets the ID field of the mutation.
func withProjectRelationshipID(id uuid.UUID) projectrelationshipOption {
	return func(m *ProjectRelationshipMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectRelationship
		)
		m.oldValue = func(ctx context.Context) (*ProjectRelationship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectRelationship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectRelationship sets the old ProjectRelationship of the mutation.
func withProjectRelationship(node *ProjectRelationship) projectrelationshipOption {
	return func(m *ProjectRelationshipMutation) {
		m.oldValue = func(context.Context) (*ProjectRelationship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectRelationshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectRelationshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectRelationship entities.
func (m *ProjectRelationshipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectRelationshipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectRelationshipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectRelationship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSourceProjectID sets the "source_project_id" field.
func (m *ProjectRelationshipMutation) SetSourceProjectID(u uuid.UUID) {
	m.source_project = &u
}

// SourceProjectID returns the value of the "source_project_id" field in the mutation.
func (m *ProjectRelationshipMutation) SourceProjectID() (r uuid.UUID, exists bool) {
	v := m.source_project
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceProjectID returns the old "source_project_id" field's value of the ProjectRelationship entity.
// If the ProjectRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectRelationshipMutation) OldSourceProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceProjectID: %w", err)
	}
	return oldValue.SourceProjectID, nil
}

// ResetSourceProjectID resets all changes to the "source_project_id" field.
func (m *ProjectRelationshipMutation) ResetSourceProjectID() {
	m.source_project = nil
}

// SetTargetProjectID sets the "target_project_id" field.
func (m *ProjectRelationshipMutation) SetTargetProjectID(u uuid.UUID) {
	m.target_project = &u
}

// TargetProjectID returns the value of the "target_project_id" field in the mutation.
func (m *ProjectRelationshipMutation) TargetProjectID() (r uuid.UUID, exists bool) {
	v := m.target_project
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetProjectID returns the old "target_project_id" field's value of the ProjectRelationship entity.
// If the ProjectRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectRelationshipMutation) OldTargetProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetProjectID: %w", err)
	}
	return oldValue.TargetProjectID, nil
}

// ResetTargetProjectID resets all changes to the "target_project_id" field.
func (m *ProjectRelationshipMutation) ResetTargetProjectID() {
	m.target_project = nil
}

// SetRelationshipType sets the "relationship_type" field.
func (m *ProjectRelationshipMutation) SetRelationshipType(s string) {
	m.relationship_type = &s
}

// RelationshipType returns the value of the "relationship_type" field in the mutation.
func (m *ProjectRelationshipMutation) RelationshipType() (r string, exists bool) {
	v := m.relationship_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipType returns the old "relationship_type" field's value of the ProjectRelationship entity.
// If the ProjectRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectRelationshipMutation) OldRelationshipType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipType: %w", err)
	}
	return oldValue.RelationshipType, nil
}

// ResetRelationshipType resets all changes to the "relationship_type" field.
func (m *ProjectRelationshipMutation) ResetRelationshipType() {
	m.relationship_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectRelationshipMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectRelationshipMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectRelationship entity.
// If the ProjectRelationship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectRelationshipMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectRelationshipMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearSourceProject clears the "source_project" edge to the Project entity.
func (m *ProjectRelationshipMutation) ClearSourceProject() {
	m.clearedsource_project = true
	m.clearedFields[projectrelationship.FieldSourceProjectID] = struct{}{}
}

// SourceProjectCleared reports if the "source_project" edge to the Project entity was cleared.
func (m *ProjectRelationshipMutation) SourceProjectCleared() bool {
	return m.clearedsource_project
}

// SourceProjectIDs returns the "source_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectRelationshipMutation) SourceProjectIDs() (ids []uuid.UUID) {
	if id := m.source_project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSourceProject resets all changes to the "source_project" edge.
func (m *ProjectRelationshipMutation) ResetSourceProject() {
	m.source_project = nil
	m.clearedsource_project = false
}

// ClearTargetProject clears the "target_project" edge to the Project entity.
func (m *ProjectRelationshipMutation) ClearTargetProject() {
	m.clearedtarget_project = true
	m.clearedFields[projectrelationship.FieldTargetProjectID] = struct{}{}
}

// TargetProjectCleared reports if the "target_project" edge to the Project entity was cleared.
func (m *ProjectRelationshipMutation) TargetProjectCleared() bool {
	return m.clearedtarget_project
}

// TargetProjectIDs returns the "target_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TargetProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectRelationshipMutation) TargetProjectIDs() (ids []uuid.UUID) {
	if id := m.target_project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTargetProject resets all changes to the "target_project" edge.
func (m *ProjectRelationshipMutation) ResetTargetProject() {
	m.target_project = nil
	m.clearedtarget_project = false
}

// Where appends a list predicates to the ProjectRelationshipMutation builder.
func (m *ProjectRelationshipMutation) Where(ps ...predicate.ProjectRelationship) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectRelationshipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectRelationshipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectRelationship, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectRelationshipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectRelationshipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectRelationship).
func (m *ProjectRelationshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectRelationshipMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.source_project != nil {
		fields = append(fields, projectrelationship.FieldSourceProjectID)
	}
	if m.target_project != nil {
		fields = append(fields, projectrelationship.FieldTargetProjectID)
	}
	if m.relationship_type != nil {
		fields = append(fields, projectrelationship.FieldRelationshipType)
	}
	if m.created_at != nil {
		fields = append(fields, projectrelationship.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectRelationshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectrelationship.FieldSourceProjectID:
		return m.SourceProjectID()
	case projectrelationship.FieldTargetProjectID:
		return m.TargetProjectID()
	case projectrelationship.FieldRelationshipType:
		return m.RelationshipType()
	case projectrelationship.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectRelationshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectrelationship.FieldSourceProjectID:
		return m.OldSourceProjectID(ctx)
	case projectrelationship.FieldTargetProjectID:
		return m.OldTargetProjectID(ctx)
	case projectrelationship.FieldRelationshipType:
		return m.OldRelationshipType(ctx)
	case projectrelationship.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectRelationship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectRelationshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectrelationship.FieldSourceProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceProjectID(v)
		return nil
	case projectrelationship.FieldTargetProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetProjectID(v)
		return nil
	case projectrelationship.FieldRelationshipType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipType(v)
		return nil
	case projectrelationship.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectRelationship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectRelationshipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectRelationshipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectRelationshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectRelationship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectRelationshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectRelationshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectRelationshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectRelationship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectRelationshipMutation) ResetField(name string) error {
	switch name {
	case projectrelationship.FieldSourceProjectID:
		m.ResetSourceProjectID()
		return nil
	case projectrelationship.FieldTargetProjectID:
		m.ResetTargetProjectID()
		return nil
	case projectrelationship.FieldRelationshipType:
		m.ResetRelationshipType()
		return nil
	case projectrelationship.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectRelationship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectRelationshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.source_project != nil {
		edges = append(edges, projectrelationship.EdgeSourceProject)
	}
	if m.target_project != nil {
		edges = append(edges, projectrelationship.EdgeTargetProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectRelationshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectrelationship.EdgeSourceProject:
		if id := m.source_project; id != nil {
			return []ent.Value{*id}
		}
	case projectrelationship.EdgeTargetProject:
		if id := m.target_project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectRelationshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectRelationshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectRelationshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsource_project {
		edges = append(edges, projectrelationship.EdgeSourceProject)
	}
	if m.clearedtarget_project {
		edges = append(edges, projectrelationship.EdgeTargetProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectRelationshipMutation) EdgeCleared(name string) bool {
	switch name {
	case projectrelationship.EdgeSourceProject:
		return m.clearedsource_project
	case projectrelationship.EdgeTargetProject:
		return m.clearedtarget_project
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectRelationshipMutation) ClearEdge(name string) error {
	switch name {
	case projectrelationship.EdgeSourceProject:
		m.ClearSourceProject()
		return nil
	case projectrelationship.EdgeTargetProject:
		m.ClearTargetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectRelationship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectRelationshipMutation) ResetEdge(name string) error {
	switch name {
	case projectrelationship.EdgeSourceProject:
		m.ResetSourceProject()
		return nil
	case projectrelationship.EdgeTargetProject:
		m.ResetTargetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectRelationship edge %s", name)
}

// ProjectTechnologyMutation represents an operation that mutates the ProjectTechnology nodes in the graph.
type ProjectTechnologyMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	technology_name *string
	technology_type *string
	sort_order      *int
	addsort_order   *int
	created_at      *time.Time
	clearedFields   map[string]struct{}
	project         *uuid.UUID
	clearedproject  bool
	done            bool
	oldValue        func(context.Context) (*ProjectTechnology, error)
	predicates      []predicate.ProjectTechnology
}

var _ ent.Mutation = (*ProjectTechnologyMutation)(nil)

// projecttechnologyOption allows management of the mutation configuration using functional options.
type projecttechnologyOption func(*ProjectTechnologyMutation)

// newProjectTechnologyMutation creates new mutation for the ProjectTechnology entity.
func newProjectTechnologyMutation(c config, op Op, opts ...projecttechnologyOption) *ProjectTechnologyMutation {
	m := &ProjectTechnologyMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTechnology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTechnologyID sets the ID field of the mutation.
func withProjectTechnologyID(id uuid.UUID) projecttechnologyOption {
	return func(m *ProjectTechnologyMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTechnology
		)
		m.oldValue = func(ctx context.Context) (*ProjectTechnology, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTechnology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTechnology sets the old ProjectTechnology of the mutation.
func withProjectTechnology(node *ProjectTechnology) projecttechnologyOption {
	return func(m *ProjectTechnologyMutation) {
		m.oldValue = func(context.Context) (*ProjectTechnology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTechnologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTechnologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTechnology entities.
func (m *ProjectTechnologyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTechnologyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTechnologyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTechnology.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTechnologyMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTechnologyMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTechnologyMutation) ResetProjectID() {
	m.project = nil
}

// SetTechnologyName sets the "technology_name" field.
func (m *ProjectTechnologyMutation) SetTechnologyName(s string) {
	m.technology_name = &s
}

// TechnologyName returns the value of the "technology_name" field in the mutation.
func (m *ProjectTechnologyMutation) TechnologyName() (r string, exists bool) {
	v := m.technology_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnologyName returns the old "technology_name" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldTechnologyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnologyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnologyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnologyName: %w", err)
	}
	return oldValue.TechnologyName, nil
}

// ResetTechnologyName resets all changes to the "technology_name" field.
func (m *ProjectTechnologyMutation) ResetTechnologyName() {
	m.technology_name = nil
}

// SetTechnologyType sets the "technology_type" field.
func (m *ProjectTechnologyMutation) SetTechnologyType(s string) {
	m.technology_type = &s
}

// TechnologyType returns the value of the "technology_type" field in the mutation.
func (m *ProjectTechnologyMutation) TechnologyType() (r string, exists bool) {
	v := m.technology_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnologyType returns the old "technology_type" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldTechnologyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnologyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnologyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnologyType: %w", err)
	}
	return oldValue.TechnologyType, nil
}

// ClearTechnologyType clears the value of the "technology_type" field.
func (m *ProjectTechnologyMutation) ClearTechnologyType() {
	m.technology_type = nil
	m.clearedFields[projecttechnology.FieldTechnologyType] = struct{}{}
}

// TechnologyTypeCleared returns if the "technology_type" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) TechnologyTypeCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldTechnologyType]
	return ok
}

// ResetTechnologyType resets all changes to the "technology_type" field.
func (m *ProjectTechnologyMutation) ResetTechnologyType() {
	m.technology_type = nil
	delete(m.clearedFields, projecttechnology.FieldTechnologyType)
}

// SetSortOrder sets the "sort_order" field.
func (m *ProjectTechnologyMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProjectTechnologyMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProjectTechnologyMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProjectTechnologyMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProjectTechnologyMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTechnologyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTechnologyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTechnologyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTechnologyMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[projecttechnology.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTechnologyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTechnologyMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTechnologyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ProjectTechnologyMutation builder.
func (m *ProjectTechnologyMutation) Where(ps ...predicate.ProjectTechnology) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectTechnologyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectTechnologyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectTechnology, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectTechnologyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectTechnologyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectTechnology).
func (m *ProjectTechnologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTechnologyMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.project != nil {
		fields = append(fields, projecttechnology.FieldProjectID)
	}
	if m.technology_name != nil {
		fields = append(fields, projecttechnology.FieldTechnologyName)
	}
	if m.technology_type != nil {
		fields = append(fields, projecttechnology.FieldTechnologyType)
	}
	if m.sort_order != nil {
		fields = append(fields, projecttechnology.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, projecttechnology.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTechnologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttechnology.FieldProjectID:
		return m.ProjectID()
	case projecttechnology.FieldTechnologyName:
		return m.TechnologyName()
	case projecttechnology.FieldTechnologyType:
		return m.TechnologyType()
	case projecttechnology.FieldSortOrder:
		return m.SortOrder()
	case projecttechnology.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTechnologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttechnology.FieldProjectID:
		return m.OldProjectID(ctx)
	case projecttechnology.FieldTechnologyName:
		return m.OldTechnologyName(ctx)
	case projecttechnology.FieldTechnologyType:
		return m.OldTechnologyType(ctx)
	case projecttechnology.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case projecttechnology.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTechnology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTechnologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttechnology.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projecttechnology.FieldTechnologyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnologyName(v)
		return nil
	case projecttechnology.FieldTechnologyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnologyType(v)
		return nil
	case projecttechnology.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case projecttechnology.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTechnologyMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, projecttechnology.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTechnologyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projecttechnology.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTechnologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projecttechnology.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTechnologyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttechnology.FieldTechnologyType) {
		fields = append(fields, projecttechnology.FieldTechnologyType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTechnologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTechnologyMutation) ClearField(name string) error {
	switch name {
	case projecttechnology.FieldTechnologyType:
		m.ClearTechnologyType()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTechnologyMutation) ResetField(name string) error {
	switch name {
	case projecttechnology.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projecttechnology.FieldTechnologyName:
		m.ResetTechnologyName()
		return nil
	case projecttechnology.FieldTechnologyType:
		m.ResetTechnologyType()
		return nil
	case projecttechnology.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case projecttechnology.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTechnologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, projecttechnology.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTechnologyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttechnology.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTechnologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTechnologyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTechnologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, projecttechnology.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTechnologyMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttechnology.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTechnologyMutation) ClearEdge(name string) error {
	switch name {
	case projecttechnology.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTechnologyMutation) ResetEdge(name string) error {
	switch name {
	case projecttechnology.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology edge %s", name)
}

// ProjectTranslationMutation represents an operation that mutates the ProjectTranslation nodes in the graph.
type ProjectTranslationMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	title           *string
	description     *string
	project_type    *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	project         *uuid.UUID
	clearedproject  bool
	language        *string
	clearedlanguage bool
	done            bool
	oldValue        func(context.Context) (*ProjectTranslation, error)
	predicates      []predicate.ProjectTranslation
}

var _ ent.Mutation = (*ProjectTranslationMutation)(nil)

// projecttranslationOption allows management of the mutation configuration using functional options.
type projecttranslationOption func(*ProjectTranslationMutation)

// newProjectTranslationMutation creates new mutation for the ProjectTranslation entity.
func newProjectTranslationMutation(c config, op Op, opts ...projecttranslationOption) *ProjectTranslationMutation {
	m := &ProjectTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTranslationID sets the ID field of the mutation.
func withProjectTranslationID(id uuid.UUID) projecttranslationOption {
	return func(m *ProjectTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTranslation
		)
		m.oldValue = func(ctx context.Context) (*ProjectTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTranslation sets the old ProjectTranslation of the mutation.
func withProjectTranslation(node *ProjectTranslation) projecttranslationOption {
	return func(m *ProjectTranslationMutation) {
		m.oldValue = func(context.Context) (*ProjectTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTranslation entities.
func (m *ProjectTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectTranslationMutation) SetProjectID(u uuid.UUID) {
	m.project = &u
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectTranslationMutation) ProjectID() (r uuid.UUID, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectTranslation entity.
// If the ProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTranslationMutation) OldProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectTranslationMutation) ResetProjectID() {
	m.project = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *ProjectTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *ProjectTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the ProjectTranslation entity.
// If the ProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *ProjectTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *ProjectTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProjectTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ProjectTranslation entity.
// If the ProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ProjectTranslationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectTranslationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectTranslation entity.
// If the ProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTranslationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectTranslationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttranslation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectTranslationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttranslation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectTranslationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttranslation.FieldDescription)
}

// SetProjectType sets the "project_type" field.
func (m *ProjectTranslationMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *ProjectTranslationMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the ProjectTranslation entity.
// If the ProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTranslationMutation) OldProjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ClearProjectType clears the value of the "project_type" field.
func (m *ProjectTranslationMutation) ClearProjectType() {
	m.project_type = nil
	m.clearedFields[projecttranslation.FieldProjectType] = struct{}{}
}

// ProjectTypeCleared returns if the "project_type" field was cleared in this mutation.
func (m *ProjectTranslationMutation) ProjectTypeCleared() bool {
	_, ok := m.clearedFields[projecttranslation.FieldProjectType]
	return ok
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *ProjectTranslationMutation) ResetProjectType() {
	m.project_type = nil
	delete(m.clearedFields, projecttranslation.FieldProjectType)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTranslation entity.
// If the ProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTranslationMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[projecttranslation.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTranslationMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTranslationMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTranslationMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *ProjectTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *ProjectTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[projecttranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *ProjectTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *ProjectTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *ProjectTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *ProjectTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the ProjectTranslationMutation builder.
func (m *ProjectTranslationMutation) Where(ps ...predicate.ProjectTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectTranslation).
func (m *ProjectTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTranslationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.project != nil {
		fields = append(fields, projecttranslation.FieldProjectID)
	}
	if m.language != nil {
		fields = append(fields, projecttranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, projecttranslation.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, projecttranslation.FieldDescription)
	}
	if m.project_type != nil {
		fields = append(fields, projecttranslation.FieldProjectType)
	}
	if m.created_at != nil {
		fields = append(fields, projecttranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttranslation.FieldProjectID:
		return m.ProjectID()
	case projecttranslation.FieldLanguageCode:
		return m.LanguageCode()
	case projecttranslation.FieldTitle:
		return m.Title()
	case projecttranslation.FieldDescription:
		return m.Description()
	case projecttranslation.FieldProjectType:
		return m.ProjectType()
	case projecttranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttranslation.FieldProjectID:
		return m.OldProjectID(ctx)
	case projecttranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case projecttranslation.FieldTitle:
		return m.OldTitle(ctx)
	case projecttranslation.FieldDescription:
		return m.OldDescription(ctx)
	case projecttranslation.FieldProjectType:
		return m.OldProjectType(ctx)
	case projecttranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttranslation.FieldProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projecttranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case projecttranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case projecttranslation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projecttranslation.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case projecttranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttranslation.FieldDescription) {
		fields = append(fields, projecttranslation.FieldDescription)
	}
	if m.FieldCleared(projecttranslation.FieldProjectType) {
		fields = append(fields, projecttranslation.FieldProjectType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTranslationMutation) ClearField(name string) error {
	switch name {
	case projecttranslation.FieldDescription:
		m.ClearDescription()
		return nil
	case projecttranslation.FieldProjectType:
		m.ClearProjectType()
		return nil
	}
	return fmt.Errorf("unknown ProjectTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTranslationMutation) ResetField(name string) error {
	switch name {
	case projecttranslation.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projecttranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case projecttranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case projecttranslation.FieldDescription:
		m.ResetDescription()
		return nil
	case projecttranslation.FieldProjectType:
		m.ResetProjectType()
		return nil
	case projecttranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, projecttranslation.EdgeProject)
	}
	if m.language != nil {
		edges = append(edges, projecttranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttranslation.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projecttranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, projecttranslation.EdgeProject)
	}
	if m.clearedlanguage {
		edges = append(edges, projecttranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttranslation.EdgeProject:
		return m.clearedproject
	case projecttranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTranslationMutation) ClearEdge(name string) error {
	switch name {
	case projecttranslation.EdgeProject:
		m.ClearProject()
		return nil
	case projecttranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown ProjectTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTranslationMutation) ResetEdge(name string) error {
	switch name {
	case projecttranslation.EdgeProject:
		m.ResetProject()
		return nil
	case projecttranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown ProjectTranslation edge %s", name)
}

// PublicationMutation represents an operation that mutates the Publication nodes in the graph.
type PublicationMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	title               *string
	publication_type    *string
	journal_name        *string
	conference_name     *string
	volume              *string
	issue               *string
	pages               *string
	publication_date    *time.Time
	doi                 *string
	isbn                *string
	url                 *string
	pdf_url             *string
	citation_count      *int
	addcitation_count   *int
	is_peer_reviewed    *bool
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	authors             map[uuid.UUID]struct{}
	removedauthors      map[uuid.UUID]struct{}
	clearedauthors      bool
	done                bool
	oldValue            func(context.Context) (*Publication, error)
	predicates          []predicate.Publication
}

var _ ent.Mutation = (*PublicationMutation)(nil)

// publicationOption allows management of the mutation configuration using functional options.
type publicationOption func(*PublicationMutation)

// newPublicationMutation creates new mutation for the Publication entity.
func newPublicationMutation(c config, op Op, opts ...publicationOption) *PublicationMutation {
	m := &PublicationMutation{
		config:        c,
		op:            op,
		typ:           TypePublication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationID sets the ID field of the mutation.
func withPublicationID(id uuid.UUID) publicationOption {
	return func(m *PublicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Publication
		)
		m.oldValue = func(ctx context.Context) (*Publication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublication sets the old Publication of the mutation.
func withPublication(node *Publication) publicationOption {
	return func(m *PublicationMutation) {
		m.oldValue = func(context.Context) (*Publication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Publication entities.
func (m *PublicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PublicationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PublicationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PublicationMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *PublicationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PublicationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PublicationMutation) ResetTitle() {
	m.title = nil
}

// SetPublicationType sets the "publication_type" field.
func (m *PublicationMutation) SetPublicationType(s string) {
	m.publication_type = &s
}

// PublicationType returns the value of the "publication_type" field in the mutation.
func (m *PublicationMutation) PublicationType() (r string, exists bool) {
	v := m.publication_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationType returns the old "publication_type" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPublicationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationType: %w", err)
	}
	return oldValue.PublicationType, nil
}

// ResetPublicationType resets all changes to the "publication_type" field.
func (m *PublicationMutation) ResetPublicationType() {
	m.publication_type = nil
}

// SetJournalName sets the "journal_name" field.
func (m *PublicationMutation) SetJournalName(s string) {
	m.journal_name = &s
}

// JournalName returns the value of the "journal_name" field in the mutation.
func (m *PublicationMutation) JournalName() (r string, exists bool) {
	v := m.journal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJournalName returns the old "journal_name" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldJournalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJournalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJournalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJournalName: %w", err)
	}
	return oldValue.JournalName, nil
}

// ClearJournalName clears the value of the "journal_name" field.
func (m *PublicationMutation) ClearJournalName() {
	m.journal_name = nil
	m.clearedFields[publication.FieldJournalName] = struct{}{}
}

// JournalNameCleared returns if the "journal_name" field was cleared in this mutation.
func (m *PublicationMutation) JournalNameCleared() bool {
	_, ok := m.clearedFields[publication.FieldJournalName]
	return ok
}

// ResetJournalName resets all changes to the "journal_name" field.
func (m *PublicationMutation) ResetJournalName() {
	m.journal_name = nil
	delete(m.clearedFields, publication.FieldJournalName)
}

// SetConferenceName sets the "conference_name" field.
func (m *PublicationMutation) SetConferenceName(s string) {
	m.conference_name = &s
}

// ConferenceName returns the value of the "conference_name" field in the mutation.
func (m *PublicationMutation) ConferenceName() (r string, exists bool) {
	v := m.conference_name
	if v == nil {
		return
	}
	return *v, true
}

// OldConferenceName returns the old "conference_name" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldConferenceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConferenceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConferenceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConferenceName: %w", err)
	}
	return oldValue.ConferenceName, nil
}

// ClearConferenceName clears the value of the "conference_name" field.
func (m *PublicationMutation) ClearConferenceName() {
	m.conference_name = nil
	m.clearedFields[publication.FieldConferenceName] = struct{}{}
}

// ConferenceNameCleared returns if the "conference_name" field was cleared in this mutation.
func (m *PublicationMutation) ConferenceNameCleared() bool {
	_, ok := m.clearedFields[publication.FieldConferenceName]
	return ok
}

// ResetConferenceName resets all changes to the "conference_name" field.
func (m *PublicationMutation) ResetConferenceName() {
	m.conference_name = nil
	delete(m.clearedFields, publication.FieldConferenceName)
}

// SetVolume sets the "volume" field.
func (m *PublicationMutation) SetVolume(s string) {
	m.volume = &s
}

// Volume returns the value of the "volume" field in the mutation.
func (m *PublicationMutation) Volume() (r string, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldVolume(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// ClearVolume clears the value of the "volume" field.
func (m *PublicationMutation) ClearVolume() {
	m.volume = nil
	m.clearedFields[publication.FieldVolume] = struct{}{}
}

// VolumeCleared returns if the "volume" field was cleared in this mutation.
func (m *PublicationMutation) VolumeCleared() bool {
	_, ok := m.clearedFields[publication.FieldVolume]
	return ok
}

// ResetVolume resets all changes to the "volume" field.
func (m *PublicationMutation) ResetVolume() {
	m.volume = nil
	delete(m.clearedFields, publication.FieldVolume)
}

// SetIssue sets the "issue" field.
func (m *PublicationMutation) SetIssue(s string) {
	m.issue = &s
}

// Issue returns the value of the "issue" field in the mutation.
func (m *PublicationMutation) Issue() (r string, exists bool) {
	v := m.issue
	if v == nil {
		return
	}
	return *v, true
}

// OldIssue returns the old "issue" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldIssue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssue: %w", err)
	}
	return oldValue.Issue, nil
}

// ClearIssue clears the value of the "issue" field.
func (m *PublicationMutation) ClearIssue() {
	m.issue = nil
	m.clearedFields[publication.FieldIssue] = struct{}{}
}

// IssueCleared returns if the "issue" field was cleared in this mutation.
func (m *PublicationMutation) IssueCleared() bool {
	_, ok := m.clearedFields[publication.FieldIssue]
	return ok
}

// ResetIssue resets all changes to the "issue" field.
func (m *PublicationMutation) ResetIssue() {
	m.issue = nil
	delete(m.clearedFields, publication.FieldIssue)
}

// SetPages sets the "pages" field.
func (m *PublicationMutation) SetPages(s string) {
	m.pages = &s
}

// Pages returns the value of the "pages" field in the mutation.
func (m *PublicationMutation) Pages() (r string, exists bool) {
	v := m.pages
	if v == nil {
		return
	}
	return *v, true
}

// OldPages returns the old "pages" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPages: %w", err)
	}
	return oldValue.Pages, nil
}

// ClearPages clears the value of the "pages" field.
func (m *PublicationMutation) ClearPages() {
	m.pages = nil
	m.clearedFields[publication.FieldPages] = struct{}{}
}

// PagesCleared returns if the "pages" field was cleared in this mutation.
func (m *PublicationMutation) PagesCleared() bool {
	_, ok := m.clearedFields[publication.FieldPages]
	return ok
}

// ResetPages resets all changes to the "pages" field.
func (m *PublicationMutation) ResetPages() {
	m.pages = nil
	delete(m.clearedFields, publication.FieldPages)
}

// SetPublicationDate sets the "publication_date" field.
func (m *PublicationMutation) SetPublicationDate(t time.Time) {
	m.publication_date = &t
}

// PublicationDate returns the value of the "publication_date" field in the mutation.
func (m *PublicationMutation) PublicationDate() (r time.Time, exists bool) {
	v := m.publication_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationDate returns the old "publication_date" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPublicationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationDate: %w", err)
	}
	return oldValue.PublicationDate, nil
}

// ClearPublicationDate clears the value of the "publication_date" field.
func (m *PublicationMutation) ClearPublicationDate() {
	m.publication_date = nil
	m.clearedFields[publication.FieldPublicationDate] = struct{}{}
}

// PublicationDateCleared returns if the "publication_date" field was cleared in this mutation.
func (m *PublicationMutation) PublicationDateCleared() bool {
	_, ok := m.clearedFields[publication.FieldPublicationDate]
	return ok
}

// ResetPublicationDate resets all changes to the "publication_date" field.
func (m *PublicationMutation) ResetPublicationDate() {
	m.publication_date = nil
	delete(m.clearedFields, publication.FieldPublicationDate)
}

// SetDoi sets the "doi" field.
func (m *PublicationMutation) SetDoi(s string) {
	m.doi = &s
}

// Doi returns the value of the "doi" field in the mutation.
func (m *PublicationMutation) Doi() (r string, exists bool) {
	v := m.doi
	if v == nil {
		return
	}
	return *v, true
}

// OldDoi returns the old "doi" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldDoi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoi: %w", err)
	}
	return oldValue.Doi, nil
}

// ClearDoi clears the value of the "doi" field.
func (m *PublicationMutation) ClearDoi() {
	m.doi = nil
	m.clearedFields[publication.FieldDoi] = struct{}{}
}

// DoiCleared returns if the "doi" field was cleared in this mutation.
func (m *PublicationMutation) DoiCleared() bool {
	_, ok := m.clearedFields[publication.FieldDoi]
	return ok
}

// ResetDoi resets all changes to the "doi" field.
func (m *PublicationMutation) ResetDoi() {
	m.doi = nil
	delete(m.clearedFields, publication.FieldDoi)
}

// SetIsbn sets the "isbn" field.
func (m *PublicationMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ClearIsbn clears the value of the "isbn" field.
func (m *PublicationMutation) ClearIsbn() {
	m.isbn = nil
	m.clearedFields[publication.FieldIsbn] = struct{}{}
}

// IsbnCleared returns if the "isbn" field was cleared in this mutation.
func (m *PublicationMutation) IsbnCleared() bool {
	_, ok := m.clearedFields[publication.FieldIsbn]
	return ok
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationMutation) ResetIsbn() {
	m.isbn = nil
	delete(m.clearedFields, publication.FieldIsbn)
}

// SetURL sets the "url" field.
func (m *PublicationMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PublicationMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *PublicationMutation) ClearURL() {
	m.url = nil
	m.clearedFields[publication.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *PublicationMutation) URLCleared() bool {
	_, ok := m.clearedFields[publication.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *PublicationMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, publication.FieldURL)
}

// SetPdfURL sets the "pdf_url" field.
func (m *PublicationMutation) SetPdfURL(s string) {
	m.pdf_url = &s
}

// PdfURL returns the value of the "pdf_url" field in the mutation.
func (m *PublicationMutation) PdfURL() (r string, exists bool) {
	v := m.pdf_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPdfURL returns the old "pdf_url" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPdfURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPdfURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPdfURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPdfURL: %w", err)
	}
	return oldValue.PdfURL, nil
}

// ClearPdfURL clears the value of the "pdf_url" field.
func (m *PublicationMutation) ClearPdfURL() {
	m.pdf_url = nil
	m.clearedFields[publication.FieldPdfURL] = struct{}{}
}

// PdfURLCleared returns if the "pdf_url" field was cleared in this mutation.
func (m *PublicationMutation) PdfURLCleared() bool {
	_, ok := m.clearedFields[publication.FieldPdfURL]
	return ok
}

// ResetPdfURL resets all changes to the "pdf_url" field.
func (m *PublicationMutation) ResetPdfURL() {
	m.pdf_url = nil
	delete(m.clearedFields, publication.FieldPdfURL)
}

// SetCitationCount sets the "citation_count" field.
func (m *PublicationMutation) SetCitationCount(i int) {
	m.citation_count = &i
	m.addcitation_count = nil
}

// CitationCount returns the value of the "citation_count" field in the mutation.
func (m *PublicationMutation) CitationCount() (r int, exists bool) {
	v := m.citation_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCitationCount returns the old "citation_count" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCitationCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCitationCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCitationCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitationCount: %w", err)
	}
	return oldValue.CitationCount, nil
}

// AddCitationCount adds i to the "citation_count" field.
func (m *PublicationMutation) AddCitationCount(i int) {
	if m.addcitation_count != nil {
		*m.addcitation_count += i
	} else {
		m.addcitation_count = &i
	}
}

// AddedCitationCount returns the value that was added to the "citation_count" field in this mutation.
func (m *PublicationMutation) AddedCitationCount() (r int, exists bool) {
	v := m.addcitation_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCitationCount resets all changes to the "citation_count" field.
func (m *PublicationMutation) ResetCitationCount() {
	m.citation_count = nil
	m.addcitation_count = nil
}

// SetIsPeerReviewed sets the "is_peer_reviewed" field.
func (m *PublicationMutation) SetIsPeerReviewed(b bool) {
	m.is_peer_reviewed = &b
}

// IsPeerReviewed returns the value of the "is_peer_reviewed" field in the mutation.
func (m *PublicationMutation) IsPeerReviewed() (r bool, exists bool) {
	v := m.is_peer_reviewed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPeerReviewed returns the old "is_peer_reviewed" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldIsPeerReviewed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPeerReviewed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPeerReviewed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPeerReviewed: %w", err)
	}
	return oldValue.IsPeerReviewed, nil
}

// ResetIsPeerReviewed resets all changes to the "is_peer_reviewed" field.
func (m *PublicationMutation) ResetIsPeerReviewed() {
	m.is_peer_reviewed = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *PublicationMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *PublicationMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *PublicationMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *PublicationMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *PublicationMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PublicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PublicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PublicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *PublicationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[publication.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PublicationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PublicationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PublicationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the PublicationTranslation entity by ids.
func (m *PublicationMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the PublicationTranslation entity.
func (m *PublicationMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the PublicationTranslation entity was cleared.
func (m *PublicationMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the PublicationTranslation entity by IDs.
func (m *PublicationMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the PublicationTranslation entity.
func (m *PublicationMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *PublicationMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *PublicationMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddAuthorIDs adds the "authors" edge to the PublicationAuthor entity by ids.
func (m *PublicationMutation) AddAuthorIDs(ids ...uuid.UUID) {
	if m.authors == nil {
		m.authors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the PublicationAuthor entity.
func (m *PublicationMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the PublicationAuthor entity was cleared.
func (m *PublicationMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the PublicationAuthor entity by IDs.
func (m *PublicationMutation) RemoveAuthorIDs(ids ...uuid.UUID) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the PublicationAuthor entity.
func (m *PublicationMutation) RemovedAuthorsIDs() (ids []uuid.UUID) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *PublicationMutation) AuthorsIDs() (ids []uuid.UUID) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *PublicationMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// Where appends a list predicates to the PublicationMutation builder.
func (m *PublicationMutation) Where(ps ...predicate.Publication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publication).
func (m *PublicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.user != nil {
		fields = append(fields, publication.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, publication.FieldTitle)
	}
	if m.publication_type != nil {
		fields = append(fields, publication.FieldPublicationType)
	}
	if m.journal_name != nil {
		fields = append(fields, publication.FieldJournalName)
	}
	if m.conference_name != nil {
		fields = append(fields, publication.FieldConferenceName)
	}
	if m.volume != nil {
		fields = append(fields, publication.FieldVolume)
	}
	if m.issue != nil {
		fields = append(fields, publication.FieldIssue)
	}
	if m.pages != nil {
		fields = append(fields, publication.FieldPages)
	}
	if m.publication_date != nil {
		fields = append(fields, publication.FieldPublicationDate)
	}
	if m.doi != nil {
		fields = append(fields, publication.FieldDoi)
	}
	if m.isbn != nil {
		fields = append(fields, publication.FieldIsbn)
	}
	if m.url != nil {
		fields = append(fields, publication.FieldURL)
	}
	if m.pdf_url != nil {
		fields = append(fields, publication.FieldPdfURL)
	}
	if m.citation_count != nil {
		fields = append(fields, publication.FieldCitationCount)
	}
	if m.is_peer_reviewed != nil {
		fields = append(fields, publication.FieldIsPeerReviewed)
	}
	if m.sort_order != nil {
		fields = append(fields, publication.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, publication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, publication.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publication.FieldUserID:
		return m.UserID()
	case publication.FieldTitle:
		return m.Title()
	case publication.FieldPublicationType:
		return m.PublicationType()
	case publication.FieldJournalName:
		return m.JournalName()
	case publication.FieldConferenceName:
		return m.ConferenceName()
	case publication.FieldVolume:
		return m.Volume()
	case publication.FieldIssue:
		return m.Issue()
	case publication.FieldPages:
		return m.Pages()
	case publication.FieldPublicationDate:
		return m.PublicationDate()
	case publication.FieldDoi:
		return m.Doi()
	case publication.FieldIsbn:
		return m.Isbn()
	case publication.FieldURL:
		return m.URL()
	case publication.FieldPdfURL:
		return m.PdfURL()
	case publication.FieldCitationCount:
		return m.CitationCount()
	case publication.FieldIsPeerReviewed:
		return m.IsPeerReviewed()
	case publication.FieldSortOrder:
		return m.SortOrder()
	case publication.FieldCreatedAt:
		return m.CreatedAt()
	case publication.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publication.FieldUserID:
		return m.OldUserID(ctx)
	case publication.FieldTitle:
		return m.OldTitle(ctx)
	case publication.FieldPublicationType:
		return m.OldPublicationType(ctx)
	case publication.FieldJournalName:
		return m.OldJournalName(ctx)
	case publication.FieldConferenceName:
		return m.OldConferenceName(ctx)
	case publication.FieldVolume:
		return m.OldVolume(ctx)
	case publication.FieldIssue:
		return m.OldIssue(ctx)
	case publication.FieldPages:
		return m.OldPages(ctx)
	case publication.FieldPublicationDate:
		return m.OldPublicationDate(ctx)
	case publication.FieldDoi:
		return m.OldDoi(ctx)
	case publication.FieldIsbn:
		return m.OldIsbn(ctx)
	case publication.FieldURL:
		return m.OldURL(ctx)
	case publication.FieldPdfURL:
		return m.OldPdfURL(ctx)
	case publication.FieldCitationCount:
		return m.OldCitationCount(ctx)
	case publication.FieldIsPeerReviewed:
		return m.OldIsPeerReviewed(ctx)
	case publication.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case publication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Publication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publication.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case publication.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case publication.FieldPublicationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationType(v)
		return nil
	case publication.FieldJournalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJournalName(v)
		return nil
	case publication.FieldConferenceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConferenceName(v)
		return nil
	case publication.FieldVolume:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case publication.FieldIssue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssue(v)
		return nil
	case publication.FieldPages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPages(v)
		return nil
	case publication.FieldPublicationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationDate(v)
		return nil
	case publication.FieldDoi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoi(v)
		return nil
	case publication.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publication.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case publication.FieldPdfURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPdfURL(v)
		return nil
	case publication.FieldCitationCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitationCount(v)
		return nil
	case publication.FieldIsPeerReviewed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPeerReviewed(v)
		return nil
	case publication.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case publication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationMutation) AddedFields() []string {
	var fields []string
	if m.addcitation_count != nil {
		fields = append(fields, publication.FieldCitationCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, publication.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publication.FieldCitationCount:
		return m.AddedCitationCount()
	case publication.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publication.FieldCitationCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCitationCount(v)
		return nil
	case publication.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Publication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publication.FieldJournalName) {
		fields = append(fields, publication.FieldJournalName)
	}
	if m.FieldCleared(publication.FieldConferenceName) {
		fields = append(fields, publication.FieldConferenceName)
	}
	if m.FieldCleared(publication.FieldVolume) {
		fields = append(fields, publication.FieldVolume)
	}
	if m.FieldCleared(publication.FieldIssue) {
		fields = append(fields, publication.FieldIssue)
	}
	if m.FieldCleared(publication.FieldPages) {
		fields = append(fields, publication.FieldPages)
	}
	if m.FieldCleared(publication.FieldPublicationDate) {
		fields = append(fields, publication.FieldPublicationDate)
	}
	if m.FieldCleared(publication.FieldDoi) {
		fields = append(fields, publication.FieldDoi)
	}
	if m.FieldCleared(publication.FieldIsbn) {
		fields = append(fields, publication.FieldIsbn)
	}
	if m.FieldCleared(publication.FieldURL) {
		fields = append(fields, publication.FieldURL)
	}
	if m.FieldCleared(publication.FieldPdfURL) {
		fields = append(fields, publication.FieldPdfURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationMutation) ClearField(name string) error {
	switch name {
	case publication.FieldJournalName:
		m.ClearJournalName()
		return nil
	case publication.FieldConferenceName:
		m.ClearConferenceName()
		return nil
	case publication.FieldVolume:
		m.ClearVolume()
		return nil
	case publication.FieldIssue:
		m.ClearIssue()
		return nil
	case publication.FieldPages:
		m.ClearPages()
		return nil
	case publication.FieldPublicationDate:
		m.ClearPublicationDate()
		return nil
	case publication.FieldDoi:
		m.ClearDoi()
		return nil
	case publication.FieldIsbn:
		m.ClearIsbn()
		return nil
	case publication.FieldURL:
		m.ClearURL()
		return nil
	case publication.FieldPdfURL:
		m.ClearPdfURL()
		return nil
	}
	return fmt.Errorf("unknown Publication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationMutation) ResetField(name string) error {
	switch name {
	case publication.FieldUserID:
		m.ResetUserID()
		return nil
	case publication.FieldTitle:
		m.ResetTitle()
		return nil
	case publication.FieldPublicationType:
		m.ResetPublicationType()
		return nil
	case publication.FieldJournalName:
		m.ResetJournalName()
		return nil
	case publication.FieldConferenceName:
		m.ResetConferenceName()
		return nil
	case publication.FieldVolume:
		m.ResetVolume()
		return nil
	case publication.FieldIssue:
		m.ResetIssue()
		return nil
	case publication.FieldPages:
		m.ResetPages()
		return nil
	case publication.FieldPublicationDate:
		m.ResetPublicationDate()
		return nil
	case publication.FieldDoi:
		m.ResetDoi()
		return nil
	case publication.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publication.FieldURL:
		m.ResetURL()
		return nil
	case publication.FieldPdfURL:
		m.ResetPdfURL()
		return nil
	case publication.FieldCitationCount:
		m.ResetCitationCount()
		return nil
	case publication.FieldIsPeerReviewed:
		m.ResetIsPeerReviewed()
		return nil
	case publication.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case publication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, publication.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, publication.EdgeTranslations)
	}
	if m.authors != nil {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case publication.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtranslations != nil {
		edges = append(edges, publication.EdgeTranslations)
	}
	if m.removedauthors != nil {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case publication.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, publication.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, publication.EdgeTranslations)
	}
	if m.clearedauthors {
		edges = append(edges, publication.EdgeAuthors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationMutation) EdgeCleared(name string) bool {
	switch name {
	case publication.EdgeUser:
		return m.cleareduser
	case publication.EdgeTranslations:
		return m.clearedtranslations
	case publication.EdgeAuthors:
		return m.clearedauthors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationMutation) ClearEdge(name string) error {
	switch name {
	case publication.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Publication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationMutation) ResetEdge(name string) error {
	switch name {
	case publication.EdgeUser:
		m.ResetUser()
		return nil
	case publication.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case publication.EdgeAuthors:
		m.ResetAuthors()
		return nil
	}
	return fmt.Errorf("unknown Publication edge %s", name)
}

// PublicationAuthorMutation represents an operation that mutates the PublicationAuthor nodes in the graph.
type PublicationAuthorMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	author_name        *string
	author_order       *int
	addauthor_order    *int
	is_corresponding   *bool
	affiliation        *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	publication        *uuid.UUID
	clearedpublication bool
	done               bool
	oldValue           func(context.Context) (*PublicationAuthor, error)
	predicates         []predicate.PublicationAuthor
}

var _ ent.Mutation = (*PublicationAuthorMutation)(nil)

// publicationauthorOption allows management of the mutation configuration using functional options.
type publicationauthorOption func(*PublicationAuthorMutation)

// newPublicationAuthorMutation creates new mutation for the PublicationAuthor entity.
func newPublicationAuthorMutation(c config, op Op, opts ...publicationauthorOption) *PublicationAuthorMutation {
	m := &PublicationAuthorMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationAuthorID sets the ID field of the mutation.
func withPublicationAuthorID(id uuid.UUID) publicationauthorOption {
	return func(m *PublicationAuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationAuthor
		)
		m.oldValue = func(ctx context.Context) (*PublicationAuthor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationAuthor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationAuthor sets the old PublicationAuthor of the mutation.
func withPublicationAuthor(node *PublicationAuthor) publicationauthorOption {
	return func(m *PublicationAuthorMutation) {
		m.oldValue = func(context.Context) (*PublicationAuthor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationAuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationAuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationAuthor entities.
func (m *PublicationAuthorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationAuthorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationAuthorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationAuthor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationAuthorMutation) SetPublicationID(u uuid.UUID) {
	m.publication = &u
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationAuthorMutation) PublicationID() (r uuid.UUID, exists bool) {
	v := m.publication
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldPublicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationAuthorMutation) ResetPublicationID() {
	m.publication = nil
}

// SetAuthorName sets the "author_name" field.
func (m *PublicationAuthorMutation) SetAuthorName(s string) {
	m.author_name = &s
}

// AuthorName returns the value of the "author_name" field in the mutation.
func (m *PublicationAuthorMutation) AuthorName() (r string, exists bool) {
	v := m.author_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorName returns the old "author_name" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldAuthorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorName: %w", err)
	}
	return oldValue.AuthorName, nil
}

// ResetAuthorName resets all changes to the "author_name" field.
func (m *PublicationAuthorMutation) ResetAuthorName() {
	m.author_name = nil
}

// SetAuthorOrder sets the "author_order" field.
func (m *PublicationAuthorMutation) SetAuthorOrder(i int) {
	m.author_order = &i
	m.addauthor_order = nil
}

// AuthorOrder returns the value of the "author_order" field in the mutation.
func (m *PublicationAuthorMutation) AuthorOrder() (r int, exists bool) {
	v := m.author_order
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorOrder returns the old "author_order" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldAuthorOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorOrder: %w", err)
	}
	return oldValue.AuthorOrder, nil
}

// AddAuthorOrder adds i to the "author_order" field.
func (m *PublicationAuthorMutation) AddAuthorOrder(i int) {
	if m.addauthor_order != nil {
		*m.addauthor_order += i
	} else {
		m.addauthor_order = &i
	}
}

// AddedAuthorOrder returns the value that was added to the "author_order" field in this mutation.
func (m *PublicationAuthorMutation) AddedAuthorOrder() (r int, exists bool) {
	v := m.addauthor_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorOrder resets all changes to the "author_order" field.
func (m *PublicationAuthorMutation) ResetAuthorOrder() {
	m.author_order = nil
	m.addauthor_order = nil
}

// SetIsCorresponding sets the "is_corresponding" field.
func (m *PublicationAuthorMutation) SetIsCorresponding(b bool) {
	m.is_corresponding = &b
}

// IsCorresponding returns the value of the "is_corresponding" field in the mutation.
func (m *PublicationAuthorMutation) IsCorresponding() (r bool, exists bool) {
	v := m.is_corresponding
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCorresponding returns the old "is_corresponding" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldIsCorresponding(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCorresponding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCorresponding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCorresponding: %w", err)
	}
	return oldValue.IsCorresponding, nil
}

// ResetIsCorresponding resets all changes to the "is_corresponding" field.
func (m *PublicationAuthorMutation) ResetIsCorresponding() {
	m.is_corresponding = nil
}

// SetAffiliation sets the "affiliation" field.
func (m *PublicationAuthorMutation) SetAffiliation(s string) {
	m.affiliation = &s
}

// Affiliation returns the value of the "affiliation" field in the mutation.
func (m *PublicationAuthorMutation) Affiliation() (r string, exists bool) {
	v := m.affiliation
	if v == nil {
		return
	}
	return *v, true
}

// OldAffiliation returns the old "affiliation" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldAffiliation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAffiliation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAffiliation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAffiliation: %w", err)
	}
	return oldValue.Affiliation, nil
}

// ClearAffiliation clears the value of the "affiliation" field.
func (m *PublicationAuthorMutation) ClearAffiliation() {
	m.affiliation = nil
	m.clearedFields[publicationauthor.FieldAffiliation] = struct{}{}
}

// AffiliationCleared returns if the "affiliation" field was cleared in this mutation.
func (m *PublicationAuthorMutation) AffiliationCleared() bool {
	_, ok := m.clearedFields[publicationauthor.FieldAffiliation]
	return ok
}

// ResetAffiliation resets all changes to the "affiliation" field.
func (m *PublicationAuthorMutation) ResetAffiliation() {
	m.affiliation = nil
	delete(m.clearedFields, publicationauthor.FieldAffiliation)
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationAuthorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationAuthorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationAuthorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PublicationAuthorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PublicationAuthorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PublicationAuthor entity.
// If the PublicationAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationAuthorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PublicationAuthorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearPublication clears the "publication" edge to the Publication entity.
func (m *PublicationAuthorMutation) ClearPublication() {
	m.clearedpublication = true
	m.clearedFields[publicationauthor.FieldPublicationID] = struct{}{}
}

// PublicationCleared reports if the "publication" edge to the Publication entity was cleared.
func (m *PublicationAuthorMutation) PublicationCleared() bool {
	return m.clearedpublication
}

// PublicationIDs returns the "publication" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublicationID instead. It exists only for internal usage by the builders.
func (m *PublicationAuthorMutation) PublicationIDs() (ids []uuid.UUID) {
	if id := m.publication; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublication resets all changes to the "publication" edge.
func (m *PublicationAuthorMutation) ResetPublication() {
	m.publication = nil
	m.clearedpublication = false
}

// Where appends a list predicates to the PublicationAuthorMutation builder.
func (m *PublicationAuthorMutation) Where(ps ...predicate.PublicationAuthor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationAuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationAuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationAuthor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationAuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationAuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationAuthor).
func (m *PublicationAuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationAuthorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.publication != nil {
		fields = append(fields, publicationauthor.FieldPublicationID)
	}
	if m.author_name != nil {
		fields = append(fields, publicationauthor.FieldAuthorName)
	}
	if m.author_order != nil {
		fields = append(fields, publicationauthor.FieldAuthorOrder)
	}
	if m.is_corresponding != nil {
		fields = append(fields, publicationauthor.FieldIsCorresponding)
	}
	if m.affiliation != nil {
		fields = append(fields, publicationauthor.FieldAffiliation)
	}
	if m.created_at != nil {
		fields = append(fields, publicationauthor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, publicationauthor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationAuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationauthor.FieldPublicationID:
		return m.PublicationID()
	case publicationauthor.FieldAuthorName:
		return m.AuthorName()
	case publicationauthor.FieldAuthorOrder:
		return m.AuthorOrder()
	case publicationauthor.FieldIsCorresponding:
		return m.IsCorresponding()
	case publicationauthor.FieldAffiliation:
		return m.Affiliation()
	case publicationauthor.FieldCreatedAt:
		return m.CreatedAt()
	case publicationauthor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationAuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationauthor.FieldPublicationID:
		return m.OldPublicationID(ctx)
	case publicationauthor.FieldAuthorName:
		return m.OldAuthorName(ctx)
	case publicationauthor.FieldAuthorOrder:
		return m.OldAuthorOrder(ctx)
	case publicationauthor.FieldIsCorresponding:
		return m.OldIsCorresponding(ctx)
	case publicationauthor.FieldAffiliation:
		return m.OldAffiliation(ctx)
	case publicationauthor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publicationauthor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationAuthor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationAuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationauthor.FieldPublicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	case publicationauthor.FieldAuthorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorName(v)
		return nil
	case publicationauthor.FieldAuthorOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorOrder(v)
		return nil
	case publicationauthor.FieldIsCorresponding:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCorresponding(v)
		return nil
	case publicationauthor.FieldAffiliation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAffiliation(v)
		return nil
	case publicationauthor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publicationauthor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationAuthorMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_order != nil {
		fields = append(fields, publicationauthor.FieldAuthorOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationAuthorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publicationauthor.FieldAuthorOrder:
		return m.AddedAuthorOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationAuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publicationauthor.FieldAuthorOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorOrder(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationAuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationauthor.FieldAffiliation) {
		fields = append(fields, publicationauthor.FieldAffiliation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationAuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationAuthorMutation) ClearField(name string) error {
	switch name {
	case publicationauthor.FieldAffiliation:
		m.ClearAffiliation()
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationAuthorMutation) ResetField(name string) error {
	switch name {
	case publicationauthor.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	case publicationauthor.FieldAuthorName:
		m.ResetAuthorName()
		return nil
	case publicationauthor.FieldAuthorOrder:
		m.ResetAuthorOrder()
		return nil
	case publicationauthor.FieldIsCorresponding:
		m.ResetIsCorresponding()
		return nil
	case publicationauthor.FieldAffiliation:
		m.ResetAffiliation()
		return nil
	case publicationauthor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publicationauthor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationAuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.publication != nil {
		edges = append(edges, publicationauthor.EdgePublication)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationAuthorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publicationauthor.EdgePublication:
		if id := m.publication; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationAuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationAuthorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationAuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpublication {
		edges = append(edges, publicationauthor.EdgePublication)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationAuthorMutation) EdgeCleared(name string) bool {
	switch name {
	case publicationauthor.EdgePublication:
		return m.clearedpublication
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationAuthorMutation) ClearEdge(name string) error {
	switch name {
	case publicationauthor.EdgePublication:
		m.ClearPublication()
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationAuthorMutation) ResetEdge(name string) error {
	switch name {
	case publicationauthor.EdgePublication:
		m.ResetPublication()
		return nil
	}
	return fmt.Errorf("unknown PublicationAuthor edge %s", name)
}

// PublicationTranslationMutation represents an operation that mutates the PublicationTranslation nodes in the graph.
type PublicationTranslationMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	title              *string
	journal_name       *string
	conference_name    *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	publication        *uuid.UUID
	clearedpublication bool
	language           *string
	clearedlanguage    bool
	done               bool
	oldValue           func(context.Context) (*PublicationTranslation, error)
	predicates         []predicate.PublicationTranslation
}

var _ ent.Mutation = (*PublicationTranslationMutation)(nil)

// publicationtranslationOption allows management of the mutation configuration using functional options.
type publicationtranslationOption func(*PublicationTranslationMutation)

// newPublicationTranslationMutation creates new mutation for the PublicationTranslation entity.
func newPublicationTranslationMutation(c config, op Op, opts ...publicationtranslationOption) *PublicationTranslationMutation {
	m := &PublicationTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypePublicationTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationTranslationID sets the ID field of the mutation.
func withPublicationTranslationID(id uuid.UUID) publicationtranslationOption {
	return func(m *PublicationTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicationTranslation
		)
		m.oldValue = func(ctx context.Context) (*PublicationTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicationTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicationTranslation sets the old PublicationTranslation of the mutation.
func withPublicationTranslation(node *PublicationTranslation) publicationtranslationOption {
	return func(m *PublicationTranslationMutation) {
		m.oldValue = func(context.Context) (*PublicationTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicationTranslation entities.
func (m *PublicationTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicationTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicationID sets the "publication_id" field.
func (m *PublicationTranslationMutation) SetPublicationID(u uuid.UUID) {
	m.publication = &u
}

// PublicationID returns the value of the "publication_id" field in the mutation.
func (m *PublicationTranslationMutation) PublicationID() (r uuid.UUID, exists bool) {
	v := m.publication
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationID returns the old "publication_id" field's value of the PublicationTranslation entity.
// If the PublicationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationTranslationMutation) OldPublicationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationID: %w", err)
	}
	return oldValue.PublicationID, nil
}

// ResetPublicationID resets all changes to the "publication_id" field.
func (m *PublicationTranslationMutation) ResetPublicationID() {
	m.publication = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *PublicationTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *PublicationTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the PublicationTranslation entity.
// If the PublicationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *PublicationTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *PublicationTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PublicationTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PublicationTranslation entity.
// If the PublicationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PublicationTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetJournalName sets the "journal_name" field.
func (m *PublicationTranslationMutation) SetJournalName(s string) {
	m.journal_name = &s
}

// JournalName returns the value of the "journal_name" field in the mutation.
func (m *PublicationTranslationMutation) JournalName() (r string, exists bool) {
	v := m.journal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJournalName returns the old "journal_name" field's value of the PublicationTranslation entity.
// If the PublicationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationTranslationMutation) OldJournalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJournalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJournalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJournalName: %w", err)
	}
	return oldValue.JournalName, nil
}

// ClearJournalName clears the value of the "journal_name" field.
func (m *PublicationTranslationMutation) ClearJournalName() {
	m.journal_name = nil
	m.clearedFields[publicationtranslation.FieldJournalName] = struct{}{}
}

// JournalNameCleared returns if the "journal_name" field was cleared in this mutation.
func (m *PublicationTranslationMutation) JournalNameCleared() bool {
	_, ok := m.clearedFields[publicationtranslation.FieldJournalName]
	return ok
}

// ResetJournalName resets all changes to the "journal_name" field.
func (m *PublicationTranslationMutation) ResetJournalName() {
	m.journal_name = nil
	delete(m.clearedFields, publicationtranslation.FieldJournalName)
}

// SetConferenceName sets the "conference_name" field.
func (m *PublicationTranslationMutation) SetConferenceName(s string) {
	m.conference_name = &s
}

// ConferenceName returns the value of the "conference_name" field in the mutation.
func (m *PublicationTranslationMutation) ConferenceName() (r string, exists bool) {
	v := m.conference_name
	if v == nil {
		return
	}
	return *v, true
}

// OldConferenceName returns the old "conference_name" field's value of the PublicationTranslation entity.
// If the PublicationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationTranslationMutation) OldConferenceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConferenceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConferenceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConferenceName: %w", err)
	}
	return oldValue.ConferenceName, nil
}

// ClearConferenceName clears the value of the "conference_name" field.
func (m *PublicationTranslationMutation) ClearConferenceName() {
	m.conference_name = nil
	m.clearedFields[publicationtranslation.FieldConferenceName] = struct{}{}
}

// ConferenceNameCleared returns if the "conference_name" field was cleared in this mutation.
func (m *PublicationTranslationMutation) ConferenceNameCleared() bool {
	_, ok := m.clearedFields[publicationtranslation.FieldConferenceName]
	return ok
}

// ResetConferenceName resets all changes to the "conference_name" field.
func (m *PublicationTranslationMutation) ResetConferenceName() {
	m.conference_name = nil
	delete(m.clearedFields, publicationtranslation.FieldConferenceName)
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PublicationTranslation entity.
// If the PublicationTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearPublication clears the "publication" edge to the Publication entity.
func (m *PublicationTranslationMutation) ClearPublication() {
	m.clearedpublication = true
	m.clearedFields[publicationtranslation.FieldPublicationID] = struct{}{}
}

// PublicationCleared reports if the "publication" edge to the Publication entity was cleared.
func (m *PublicationTranslationMutation) PublicationCleared() bool {
	return m.clearedpublication
}

// PublicationIDs returns the "publication" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublicationID instead. It exists only for internal usage by the builders.
func (m *PublicationTranslationMutation) PublicationIDs() (ids []uuid.UUID) {
	if id := m.publication; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublication resets all changes to the "publication" edge.
func (m *PublicationTranslationMutation) ResetPublication() {
	m.publication = nil
	m.clearedpublication = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *PublicationTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *PublicationTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[publicationtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *PublicationTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *PublicationTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *PublicationTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *PublicationTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the PublicationTranslationMutation builder.
func (m *PublicationTranslationMutation) Where(ps ...predicate.PublicationTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicationTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicationTranslation).
func (m *PublicationTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationTranslationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.publication != nil {
		fields = append(fields, publicationtranslation.FieldPublicationID)
	}
	if m.language != nil {
		fields = append(fields, publicationtranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, publicationtranslation.FieldTitle)
	}
	if m.journal_name != nil {
		fields = append(fields, publicationtranslation.FieldJournalName)
	}
	if m.conference_name != nil {
		fields = append(fields, publicationtranslation.FieldConferenceName)
	}
	if m.created_at != nil {
		fields = append(fields, publicationtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publicationtranslation.FieldPublicationID:
		return m.PublicationID()
	case publicationtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case publicationtranslation.FieldTitle:
		return m.Title()
	case publicationtranslation.FieldJournalName:
		return m.JournalName()
	case publicationtranslation.FieldConferenceName:
		return m.ConferenceName()
	case publicationtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publicationtranslation.FieldPublicationID:
		return m.OldPublicationID(ctx)
	case publicationtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case publicationtranslation.FieldTitle:
		return m.OldTitle(ctx)
	case publicationtranslation.FieldJournalName:
		return m.OldJournalName(ctx)
	case publicationtranslation.FieldConferenceName:
		return m.OldConferenceName(ctx)
	case publicationtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PublicationTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publicationtranslation.FieldPublicationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationID(v)
		return nil
	case publicationtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case publicationtranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case publicationtranslation.FieldJournalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJournalName(v)
		return nil
	case publicationtranslation.FieldConferenceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConferenceName(v)
		return nil
	case publicationtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PublicationTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PublicationTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publicationtranslation.FieldJournalName) {
		fields = append(fields, publicationtranslation.FieldJournalName)
	}
	if m.FieldCleared(publicationtranslation.FieldConferenceName) {
		fields = append(fields, publicationtranslation.FieldConferenceName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationTranslationMutation) ClearField(name string) error {
	switch name {
	case publicationtranslation.FieldJournalName:
		m.ClearJournalName()
		return nil
	case publicationtranslation.FieldConferenceName:
		m.ClearConferenceName()
		return nil
	}
	return fmt.Errorf("unknown PublicationTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationTranslationMutation) ResetField(name string) error {
	switch name {
	case publicationtranslation.FieldPublicationID:
		m.ResetPublicationID()
		return nil
	case publicationtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case publicationtranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case publicationtranslation.FieldJournalName:
		m.ResetJournalName()
		return nil
	case publicationtranslation.FieldConferenceName:
		m.ResetConferenceName()
		return nil
	case publicationtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PublicationTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.publication != nil {
		edges = append(edges, publicationtranslation.EdgePublication)
	}
	if m.language != nil {
		edges = append(edges, publicationtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publicationtranslation.EdgePublication:
		if id := m.publication; id != nil {
			return []ent.Value{*id}
		}
	case publicationtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpublication {
		edges = append(edges, publicationtranslation.EdgePublication)
	}
	if m.clearedlanguage {
		edges = append(edges, publicationtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case publicationtranslation.EdgePublication:
		return m.clearedpublication
	case publicationtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationTranslationMutation) ClearEdge(name string) error {
	switch name {
	case publicationtranslation.EdgePublication:
		m.ClearPublication()
		return nil
	case publicationtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown PublicationTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationTranslationMutation) ResetEdge(name string) error {
	switch name {
	case publicationtranslation.EdgePublication:
		m.ResetPublication()
		return nil
	case publicationtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown PublicationTranslation edge %s", name)
}

// RecentUpdateMutation represents an operation that mutates the RecentUpdate nodes in the graph.
type RecentUpdateMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	_type               *recentupdate.Type
	title               *string
	description         *string
	date                *time.Time
	tags                *[]string
	appendtags          []string
	status              *recentupdate.Status
	priority            *recentupdate.Priority
	external_id         *string
	image_url           *string
	video_url           *string
	document_url        *string
	gallery             *[]string
	appendgallery       []string
	attachments         *[]map[string]interface{}
	appendattachments   []map[string]interface{}
	media_metadata      *map[string]interface{}
	demo_url            *string
	github_url          *string
	external_url        *string
	social_links        *[]map[string]interface{}
	appendsocial_links  []map[string]interface{}
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	done                bool
	oldValue            func(context.Context) (*RecentUpdate, error)
	predicates          []predicate.RecentUpdate
}

var _ ent.Mutation = (*RecentUpdateMutation)(nil)

// recentupdateOption allows management of the mutation configuration using functional options.
type recentupdateOption func(*RecentUpdateMutation)

// newRecentUpdateMutation creates new mutation for the RecentUpdate entity.
func newRecentUpdateMutation(c config, op Op, opts ...recentupdateOption) *RecentUpdateMutation {
	m := &RecentUpdateMutation{
		config:        c,
		op:            op,
		typ:           TypeRecentUpdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecentUpdateID sets the ID field of the mutation.
func withRecentUpdateID(id uuid.UUID) recentupdateOption {
	return func(m *RecentUpdateMutation) {
		var (
			err   error
			once  sync.Once
			value *RecentUpdate
		)
		m.oldValue = func(ctx context.Context) (*RecentUpdate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecentUpdate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecentUpdate sets the old RecentUpdate of the mutation.
func withRecentUpdate(node *RecentUpdate) recentupdateOption {
	return func(m *RecentUpdateMutation) {
		m.oldValue = func(context.Context) (*RecentUpdate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecentUpdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecentUpdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RecentUpdate entities.
func (m *RecentUpdateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecentUpdateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecentUpdateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecentUpdate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *RecentUpdateMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RecentUpdateMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RecentUpdateMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *RecentUpdateMutation) SetType(r recentupdate.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *RecentUpdateMutation) GetType() (r recentupdate.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldType(ctx context.Context) (v recentupdate.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RecentUpdateMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *RecentUpdateMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RecentUpdateMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RecentUpdateMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *RecentUpdateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RecentUpdateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RecentUpdateMutation) ResetDescription() {
	m.description = nil
}

// SetDate sets the "date" field.
func (m *RecentUpdateMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *RecentUpdateMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *RecentUpdateMutation) ResetDate() {
	m.date = nil
}

// SetTags sets the "tags" field.
func (m *RecentUpdateMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *RecentUpdateMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *RecentUpdateMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *RecentUpdateMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ClearTags clears the value of the "tags" field.
func (m *RecentUpdateMutation) ClearTags() {
	m.tags = nil
	m.appendtags = nil
	m.clearedFields[recentupdate.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *RecentUpdateMutation) TagsCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *RecentUpdateMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
	delete(m.clearedFields, recentupdate.FieldTags)
}

// SetStatus sets the "status" field.
func (m *RecentUpdateMutation) SetStatus(r recentupdate.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RecentUpdateMutation) Status() (r recentupdate.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldStatus(ctx context.Context) (v recentupdate.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RecentUpdateMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *RecentUpdateMutation) SetPriority(r recentupdate.Priority) {
	m.priority = &r
}

// Priority returns the value of the "priority" field in the mutation.
func (m *RecentUpdateMutation) Priority() (r recentupdate.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldPriority(ctx context.Context) (v recentupdate.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *RecentUpdateMutation) ResetPriority() {
	m.priority = nil
}

// SetExternalID sets the "external_id" field.
func (m *RecentUpdateMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RecentUpdateMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RecentUpdateMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[recentupdate.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RecentUpdateMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RecentUpdateMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, recentupdate.FieldExternalID)
}

// SetImageURL sets the "image_url" field.
func (m *RecentUpdateMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *RecentUpdateMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ClearImageURL clears the value of the "image_url" field.
func (m *RecentUpdateMutation) ClearImageURL() {
	m.image_url = nil
	m.clearedFields[recentupdate.FieldImageURL] = struct{}{}
}

// ImageURLCleared returns if the "image_url" field was cleared in this mutation.
func (m *RecentUpdateMutation) ImageURLCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldImageURL]
	return ok
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *RecentUpdateMutation) ResetImageURL() {
	m.image_url = nil
	delete(m.clearedFields, recentupdate.FieldImageURL)
}

// SetVideoURL sets the "video_url" field.
func (m *RecentUpdateMutation) SetVideoURL(s string) {
	m.video_url = &s
}

// VideoURL returns the value of the "video_url" field in the mutation.
func (m *RecentUpdateMutation) VideoURL() (r string, exists bool) {
	v := m.video_url
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoURL returns the old "video_url" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldVideoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoURL: %w", err)
	}
	return oldValue.VideoURL, nil
}

// ClearVideoURL clears the value of the "video_url" field.
func (m *RecentUpdateMutation) ClearVideoURL() {
	m.video_url = nil
	m.clearedFields[recentupdate.FieldVideoURL] = struct{}{}
}

// VideoURLCleared returns if the "video_url" field was cleared in this mutation.
func (m *RecentUpdateMutation) VideoURLCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldVideoURL]
	return ok
}

// ResetVideoURL resets all changes to the "video_url" field.
func (m *RecentUpdateMutation) ResetVideoURL() {
	m.video_url = nil
	delete(m.clearedFields, recentupdate.FieldVideoURL)
}

// SetDocumentURL sets the "document_url" field.
func (m *RecentUpdateMutation) SetDocumentURL(s string) {
	m.document_url = &s
}

// DocumentURL returns the value of the "document_url" field in the mutation.
func (m *RecentUpdateMutation) DocumentURL() (r string, exists bool) {
	v := m.document_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentURL returns the old "document_url" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldDocumentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentURL: %w", err)
	}
	return oldValue.DocumentURL, nil
}

// ClearDocumentURL clears the value of the "document_url" field.
func (m *RecentUpdateMutation) ClearDocumentURL() {
	m.document_url = nil
	m.clearedFields[recentupdate.FieldDocumentURL] = struct{}{}
}

// DocumentURLCleared returns if the "document_url" field was cleared in this mutation.
func (m *RecentUpdateMutation) DocumentURLCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldDocumentURL]
	return ok
}

// ResetDocumentURL resets all changes to the "document_url" field.
func (m *RecentUpdateMutation) ResetDocumentURL() {
	m.document_url = nil
	delete(m.clearedFields, recentupdate.FieldDocumentURL)
}

// SetGallery sets the "gallery" field.
func (m *RecentUpdateMutation) SetGallery(s []string) {
	m.gallery = &s
	m.appendgallery = nil
}

// Gallery returns the value of the "gallery" field in the mutation.
func (m *RecentUpdateMutation) Gallery() (r []string, exists bool) {
	v := m.gallery
	if v == nil {
		return
	}
	return *v, true
}

// OldGallery returns the old "gallery" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldGallery(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGallery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGallery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGallery: %w", err)
	}
	return oldValue.Gallery, nil
}

// AppendGallery adds s to the "gallery" field.
func (m *RecentUpdateMutation) AppendGallery(s []string) {
	m.appendgallery = append(m.appendgallery, s...)
}

// AppendedGallery returns the list of values that were appended to the "gallery" field in this mutation.
func (m *RecentUpdateMutation) AppendedGallery() ([]string, bool) {
	if len(m.appendgallery) == 0 {
		return nil, false
	}
	return m.appendgallery, true
}

// ClearGallery clears the value of the "gallery" field.
func (m *RecentUpdateMutation) ClearGallery() {
	m.gallery = nil
	m.appendgallery = nil
	m.clearedFields[recentupdate.FieldGallery] = struct{}{}
}

// GalleryCleared returns if the "gallery" field was cleared in this mutation.
func (m *RecentUpdateMutation) GalleryCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldGallery]
	return ok
}

// ResetGallery resets all changes to the "gallery" field.
func (m *RecentUpdateMutation) ResetGallery() {
	m.gallery = nil
	m.appendgallery = nil
	delete(m.clearedFields, recentupdate.FieldGallery)
}

// SetAttachments sets the "attachments" field.
func (m *RecentUpdateMutation) SetAttachments(value []map[string]interface{}) {
	m.attachments = &value
	m.appendattachments = nil
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *RecentUpdateMutation) Attachments() (r []map[string]interface{}, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldAttachments(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// AppendAttachments adds value to the "attachments" field.
func (m *RecentUpdateMutation) AppendAttachments(value []map[string]interface{}) {
	m.appendattachments = append(m.appendattachments, value...)
}

// AppendedAttachments returns the list of values that were appended to the "attachments" field in this mutation.
func (m *RecentUpdateMutation) AppendedAttachments() ([]map[string]interface{}, bool) {
	if len(m.appendattachments) == 0 {
		return nil, false
	}
	return m.appendattachments, true
}

// ClearAttachments clears the value of the "attachments" field.
func (m *RecentUpdateMutation) ClearAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	m.clearedFields[recentupdate.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *RecentUpdateMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *RecentUpdateMutation) ResetAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	delete(m.clearedFields, recentupdate.FieldAttachments)
}

// SetMediaMetadata sets the "media_metadata" field.
func (m *RecentUpdateMutation) SetMediaMetadata(value map[string]interface{}) {
	m.media_metadata = &value
}

// MediaMetadata returns the value of the "media_metadata" field in the mutation.
func (m *RecentUpdateMutation) MediaMetadata() (r map[string]interface{}, exists bool) {
	v := m.media_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaMetadata returns the old "media_metadata" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldMediaMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaMetadata: %w", err)
	}
	return oldValue.MediaMetadata, nil
}

// ClearMediaMetadata clears the value of the "media_metadata" field.
func (m *RecentUpdateMutation) ClearMediaMetadata() {
	m.media_metadata = nil
	m.clearedFields[recentupdate.FieldMediaMetadata] = struct{}{}
}

// MediaMetadataCleared returns if the "media_metadata" field was cleared in this mutation.
func (m *RecentUpdateMutation) MediaMetadataCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldMediaMetadata]
	return ok
}

// ResetMediaMetadata resets all changes to the "media_metadata" field.
func (m *RecentUpdateMutation) ResetMediaMetadata() {
	m.media_metadata = nil
	delete(m.clearedFields, recentupdate.FieldMediaMetadata)
}

// SetDemoURL sets the "demo_url" field.
func (m *RecentUpdateMutation) SetDemoURL(s string) {
	m.demo_url = &s
}

// DemoURL returns the value of the "demo_url" field in the mutation.
func (m *RecentUpdateMutation) DemoURL() (r string, exists bool) {
	v := m.demo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDemoURL returns the old "demo_url" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldDemoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDemoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDemoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDemoURL: %w", err)
	}
	return oldValue.DemoURL, nil
}

// ClearDemoURL clears the value of the "demo_url" field.
func (m *RecentUpdateMutation) ClearDemoURL() {
	m.demo_url = nil
	m.clearedFields[recentupdate.FieldDemoURL] = struct{}{}
}

// DemoURLCleared returns if the "demo_url" field was cleared in this mutation.
func (m *RecentUpdateMutation) DemoURLCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldDemoURL]
	return ok
}

// ResetDemoURL resets all changes to the "demo_url" field.
func (m *RecentUpdateMutation) ResetDemoURL() {
	m.demo_url = nil
	delete(m.clearedFields, recentupdate.FieldDemoURL)
}

// SetGithubURL sets the "github_url" field.
func (m *RecentUpdateMutation) SetGithubURL(s string) {
	m.github_url = &s
}

// GithubURL returns the value of the "github_url" field in the mutation.
func (m *RecentUpdateMutation) GithubURL() (r string, exists bool) {
	v := m.github_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubURL returns the old "github_url" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldGithubURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubURL: %w", err)
	}
	return oldValue.GithubURL, nil
}

// ClearGithubURL clears the value of the "github_url" field.
func (m *RecentUpdateMutation) ClearGithubURL() {
	m.github_url = nil
	m.clearedFields[recentupdate.FieldGithubURL] = struct{}{}
}

// GithubURLCleared returns if the "github_url" field was cleared in this mutation.
func (m *RecentUpdateMutation) GithubURLCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldGithubURL]
	return ok
}

// ResetGithubURL resets all changes to the "github_url" field.
func (m *RecentUpdateMutation) ResetGithubURL() {
	m.github_url = nil
	delete(m.clearedFields, recentupdate.FieldGithubURL)
}

// SetExternalURL sets the "external_url" field.
func (m *RecentUpdateMutation) SetExternalURL(s string) {
	m.external_url = &s
}

// ExternalURL returns the value of the "external_url" field in the mutation.
func (m *RecentUpdateMutation) ExternalURL() (r string, exists bool) {
	v := m.external_url
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalURL returns the old "external_url" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldExternalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalURL: %w", err)
	}
	return oldValue.ExternalURL, nil
}

// ClearExternalURL clears the value of the "external_url" field.
func (m *RecentUpdateMutation) ClearExternalURL() {
	m.external_url = nil
	m.clearedFields[recentupdate.FieldExternalURL] = struct{}{}
}

// ExternalURLCleared returns if the "external_url" field was cleared in this mutation.
func (m *RecentUpdateMutation) ExternalURLCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldExternalURL]
	return ok
}

// ResetExternalURL resets all changes to the "external_url" field.
func (m *RecentUpdateMutation) ResetExternalURL() {
	m.external_url = nil
	delete(m.clearedFields, recentupdate.FieldExternalURL)
}

// SetSocialLinks sets the "social_links" field.
func (m *RecentUpdateMutation) SetSocialLinks(value []map[string]interface{}) {
	m.social_links = &value
	m.appendsocial_links = nil
}

// SocialLinks returns the value of the "social_links" field in the mutation.
func (m *RecentUpdateMutation) SocialLinks() (r []map[string]interface{}, exists bool) {
	v := m.social_links
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialLinks returns the old "social_links" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldSocialLinks(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialLinks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialLinks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialLinks: %w", err)
	}
	return oldValue.SocialLinks, nil
}

// AppendSocialLinks adds value to the "social_links" field.
func (m *RecentUpdateMutation) AppendSocialLinks(value []map[string]interface{}) {
	m.appendsocial_links = append(m.appendsocial_links, value...)
}

// AppendedSocialLinks returns the list of values that were appended to the "social_links" field in this mutation.
func (m *RecentUpdateMutation) AppendedSocialLinks() ([]map[string]interface{}, bool) {
	if len(m.appendsocial_links) == 0 {
		return nil, false
	}
	return m.appendsocial_links, true
}

// ClearSocialLinks clears the value of the "social_links" field.
func (m *RecentUpdateMutation) ClearSocialLinks() {
	m.social_links = nil
	m.appendsocial_links = nil
	m.clearedFields[recentupdate.FieldSocialLinks] = struct{}{}
}

// SocialLinksCleared returns if the "social_links" field was cleared in this mutation.
func (m *RecentUpdateMutation) SocialLinksCleared() bool {
	_, ok := m.clearedFields[recentupdate.FieldSocialLinks]
	return ok
}

// ResetSocialLinks resets all changes to the "social_links" field.
func (m *RecentUpdateMutation) ResetSocialLinks() {
	m.social_links = nil
	m.appendsocial_links = nil
	delete(m.clearedFields, recentupdate.FieldSocialLinks)
}

// SetSortOrder sets the "sort_order" field.
func (m *RecentUpdateMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *RecentUpdateMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *RecentUpdateMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *RecentUpdateMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *RecentUpdateMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecentUpdateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecentUpdateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecentUpdateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RecentUpdateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RecentUpdateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RecentUpdate entity.
// If the RecentUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RecentUpdateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RecentUpdateMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[recentupdate.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RecentUpdateMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RecentUpdateMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RecentUpdateMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the RecentUpdateTranslation entity by ids.
func (m *RecentUpdateMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the RecentUpdateTranslation entity.
func (m *RecentUpdateMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the RecentUpdateTranslation entity was cleared.
func (m *RecentUpdateMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the RecentUpdateTranslation entity by IDs.
func (m *RecentUpdateMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the RecentUpdateTranslation entity.
func (m *RecentUpdateMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *RecentUpdateMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *RecentUpdateMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the RecentUpdateMutation builder.
func (m *RecentUpdateMutation) Where(ps ...predicate.RecentUpdate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecentUpdateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecentUpdateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecentUpdate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecentUpdateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecentUpdateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecentUpdate).
func (m *RecentUpdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecentUpdateMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.user != nil {
		fields = append(fields, recentupdate.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, recentupdate.FieldType)
	}
	if m.title != nil {
		fields = append(fields, recentupdate.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, recentupdate.FieldDescription)
	}
	if m.date != nil {
		fields = append(fields, recentupdate.FieldDate)
	}
	if m.tags != nil {
		fields = append(fields, recentupdate.FieldTags)
	}
	if m.status != nil {
		fields = append(fields, recentupdate.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, recentupdate.FieldPriority)
	}
	if m.external_id != nil {
		fields = append(fields, recentupdate.FieldExternalID)
	}
	if m.image_url != nil {
		fields = append(fields, recentupdate.FieldImageURL)
	}
	if m.video_url != nil {
		fields = append(fields, recentupdate.FieldVideoURL)
	}
	if m.document_url != nil {
		fields = append(fields, recentupdate.FieldDocumentURL)
	}
	if m.gallery != nil {
		fields = append(fields, recentupdate.FieldGallery)
	}
	if m.attachments != nil {
		fields = append(fields, recentupdate.FieldAttachments)
	}
	if m.media_metadata != nil {
		fields = append(fields, recentupdate.FieldMediaMetadata)
	}
	if m.demo_url != nil {
		fields = append(fields, recentupdate.FieldDemoURL)
	}
	if m.github_url != nil {
		fields = append(fields, recentupdate.FieldGithubURL)
	}
	if m.external_url != nil {
		fields = append(fields, recentupdate.FieldExternalURL)
	}
	if m.social_links != nil {
		fields = append(fields, recentupdate.FieldSocialLinks)
	}
	if m.sort_order != nil {
		fields = append(fields, recentupdate.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, recentupdate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, recentupdate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecentUpdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recentupdate.FieldUserID:
		return m.UserID()
	case recentupdate.FieldType:
		return m.GetType()
	case recentupdate.FieldTitle:
		return m.Title()
	case recentupdate.FieldDescription:
		return m.Description()
	case recentupdate.FieldDate:
		return m.Date()
	case recentupdate.FieldTags:
		return m.Tags()
	case recentupdate.FieldStatus:
		return m.Status()
	case recentupdate.FieldPriority:
		return m.Priority()
	case recentupdate.FieldExternalID:
		return m.ExternalID()
	case recentupdate.FieldImageURL:
		return m.ImageURL()
	case recentupdate.FieldVideoURL:
		return m.VideoURL()
	case recentupdate.FieldDocumentURL:
		return m.DocumentURL()
	case recentupdate.FieldGallery:
		return m.Gallery()
	case recentupdate.FieldAttachments:
		return m.Attachments()
	case recentupdate.FieldMediaMetadata:
		return m.MediaMetadata()
	case recentupdate.FieldDemoURL:
		return m.DemoURL()
	case recentupdate.FieldGithubURL:
		return m.GithubURL()
	case recentupdate.FieldExternalURL:
		return m.ExternalURL()
	case recentupdate.FieldSocialLinks:
		return m.SocialLinks()
	case recentupdate.FieldSortOrder:
		return m.SortOrder()
	case recentupdate.FieldCreatedAt:
		return m.CreatedAt()
	case recentupdate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecentUpdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recentupdate.FieldUserID:
		return m.OldUserID(ctx)
	case recentupdate.FieldType:
		return m.OldType(ctx)
	case recentupdate.FieldTitle:
		return m.OldTitle(ctx)
	case recentupdate.FieldDescription:
		return m.OldDescription(ctx)
	case recentupdate.FieldDate:
		return m.OldDate(ctx)
	case recentupdate.FieldTags:
		return m.OldTags(ctx)
	case recentupdate.FieldStatus:
		return m.OldStatus(ctx)
	case recentupdate.FieldPriority:
		return m.OldPriority(ctx)
	case recentupdate.FieldExternalID:
		return m.OldExternalID(ctx)
	case recentupdate.FieldImageURL:
		return m.OldImageURL(ctx)
	case recentupdate.FieldVideoURL:
		return m.OldVideoURL(ctx)
	case recentupdate.FieldDocumentURL:
		return m.OldDocumentURL(ctx)
	case recentupdate.FieldGallery:
		return m.OldGallery(ctx)
	case recentupdate.FieldAttachments:
		return m.OldAttachments(ctx)
	case recentupdate.FieldMediaMetadata:
		return m.OldMediaMetadata(ctx)
	case recentupdate.FieldDemoURL:
		return m.OldDemoURL(ctx)
	case recentupdate.FieldGithubURL:
		return m.OldGithubURL(ctx)
	case recentupdate.FieldExternalURL:
		return m.OldExternalURL(ctx)
	case recentupdate.FieldSocialLinks:
		return m.OldSocialLinks(ctx)
	case recentupdate.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case recentupdate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case recentupdate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecentUpdate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentUpdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recentupdate.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case recentupdate.FieldType:
		v, ok := value.(recentupdate.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case recentupdate.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case recentupdate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case recentupdate.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case recentupdate.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case recentupdate.FieldStatus:
		v, ok := value.(recentupdate.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case recentupdate.FieldPriority:
		v, ok := value.(recentupdate.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case recentupdate.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case recentupdate.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case recentupdate.FieldVideoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoURL(v)
		return nil
	case recentupdate.FieldDocumentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentURL(v)
		return nil
	case recentupdate.FieldGallery:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGallery(v)
		return nil
	case recentupdate.FieldAttachments:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case recentupdate.FieldMediaMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaMetadata(v)
		return nil
	case recentupdate.FieldDemoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDemoURL(v)
		return nil
	case recentupdate.FieldGithubURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubURL(v)
		return nil
	case recentupdate.FieldExternalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalURL(v)
		return nil
	case recentupdate.FieldSocialLinks:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialLinks(v)
		return nil
	case recentupdate.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case recentupdate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case recentupdate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecentUpdate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecentUpdateMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, recentupdate.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecentUpdateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case recentupdate.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentUpdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case recentupdate.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown RecentUpdate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecentUpdateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(recentupdate.FieldTags) {
		fields = append(fields, recentupdate.FieldTags)
	}
	if m.FieldCleared(recentupdate.FieldExternalID) {
		fields = append(fields, recentupdate.FieldExternalID)
	}
	if m.FieldCleared(recentupdate.FieldImageURL) {
		fields = append(fields, recentupdate.FieldImageURL)
	}
	if m.FieldCleared(recentupdate.FieldVideoURL) {
		fields = append(fields, recentupdate.FieldVideoURL)
	}
	if m.FieldCleared(recentupdate.FieldDocumentURL) {
		fields = append(fields, recentupdate.FieldDocumentURL)
	}
	if m.FieldCleared(recentupdate.FieldGallery) {
		fields = append(fields, recentupdate.FieldGallery)
	}
	if m.FieldCleared(recentupdate.FieldAttachments) {
		fields = append(fields, recentupdate.FieldAttachments)
	}
	if m.FieldCleared(recentupdate.FieldMediaMetadata) {
		fields = append(fields, recentupdate.FieldMediaMetadata)
	}
	if m.FieldCleared(recentupdate.FieldDemoURL) {
		fields = append(fields, recentupdate.FieldDemoURL)
	}
	if m.FieldCleared(recentupdate.FieldGithubURL) {
		fields = append(fields, recentupdate.FieldGithubURL)
	}
	if m.FieldCleared(recentupdate.FieldExternalURL) {
		fields = append(fields, recentupdate.FieldExternalURL)
	}
	if m.FieldCleared(recentupdate.FieldSocialLinks) {
		fields = append(fields, recentupdate.FieldSocialLinks)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecentUpdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecentUpdateMutation) ClearField(name string) error {
	switch name {
	case recentupdate.FieldTags:
		m.ClearTags()
		return nil
	case recentupdate.FieldExternalID:
		m.ClearExternalID()
		return nil
	case recentupdate.FieldImageURL:
		m.ClearImageURL()
		return nil
	case recentupdate.FieldVideoURL:
		m.ClearVideoURL()
		return nil
	case recentupdate.FieldDocumentURL:
		m.ClearDocumentURL()
		return nil
	case recentupdate.FieldGallery:
		m.ClearGallery()
		return nil
	case recentupdate.FieldAttachments:
		m.ClearAttachments()
		return nil
	case recentupdate.FieldMediaMetadata:
		m.ClearMediaMetadata()
		return nil
	case recentupdate.FieldDemoURL:
		m.ClearDemoURL()
		return nil
	case recentupdate.FieldGithubURL:
		m.ClearGithubURL()
		return nil
	case recentupdate.FieldExternalURL:
		m.ClearExternalURL()
		return nil
	case recentupdate.FieldSocialLinks:
		m.ClearSocialLinks()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecentUpdateMutation) ResetField(name string) error {
	switch name {
	case recentupdate.FieldUserID:
		m.ResetUserID()
		return nil
	case recentupdate.FieldType:
		m.ResetType()
		return nil
	case recentupdate.FieldTitle:
		m.ResetTitle()
		return nil
	case recentupdate.FieldDescription:
		m.ResetDescription()
		return nil
	case recentupdate.FieldDate:
		m.ResetDate()
		return nil
	case recentupdate.FieldTags:
		m.ResetTags()
		return nil
	case recentupdate.FieldStatus:
		m.ResetStatus()
		return nil
	case recentupdate.FieldPriority:
		m.ResetPriority()
		return nil
	case recentupdate.FieldExternalID:
		m.ResetExternalID()
		return nil
	case recentupdate.FieldImageURL:
		m.ResetImageURL()
		return nil
	case recentupdate.FieldVideoURL:
		m.ResetVideoURL()
		return nil
	case recentupdate.FieldDocumentURL:
		m.ResetDocumentURL()
		return nil
	case recentupdate.FieldGallery:
		m.ResetGallery()
		return nil
	case recentupdate.FieldAttachments:
		m.ResetAttachments()
		return nil
	case recentupdate.FieldMediaMetadata:
		m.ResetMediaMetadata()
		return nil
	case recentupdate.FieldDemoURL:
		m.ResetDemoURL()
		return nil
	case recentupdate.FieldGithubURL:
		m.ResetGithubURL()
		return nil
	case recentupdate.FieldExternalURL:
		m.ResetExternalURL()
		return nil
	case recentupdate.FieldSocialLinks:
		m.ResetSocialLinks()
		return nil
	case recentupdate.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case recentupdate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case recentupdate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecentUpdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, recentupdate.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, recentupdate.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecentUpdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recentupdate.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case recentupdate.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecentUpdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, recentupdate.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecentUpdateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case recentupdate.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecentUpdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, recentupdate.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, recentupdate.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecentUpdateMutation) EdgeCleared(name string) bool {
	switch name {
	case recentupdate.EdgeUser:
		return m.cleareduser
	case recentupdate.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecentUpdateMutation) ClearEdge(name string) error {
	switch name {
	case recentupdate.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecentUpdateMutation) ResetEdge(name string) error {
	switch name {
	case recentupdate.EdgeUser:
		m.ResetUser()
		return nil
	case recentupdate.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdate edge %s", name)
}

// RecentUpdateTranslationMutation represents an operation that mutates the RecentUpdateTranslation nodes in the graph.
type RecentUpdateTranslationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	title                *string
	description          *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	recent_update        *uuid.UUID
	clearedrecent_update bool
	language             *string
	clearedlanguage      bool
	done                 bool
	oldValue             func(context.Context) (*RecentUpdateTranslation, error)
	predicates           []predicate.RecentUpdateTranslation
}

var _ ent.Mutation = (*RecentUpdateTranslationMutation)(nil)

// recentupdatetranslationOption allows management of the mutation configuration using functional options.
type recentupdatetranslationOption func(*RecentUpdateTranslationMutation)

// newRecentUpdateTranslationMutation creates new mutation for the RecentUpdateTranslation entity.
func newRecentUpdateTranslationMutation(c config, op Op, opts ...recentupdatetranslationOption) *RecentUpdateTranslationMutation {
	m := &RecentUpdateTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeRecentUpdateTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecentUpdateTranslationID sets the ID field of the mutation.
func withRecentUpdateTranslationID(id uuid.UUID) recentupdatetranslationOption {
	return func(m *RecentUpdateTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *RecentUpdateTranslation
		)
		m.oldValue = func(ctx context.Context) (*RecentUpdateTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecentUpdateTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecentUpdateTranslation sets the old RecentUpdateTranslation of the mutation.
func withRecentUpdateTranslation(node *RecentUpdateTranslation) recentupdatetranslationOption {
	return func(m *RecentUpdateTranslationMutation) {
		m.oldValue = func(context.Context) (*RecentUpdateTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecentUpdateTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecentUpdateTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RecentUpdateTranslation entities.
func (m *RecentUpdateTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecentUpdateTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecentUpdateTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecentUpdateTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecentUpdateID sets the "recent_update_id" field.
func (m *RecentUpdateTranslationMutation) SetRecentUpdateID(u uuid.UUID) {
	m.recent_update = &u
}

// RecentUpdateID returns the value of the "recent_update_id" field in the mutation.
func (m *RecentUpdateTranslationMutation) RecentUpdateID() (r uuid.UUID, exists bool) {
	v := m.recent_update
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentUpdateID returns the old "recent_update_id" field's value of the RecentUpdateTranslation entity.
// If the RecentUpdateTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateTranslationMutation) OldRecentUpdateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentUpdateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentUpdateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentUpdateID: %w", err)
	}
	return oldValue.RecentUpdateID, nil
}

// ResetRecentUpdateID resets all changes to the "recent_update_id" field.
func (m *RecentUpdateTranslationMutation) ResetRecentUpdateID() {
	m.recent_update = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *RecentUpdateTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *RecentUpdateTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the RecentUpdateTranslation entity.
// If the RecentUpdateTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *RecentUpdateTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *RecentUpdateTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RecentUpdateTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the RecentUpdateTranslation entity.
// If the RecentUpdateTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RecentUpdateTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *RecentUpdateTranslationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RecentUpdateTranslationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RecentUpdateTranslation entity.
// If the RecentUpdateTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateTranslationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RecentUpdateTranslationMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecentUpdateTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecentUpdateTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecentUpdateTranslation entity.
// If the RecentUpdateTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentUpdateTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecentUpdateTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearRecentUpdate clears the "recent_update" edge to the RecentUpdate entity.
func (m *RecentUpdateTranslationMutation) ClearRecentUpdate() {
	m.clearedrecent_update = true
	m.clearedFields[recentupdatetranslation.FieldRecentUpdateID] = struct{}{}
}

// RecentUpdateCleared reports if the "recent_update" edge to the RecentUpdate entity was cleared.
func (m *RecentUpdateTranslationMutation) RecentUpdateCleared() bool {
	return m.clearedrecent_update
}

// RecentUpdateIDs returns the "recent_update" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecentUpdateID instead. It exists only for internal usage by the builders.
func (m *RecentUpdateTranslationMutation) RecentUpdateIDs() (ids []uuid.UUID) {
	if id := m.recent_update; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecentUpdate resets all changes to the "recent_update" edge.
func (m *RecentUpdateTranslationMutation) ResetRecentUpdate() {
	m.recent_update = nil
	m.clearedrecent_update = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *RecentUpdateTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *RecentUpdateTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[recentupdatetranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *RecentUpdateTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *RecentUpdateTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *RecentUpdateTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *RecentUpdateTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the RecentUpdateTranslationMutation builder.
func (m *RecentUpdateTranslationMutation) Where(ps ...predicate.RecentUpdateTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecentUpdateTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecentUpdateTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecentUpdateTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecentUpdateTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecentUpdateTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecentUpdateTranslation).
func (m *RecentUpdateTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecentUpdateTranslationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.recent_update != nil {
		fields = append(fields, recentupdatetranslation.FieldRecentUpdateID)
	}
	if m.language != nil {
		fields = append(fields, recentupdatetranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, recentupdatetranslation.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, recentupdatetranslation.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, recentupdatetranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecentUpdateTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recentupdatetranslation.FieldRecentUpdateID:
		return m.RecentUpdateID()
	case recentupdatetranslation.FieldLanguageCode:
		return m.LanguageCode()
	case recentupdatetranslation.FieldTitle:
		return m.Title()
	case recentupdatetranslation.FieldDescription:
		return m.Description()
	case recentupdatetranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecentUpdateTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recentupdatetranslation.FieldRecentUpdateID:
		return m.OldRecentUpdateID(ctx)
	case recentupdatetranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case recentupdatetranslation.FieldTitle:
		return m.OldTitle(ctx)
	case recentupdatetranslation.FieldDescription:
		return m.OldDescription(ctx)
	case recentupdatetranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecentUpdateTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentUpdateTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recentupdatetranslation.FieldRecentUpdateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentUpdateID(v)
		return nil
	case recentupdatetranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case recentupdatetranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case recentupdatetranslation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case recentupdatetranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecentUpdateTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecentUpdateTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecentUpdateTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentUpdateTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecentUpdateTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecentUpdateTranslationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecentUpdateTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecentUpdateTranslationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecentUpdateTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecentUpdateTranslationMutation) ResetField(name string) error {
	switch name {
	case recentupdatetranslation.FieldRecentUpdateID:
		m.ResetRecentUpdateID()
		return nil
	case recentupdatetranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case recentupdatetranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case recentupdatetranslation.FieldDescription:
		m.ResetDescription()
		return nil
	case recentupdatetranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdateTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecentUpdateTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.recent_update != nil {
		edges = append(edges, recentupdatetranslation.EdgeRecentUpdate)
	}
	if m.language != nil {
		edges = append(edges, recentupdatetranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecentUpdateTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case recentupdatetranslation.EdgeRecentUpdate:
		if id := m.recent_update; id != nil {
			return []ent.Value{*id}
		}
	case recentupdatetranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecentUpdateTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecentUpdateTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecentUpdateTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrecent_update {
		edges = append(edges, recentupdatetranslation.EdgeRecentUpdate)
	}
	if m.clearedlanguage {
		edges = append(edges, recentupdatetranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecentUpdateTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case recentupdatetranslation.EdgeRecentUpdate:
		return m.clearedrecent_update
	case recentupdatetranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecentUpdateTranslationMutation) ClearEdge(name string) error {
	switch name {
	case recentupdatetranslation.EdgeRecentUpdate:
		m.ClearRecentUpdate()
		return nil
	case recentupdatetranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdateTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecentUpdateTranslationMutation) ResetEdge(name string) error {
	switch name {
	case recentupdatetranslation.EdgeRecentUpdate:
		m.ResetRecentUpdate()
		return nil
	case recentupdatetranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown RecentUpdateTranslation edge %s", name)
}

// ResearchProjectMutation represents an operation that mutates the ResearchProject nodes in the graph.
type ResearchProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	title               *string
	start_date          *time.Time
	end_date            *time.Time
	is_ongoing          *bool
	location            *string
	research_type       *string
	funding_source      *string
	funding_amount      *float64
	addfunding_amount   *float64
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	details             map[uuid.UUID]struct{}
	removeddetails      map[uuid.UUID]struct{}
	cleareddetails      bool
	done                bool
	oldValue            func(context.Context) (*ResearchProject, error)
	predicates          []predicate.ResearchProject
}

var _ ent.Mutation = (*ResearchProjectMutation)(nil)

// researchprojectOption allows management of the mutation configuration using functional options.
type researchprojectOption func(*ResearchProjectMutation)

// newResearchProjectMutation creates new mutation for the ResearchProject entity.
func newResearchProjectMutation(c config, op Op, opts ...researchprojectOption) *ResearchProjectMutation {
	m := &ResearchProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeResearchProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchProjectID sets the ID field of the mutation.
func withResearchProjectID(id uuid.UUID) researchprojectOption {
	return func(m *ResearchProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *ResearchProject
		)
		m.oldValue = func(ctx context.Context) (*ResearchProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResearchProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearchProject sets the old ResearchProject of the mutation.
func withResearchProject(node *ResearchProject) researchprojectOption {
	return func(m *ResearchProjectMutation) {
		m.oldValue = func(context.Context) (*ResearchProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResearchProject entities.
func (m *ResearchProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResearchProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResearchProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResearchProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ResearchProjectMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ResearchProjectMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ResearchProjectMutation) ResetUserID() {
	m.user = nil
}

// SetTitle sets the "title" field.
func (m *ResearchProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResearchProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ResearchProjectMutation) ResetTitle() {
	m.title = nil
}

// SetStartDate sets the "start_date" field.
func (m *ResearchProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResearchProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResearchProjectMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[researchproject.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResearchProjectMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResearchProjectMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, researchproject.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResearchProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResearchProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResearchProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[researchproject.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResearchProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResearchProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, researchproject.FieldEndDate)
}

// SetIsOngoing sets the "is_ongoing" field.
func (m *ResearchProjectMutation) SetIsOngoing(b bool) {
	m.is_ongoing = &b
}

// IsOngoing returns the value of the "is_ongoing" field in the mutation.
func (m *ResearchProjectMutation) IsOngoing() (r bool, exists bool) {
	v := m.is_ongoing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOngoing returns the old "is_ongoing" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldIsOngoing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOngoing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOngoing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOngoing: %w", err)
	}
	return oldValue.IsOngoing, nil
}

// ResetIsOngoing resets all changes to the "is_ongoing" field.
func (m *ResearchProjectMutation) ResetIsOngoing() {
	m.is_ongoing = nil
}

// SetLocation sets the "location" field.
func (m *ResearchProjectMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ResearchProjectMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ResearchProjectMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[researchproject.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ResearchProjectMutation) LocationCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ResearchProjectMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, researchproject.FieldLocation)
}

// SetResearchType sets the "research_type" field.
func (m *ResearchProjectMutation) SetResearchType(s string) {
	m.research_type = &s
}

// ResearchType returns the value of the "research_type" field in the mutation.
func (m *ResearchProjectMutation) ResearchType() (r string, exists bool) {
	v := m.research_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResearchType returns the old "research_type" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldResearchType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResearchType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResearchType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResearchType: %w", err)
	}
	return oldValue.ResearchType, nil
}

// ClearResearchType clears the value of the "research_type" field.
func (m *ResearchProjectMutation) ClearResearchType() {
	m.research_type = nil
	m.clearedFields[researchproject.FieldResearchType] = struct{}{}
}

// ResearchTypeCleared returns if the "research_type" field was cleared in this mutation.
func (m *ResearchProjectMutation) ResearchTypeCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldResearchType]
	return ok
}

// ResetResearchType resets all changes to the "research_type" field.
func (m *ResearchProjectMutation) ResetResearchType() {
	m.research_type = nil
	delete(m.clearedFields, researchproject.FieldResearchType)
}

// SetFundingSource sets the "funding_source" field.
func (m *ResearchProjectMutation) SetFundingSource(s string) {
	m.funding_source = &s
}

// FundingSource returns the value of the "funding_source" field in the mutation.
func (m *ResearchProjectMutation) FundingSource() (r string, exists bool) {
	v := m.funding_source
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingSource returns the old "funding_source" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldFundingSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingSource: %w", err)
	}
	return oldValue.FundingSource, nil
}

// ClearFundingSource clears the value of the "funding_source" field.
func (m *ResearchProjectMutation) ClearFundingSource() {
	m.funding_source = nil
	m.clearedFields[researchproject.FieldFundingSource] = struct{}{}
}

// FundingSourceCleared returns if the "funding_source" field was cleared in this mutation.
func (m *ResearchProjectMutation) FundingSourceCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldFundingSource]
	return ok
}

// ResetFundingSource resets all changes to the "funding_source" field.
func (m *ResearchProjectMutation) ResetFundingSource() {
	m.funding_source = nil
	delete(m.clearedFields, researchproject.FieldFundingSource)
}

// SetFundingAmount sets the "funding_amount" field.
func (m *ResearchProjectMutation) SetFundingAmount(f float64) {
	m.funding_amount = &f
	m.addfunding_amount = nil
}

// FundingAmount returns the value of the "funding_amount" field in the mutation.
func (m *ResearchProjectMutation) FundingAmount() (r float64, exists bool) {
	v := m.funding_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingAmount returns the old "funding_amount" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldFundingAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingAmount: %w", err)
	}
	return oldValue.FundingAmount, nil
}

// AddFundingAmount adds f to the "funding_amount" field.
func (m *ResearchProjectMutation) AddFundingAmount(f float64) {
	if m.addfunding_amount != nil {
		*m.addfunding_amount += f
	} else {
		m.addfunding_amount = &f
	}
}

// AddedFundingAmount returns the value that was added to the "funding_amount" field in this mutation.
func (m *ResearchProjectMutation) AddedFundingAmount() (r float64, exists bool) {
	v := m.addfunding_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFundingAmount clears the value of the "funding_amount" field.
func (m *ResearchProjectMutation) ClearFundingAmount() {
	m.funding_amount = nil
	m.addfunding_amount = nil
	m.clearedFields[researchproject.FieldFundingAmount] = struct{}{}
}

// FundingAmountCleared returns if the "funding_amount" field was cleared in this mutation.
func (m *ResearchProjectMutation) FundingAmountCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldFundingAmount]
	return ok
}

// ResetFundingAmount resets all changes to the "funding_amount" field.
func (m *ResearchProjectMutation) ResetFundingAmount() {
	m.funding_amount = nil
	m.addfunding_amount = nil
	delete(m.clearedFields, researchproject.FieldFundingAmount)
}

// SetSortOrder sets the "sort_order" field.
func (m *ResearchProjectMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ResearchProjectMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ResearchProjectMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ResearchProjectMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ResearchProjectMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResearchProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResearchProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResearchProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResearchProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResearchProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResearchProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *ResearchProjectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[researchproject.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ResearchProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ResearchProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the ResearchProjectTranslation entity by ids.
func (m *ResearchProjectMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the ResearchProjectTranslation entity.
func (m *ResearchProjectMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the ResearchProjectTranslation entity was cleared.
func (m *ResearchProjectMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the ResearchProjectTranslation entity by IDs.
func (m *ResearchProjectMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the ResearchProjectTranslation entity.
func (m *ResearchProjectMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *ResearchProjectMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *ResearchProjectMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddDetailIDs adds the "details" edge to the ResearchProjectDetail entity by ids.
func (m *ResearchProjectMutation) AddDetailIDs(ids ...uuid.UUID) {
	if m.details == nil {
		m.details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the ResearchProjectDetail entity.
func (m *ResearchProjectMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the ResearchProjectDetail entity was cleared.
func (m *ResearchProjectMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the ResearchProjectDetail entity by IDs.
func (m *ResearchProjectMutation) RemoveDetailIDs(ids ...uuid.UUID) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the ResearchProjectDetail entity.
func (m *ResearchProjectMutation) RemovedDetailsIDs() (ids []uuid.UUID) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *ResearchProjectMutation) DetailsIDs() (ids []uuid.UUID) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *ResearchProjectMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// Where appends a list predicates to the ResearchProjectMutation builder.
func (m *ResearchProjectMutation) Where(ps ...predicate.ResearchProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResearchProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResearchProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResearchProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResearchProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResearchProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResearchProject).
func (m *ResearchProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResearchProjectMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, researchproject.FieldUserID)
	}
	if m.title != nil {
		fields = append(fields, researchproject.FieldTitle)
	}
	if m.start_date != nil {
		fields = append(fields, researchproject.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, researchproject.FieldEndDate)
	}
	if m.is_ongoing != nil {
		fields = append(fields, researchproject.FieldIsOngoing)
	}
	if m.location != nil {
		fields = append(fields, researchproject.FieldLocation)
	}
	if m.research_type != nil {
		fields = append(fields, researchproject.FieldResearchType)
	}
	if m.funding_source != nil {
		fields = append(fields, researchproject.FieldFundingSource)
	}
	if m.funding_amount != nil {
		fields = append(fields, researchproject.FieldFundingAmount)
	}
	if m.sort_order != nil {
		fields = append(fields, researchproject.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, researchproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, researchproject.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResearchProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case researchproject.FieldUserID:
		return m.UserID()
	case researchproject.FieldTitle:
		return m.Title()
	case researchproject.FieldStartDate:
		return m.StartDate()
	case researchproject.FieldEndDate:
		return m.EndDate()
	case researchproject.FieldIsOngoing:
		return m.IsOngoing()
	case researchproject.FieldLocation:
		return m.Location()
	case researchproject.FieldResearchType:
		return m.ResearchType()
	case researchproject.FieldFundingSource:
		return m.FundingSource()
	case researchproject.FieldFundingAmount:
		return m.FundingAmount()
	case researchproject.FieldSortOrder:
		return m.SortOrder()
	case researchproject.FieldCreatedAt:
		return m.CreatedAt()
	case researchproject.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResearchProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case researchproject.FieldUserID:
		return m.OldUserID(ctx)
	case researchproject.FieldTitle:
		return m.OldTitle(ctx)
	case researchproject.FieldStartDate:
		return m.OldStartDate(ctx)
	case researchproject.FieldEndDate:
		return m.OldEndDate(ctx)
	case researchproject.FieldIsOngoing:
		return m.OldIsOngoing(ctx)
	case researchproject.FieldLocation:
		return m.OldLocation(ctx)
	case researchproject.FieldResearchType:
		return m.OldResearchType(ctx)
	case researchproject.FieldFundingSource:
		return m.OldFundingSource(ctx)
	case researchproject.FieldFundingAmount:
		return m.OldFundingAmount(ctx)
	case researchproject.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case researchproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case researchproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResearchProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case researchproject.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case researchproject.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case researchproject.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case researchproject.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case researchproject.FieldIsOngoing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOngoing(v)
		return nil
	case researchproject.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case researchproject.FieldResearchType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchType(v)
		return nil
	case researchproject.FieldFundingSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingSource(v)
		return nil
	case researchproject.FieldFundingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingAmount(v)
		return nil
	case researchproject.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case researchproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case researchproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResearchProjectMutation) AddedFields() []string {
	var fields []string
	if m.addfunding_amount != nil {
		fields = append(fields, researchproject.FieldFundingAmount)
	}
	if m.addsort_order != nil {
		fields = append(fields, researchproject.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResearchProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case researchproject.FieldFundingAmount:
		return m.AddedFundingAmount()
	case researchproject.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case researchproject.FieldFundingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFundingAmount(v)
		return nil
	case researchproject.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResearchProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(researchproject.FieldStartDate) {
		fields = append(fields, researchproject.FieldStartDate)
	}
	if m.FieldCleared(researchproject.FieldEndDate) {
		fields = append(fields, researchproject.FieldEndDate)
	}
	if m.FieldCleared(researchproject.FieldLocation) {
		fields = append(fields, researchproject.FieldLocation)
	}
	if m.FieldCleared(researchproject.FieldResearchType) {
		fields = append(fields, researchproject.FieldResearchType)
	}
	if m.FieldCleared(researchproject.FieldFundingSource) {
		fields = append(fields, researchproject.FieldFundingSource)
	}
	if m.FieldCleared(researchproject.FieldFundingAmount) {
		fields = append(fields, researchproject.FieldFundingAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResearchProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchProjectMutation) ClearField(name string) error {
	switch name {
	case researchproject.FieldStartDate:
		m.ClearStartDate()
		return nil
	case researchproject.FieldEndDate:
		m.ClearEndDate()
		return nil
	case researchproject.FieldLocation:
		m.ClearLocation()
		return nil
	case researchproject.FieldResearchType:
		m.ClearResearchType()
		return nil
	case researchproject.FieldFundingSource:
		m.ClearFundingSource()
		return nil
	case researchproject.FieldFundingAmount:
		m.ClearFundingAmount()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResearchProjectMutation) ResetField(name string) error {
	switch name {
	case researchproject.FieldUserID:
		m.ResetUserID()
		return nil
	case researchproject.FieldTitle:
		m.ResetTitle()
		return nil
	case researchproject.FieldStartDate:
		m.ResetStartDate()
		return nil
	case researchproject.FieldEndDate:
		m.ResetEndDate()
		return nil
	case researchproject.FieldIsOngoing:
		m.ResetIsOngoing()
		return nil
	case researchproject.FieldLocation:
		m.ResetLocation()
		return nil
	case researchproject.FieldResearchType:
		m.ResetResearchType()
		return nil
	case researchproject.FieldFundingSource:
		m.ResetFundingSource()
		return nil
	case researchproject.FieldFundingAmount:
		m.ResetFundingAmount()
		return nil
	case researchproject.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case researchproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case researchproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResearchProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, researchproject.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, researchproject.EdgeTranslations)
	}
	if m.details != nil {
		edges = append(edges, researchproject.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResearchProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case researchproject.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case researchproject.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case researchproject.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResearchProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtranslations != nil {
		edges = append(edges, researchproject.EdgeTranslations)
	}
	if m.removeddetails != nil {
		edges = append(edges, researchproject.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResearchProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case researchproject.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case researchproject.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResearchProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, researchproject.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, researchproject.EdgeTranslations)
	}
	if m.cleareddetails {
		edges = append(edges, researchproject.EdgeDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResearchProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case researchproject.EdgeUser:
		return m.cleareduser
	case researchproject.EdgeTranslations:
		return m.clearedtranslations
	case researchproject.EdgeDetails:
		return m.cleareddetails
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResearchProjectMutation) ClearEdge(name string) error {
	switch name {
	case researchproject.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResearchProjectMutation) ResetEdge(name string) error {
	switch name {
	case researchproject.EdgeUser:
		m.ResetUser()
		return nil
	case researchproject.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case researchproject.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject edge %s", name)
}

// ResearchProjectDetailMutation represents an operation that mutates the ResearchProjectDetail nodes in the graph.
type ResearchProjectDetailMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	detail_text             *string
	sort_order              *int
	addsort_order           *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	research_project        *uuid.UUID
	clearedresearch_project bool
	translations            map[uuid.UUID]struct{}
	removedtranslations     map[uuid.UUID]struct{}
	clearedtranslations     bool
	done                    bool
	oldValue                func(context.Context) (*ResearchProjectDetail, error)
	predicates              []predicate.ResearchProjectDetail
}

var _ ent.Mutation = (*ResearchProjectDetailMutation)(nil)

// researchprojectdetailOption allows management of the mutation configuration using functional options.
type researchprojectdetailOption func(*ResearchProjectDetailMutation)

// newResearchProjectDetailMutation creates new mutation for the ResearchProjectDetail entity.
func newResearchProjectDetailMutation(c config, op Op, opts ...researchprojectdetailOption) *ResearchProjectDetailMutation {
	m := &ResearchProjectDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeResearchProjectDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchProjectDetailID sets the ID field of the mutation.
func withResearchProjectDetailID(id uuid.UUID) researchprojectdetailOption {
	return func(m *ResearchProjectDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *ResearchProjectDetail
		)
		m.oldValue = func(ctx context.Context) (*ResearchProjectDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResearchProjectDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearchProjectDetail sets the old ResearchProjectDetail of the mutation.
func withResearchProjectDetail(node *ResearchProjectDetail) researchprojectdetailOption {
	return func(m *ResearchProjectDetailMutation) {
		m.oldValue = func(context.Context) (*ResearchProjectDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchProjectDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchProjectDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResearchProjectDetail entities.
func (m *ResearchProjectDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResearchProjectDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResearchProjectDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResearchProjectDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResearchProjectID sets the "research_project_id" field.
func (m *ResearchProjectDetailMutation) SetResearchProjectID(u uuid.UUID) {
	m.research_project = &u
}

// ResearchProjectID returns the value of the "research_project_id" field in the mutation.
func (m *ResearchProjectDetailMutation) ResearchProjectID() (r uuid.UUID, exists bool) {
	v := m.research_project
	if v == nil {
		return
	}
	return *v, true
}

// OldResearchProjectID returns the old "research_project_id" field's value of the ResearchProjectDetail entity.
// If the ResearchProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailMutation) OldResearchProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResearchProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResearchProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResearchProjectID: %w", err)
	}
	return oldValue.ResearchProjectID, nil
}

// ResetResearchProjectID resets all changes to the "research_project_id" field.
func (m *ResearchProjectDetailMutation) ResetResearchProjectID() {
	m.research_project = nil
}

// SetDetailText sets the "detail_text" field.
func (m *ResearchProjectDetailMutation) SetDetailText(s string) {
	m.detail_text = &s
}

// DetailText returns the value of the "detail_text" field in the mutation.
func (m *ResearchProjectDetailMutation) DetailText() (r string, exists bool) {
	v := m.detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailText returns the old "detail_text" field's value of the ResearchProjectDetail entity.
// If the ResearchProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailMutation) OldDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailText: %w", err)
	}
	return oldValue.DetailText, nil
}

// ResetDetailText resets all changes to the "detail_text" field.
func (m *ResearchProjectDetailMutation) ResetDetailText() {
	m.detail_text = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *ResearchProjectDetailMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ResearchProjectDetailMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ResearchProjectDetail entity.
// If the ResearchProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ResearchProjectDetailMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ResearchProjectDetailMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ResearchProjectDetailMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResearchProjectDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResearchProjectDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResearchProjectDetail entity.
// If the ResearchProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResearchProjectDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResearchProjectDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResearchProjectDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResearchProjectDetail entity.
// If the ResearchProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResearchProjectDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearResearchProject clears the "research_project" edge to the ResearchProject entity.
func (m *ResearchProjectDetailMutation) ClearResearchProject() {
	m.clearedresearch_project = true
	m.clearedFields[researchprojectdetail.FieldResearchProjectID] = struct{}{}
}

// ResearchProjectCleared reports if the "research_project" edge to the ResearchProject entity was cleared.
func (m *ResearchProjectDetailMutation) ResearchProjectCleared() bool {
	return m.clearedresearch_project
}

// ResearchProjectIDs returns the "research_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResearchProjectID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectDetailMutation) ResearchProjectIDs() (ids []uuid.UUID) {
	if id := m.research_project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResearchProject resets all changes to the "research_project" edge.
func (m *ResearchProjectDetailMutation) ResetResearchProject() {
	m.research_project = nil
	m.clearedresearch_project = false
}

// AddTranslationIDs adds the "translations" edge to the ResearchProjectDetailTranslation entity by ids.
func (m *ResearchProjectDetailMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the ResearchProjectDetailTranslation entity.
func (m *ResearchProjectDetailMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the ResearchProjectDetailTranslation entity was cleared.
func (m *ResearchProjectDetailMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the ResearchProjectDetailTranslation entity by IDs.
func (m *ResearchProjectDetailMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the ResearchProjectDetailTranslation entity.
func (m *ResearchProjectDetailMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *ResearchProjectDetailMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *ResearchProjectDetailMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the ResearchProjectDetailMutation builder.
func (m *ResearchProjectDetailMutation) Where(ps ...predicate.ResearchProjectDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResearchProjectDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResearchProjectDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResearchProjectDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResearchProjectDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResearchProjectDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResearchProjectDetail).
func (m *ResearchProjectDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResearchProjectDetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.research_project != nil {
		fields = append(fields, researchprojectdetail.FieldResearchProjectID)
	}
	if m.detail_text != nil {
		fields = append(fields, researchprojectdetail.FieldDetailText)
	}
	if m.sort_order != nil {
		fields = append(fields, researchprojectdetail.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, researchprojectdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, researchprojectdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResearchProjectDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case researchprojectdetail.FieldResearchProjectID:
		return m.ResearchProjectID()
	case researchprojectdetail.FieldDetailText:
		return m.DetailText()
	case researchprojectdetail.FieldSortOrder:
		return m.SortOrder()
	case researchprojectdetail.FieldCreatedAt:
		return m.CreatedAt()
	case researchprojectdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResearchProjectDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case researchprojectdetail.FieldResearchProjectID:
		return m.OldResearchProjectID(ctx)
	case researchprojectdetail.FieldDetailText:
		return m.OldDetailText(ctx)
	case researchprojectdetail.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case researchprojectdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case researchprojectdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResearchProjectDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case researchprojectdetail.FieldResearchProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchProjectID(v)
		return nil
	case researchprojectdetail.FieldDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailText(v)
		return nil
	case researchprojectdetail.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case researchprojectdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case researchprojectdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResearchProjectDetailMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, researchprojectdetail.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResearchProjectDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case researchprojectdetail.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case researchprojectdetail.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResearchProjectDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResearchProjectDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchProjectDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResearchProjectDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResearchProjectDetailMutation) ResetField(name string) error {
	switch name {
	case researchprojectdetail.FieldResearchProjectID:
		m.ResetResearchProjectID()
		return nil
	case researchprojectdetail.FieldDetailText:
		m.ResetDetailText()
		return nil
	case researchprojectdetail.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case researchprojectdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case researchprojectdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResearchProjectDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.research_project != nil {
		edges = append(edges, researchprojectdetail.EdgeResearchProject)
	}
	if m.translations != nil {
		edges = append(edges, researchprojectdetail.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResearchProjectDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case researchprojectdetail.EdgeResearchProject:
		if id := m.research_project; id != nil {
			return []ent.Value{*id}
		}
	case researchprojectdetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResearchProjectDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, researchprojectdetail.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResearchProjectDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case researchprojectdetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResearchProjectDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresearch_project {
		edges = append(edges, researchprojectdetail.EdgeResearchProject)
	}
	if m.clearedtranslations {
		edges = append(edges, researchprojectdetail.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResearchProjectDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case researchprojectdetail.EdgeResearchProject:
		return m.clearedresearch_project
	case researchprojectdetail.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResearchProjectDetailMutation) ClearEdge(name string) error {
	switch name {
	case researchprojectdetail.EdgeResearchProject:
		m.ClearResearchProject()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResearchProjectDetailMutation) ResetEdge(name string) error {
	switch name {
	case researchprojectdetail.EdgeResearchProject:
		m.ResetResearchProject()
		return nil
	case researchprojectdetail.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetail edge %s", name)
}

// ResearchProjectDetailTranslationMutation represents an operation that mutates the ResearchProjectDetailTranslation nodes in the graph.
type ResearchProjectDetailTranslationMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	detail_text                    *string
	created_at                     *time.Time
	clearedFields                  map[string]struct{}
	research_project_detail        *uuid.UUID
	clearedresearch_project_detail bool
	language                       *string
	clearedlanguage                bool
	done                           bool
	oldValue                       func(context.Context) (*ResearchProjectDetailTranslation, error)
	predicates                     []predicate.ResearchProjectDetailTranslation
}

var _ ent.Mutation = (*ResearchProjectDetailTranslationMutation)(nil)

// researchprojectdetailtranslationOption allows management of the mutation configuration using functional options.
type researchprojectdetailtranslationOption func(*ResearchProjectDetailTranslationMutation)

// newResearchProjectDetailTranslationMutation creates new mutation for the ResearchProjectDetailTranslation entity.
func newResearchProjectDetailTranslationMutation(c config, op Op, opts ...researchprojectdetailtranslationOption) *ResearchProjectDetailTranslationMutation {
	m := &ResearchProjectDetailTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeResearchProjectDetailTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchProjectDetailTranslationID sets the ID field of the mutation.
func withResearchProjectDetailTranslationID(id uuid.UUID) researchprojectdetailtranslationOption {
	return func(m *ResearchProjectDetailTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResearchProjectDetailTranslation
		)
		m.oldValue = func(ctx context.Context) (*ResearchProjectDetailTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResearchProjectDetailTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearchProjectDetailTranslation sets the old ResearchProjectDetailTranslation of the mutation.
func withResearchProjectDetailTranslation(node *ResearchProjectDetailTranslation) researchprojectdetailtranslationOption {
	return func(m *ResearchProjectDetailTranslationMutation) {
		m.oldValue = func(context.Context) (*ResearchProjectDetailTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchProjectDetailTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchProjectDetailTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResearchProjectDetailTranslation entities.
func (m *ResearchProjectDetailTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResearchProjectDetailTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResearchProjectDetailTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResearchProjectDetailTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResearchProjectDetailID sets the "research_project_detail_id" field.
func (m *ResearchProjectDetailTranslationMutation) SetResearchProjectDetailID(u uuid.UUID) {
	m.research_project_detail = &u
}

// ResearchProjectDetailID returns the value of the "research_project_detail_id" field in the mutation.
func (m *ResearchProjectDetailTranslationMutation) ResearchProjectDetailID() (r uuid.UUID, exists bool) {
	v := m.research_project_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldResearchProjectDetailID returns the old "research_project_detail_id" field's value of the ResearchProjectDetailTranslation entity.
// If the ResearchProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailTranslationMutation) OldResearchProjectDetailID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResearchProjectDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResearchProjectDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResearchProjectDetailID: %w", err)
	}
	return oldValue.ResearchProjectDetailID, nil
}

// ResetResearchProjectDetailID resets all changes to the "research_project_detail_id" field.
func (m *ResearchProjectDetailTranslationMutation) ResetResearchProjectDetailID() {
	m.research_project_detail = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *ResearchProjectDetailTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *ResearchProjectDetailTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the ResearchProjectDetailTranslation entity.
// If the ResearchProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *ResearchProjectDetailTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetDetailText sets the "detail_text" field.
func (m *ResearchProjectDetailTranslationMutation) SetDetailText(s string) {
	m.detail_text = &s
}

// DetailText returns the value of the "detail_text" field in the mutation.
func (m *ResearchProjectDetailTranslationMutation) DetailText() (r string, exists bool) {
	v := m.detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailText returns the old "detail_text" field's value of the ResearchProjectDetailTranslation entity.
// If the ResearchProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailTranslationMutation) OldDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailText: %w", err)
	}
	return oldValue.DetailText, nil
}

// ResetDetailText resets all changes to the "detail_text" field.
func (m *ResearchProjectDetailTranslationMutation) ResetDetailText() {
	m.detail_text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResearchProjectDetailTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResearchProjectDetailTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResearchProjectDetailTranslation entity.
// If the ResearchProjectDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectDetailTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResearchProjectDetailTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearResearchProjectDetail clears the "research_project_detail" edge to the ResearchProjectDetail entity.
func (m *ResearchProjectDetailTranslationMutation) ClearResearchProjectDetail() {
	m.clearedresearch_project_detail = true
	m.clearedFields[researchprojectdetailtranslation.FieldResearchProjectDetailID] = struct{}{}
}

// ResearchProjectDetailCleared reports if the "research_project_detail" edge to the ResearchProjectDetail entity was cleared.
func (m *ResearchProjectDetailTranslationMutation) ResearchProjectDetailCleared() bool {
	return m.clearedresearch_project_detail
}

// ResearchProjectDetailIDs returns the "research_project_detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResearchProjectDetailID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectDetailTranslationMutation) ResearchProjectDetailIDs() (ids []uuid.UUID) {
	if id := m.research_project_detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResearchProjectDetail resets all changes to the "research_project_detail" edge.
func (m *ResearchProjectDetailTranslationMutation) ResetResearchProjectDetail() {
	m.research_project_detail = nil
	m.clearedresearch_project_detail = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *ResearchProjectDetailTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *ResearchProjectDetailTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[researchprojectdetailtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *ResearchProjectDetailTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *ResearchProjectDetailTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectDetailTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *ResearchProjectDetailTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the ResearchProjectDetailTranslationMutation builder.
func (m *ResearchProjectDetailTranslationMutation) Where(ps ...predicate.ResearchProjectDetailTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResearchProjectDetailTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResearchProjectDetailTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResearchProjectDetailTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResearchProjectDetailTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResearchProjectDetailTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResearchProjectDetailTranslation).
func (m *ResearchProjectDetailTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResearchProjectDetailTranslationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.research_project_detail != nil {
		fields = append(fields, researchprojectdetailtranslation.FieldResearchProjectDetailID)
	}
	if m.language != nil {
		fields = append(fields, researchprojectdetailtranslation.FieldLanguageCode)
	}
	if m.detail_text != nil {
		fields = append(fields, researchprojectdetailtranslation.FieldDetailText)
	}
	if m.created_at != nil {
		fields = append(fields, researchprojectdetailtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResearchProjectDetailTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case researchprojectdetailtranslation.FieldResearchProjectDetailID:
		return m.ResearchProjectDetailID()
	case researchprojectdetailtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case researchprojectdetailtranslation.FieldDetailText:
		return m.DetailText()
	case researchprojectdetailtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResearchProjectDetailTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case researchprojectdetailtranslation.FieldResearchProjectDetailID:
		return m.OldResearchProjectDetailID(ctx)
	case researchprojectdetailtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case researchprojectdetailtranslation.FieldDetailText:
		return m.OldDetailText(ctx)
	case researchprojectdetailtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResearchProjectDetailTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectDetailTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case researchprojectdetailtranslation.FieldResearchProjectDetailID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchProjectDetailID(v)
		return nil
	case researchprojectdetailtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case researchprojectdetailtranslation.FieldDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailText(v)
		return nil
	case researchprojectdetailtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetailTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResearchProjectDetailTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResearchProjectDetailTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectDetailTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResearchProjectDetailTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResearchProjectDetailTranslationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResearchProjectDetailTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchProjectDetailTranslationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResearchProjectDetailTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResearchProjectDetailTranslationMutation) ResetField(name string) error {
	switch name {
	case researchprojectdetailtranslation.FieldResearchProjectDetailID:
		m.ResetResearchProjectDetailID()
		return nil
	case researchprojectdetailtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case researchprojectdetailtranslation.FieldDetailText:
		m.ResetDetailText()
		return nil
	case researchprojectdetailtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetailTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResearchProjectDetailTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.research_project_detail != nil {
		edges = append(edges, researchprojectdetailtranslation.EdgeResearchProjectDetail)
	}
	if m.language != nil {
		edges = append(edges, researchprojectdetailtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResearchProjectDetailTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case researchprojectdetailtranslation.EdgeResearchProjectDetail:
		if id := m.research_project_detail; id != nil {
			return []ent.Value{*id}
		}
	case researchprojectdetailtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResearchProjectDetailTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResearchProjectDetailTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResearchProjectDetailTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresearch_project_detail {
		edges = append(edges, researchprojectdetailtranslation.EdgeResearchProjectDetail)
	}
	if m.clearedlanguage {
		edges = append(edges, researchprojectdetailtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResearchProjectDetailTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case researchprojectdetailtranslation.EdgeResearchProjectDetail:
		return m.clearedresearch_project_detail
	case researchprojectdetailtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResearchProjectDetailTranslationMutation) ClearEdge(name string) error {
	switch name {
	case researchprojectdetailtranslation.EdgeResearchProjectDetail:
		m.ClearResearchProjectDetail()
		return nil
	case researchprojectdetailtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetailTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResearchProjectDetailTranslationMutation) ResetEdge(name string) error {
	switch name {
	case researchprojectdetailtranslation.EdgeResearchProjectDetail:
		m.ResetResearchProjectDetail()
		return nil
	case researchprojectdetailtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectDetailTranslation edge %s", name)
}

// ResearchProjectTranslationMutation represents an operation that mutates the ResearchProjectTranslation nodes in the graph.
type ResearchProjectTranslationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	title                   *string
	location                *string
	research_type           *string
	funding_source          *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	research_project        *uuid.UUID
	clearedresearch_project bool
	language                *string
	clearedlanguage         bool
	done                    bool
	oldValue                func(context.Context) (*ResearchProjectTranslation, error)
	predicates              []predicate.ResearchProjectTranslation
}

var _ ent.Mutation = (*ResearchProjectTranslationMutation)(nil)

// researchprojecttranslationOption allows management of the mutation configuration using functional options.
type researchprojecttranslationOption func(*ResearchProjectTranslationMutation)

// newResearchProjectTranslationMutation creates new mutation for the ResearchProjectTranslation entity.
func newResearchProjectTranslationMutation(c config, op Op, opts ...researchprojecttranslationOption) *ResearchProjectTranslationMutation {
	m := &ResearchProjectTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeResearchProjectTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchProjectTranslationID sets the ID field of the mutation.
func withResearchProjectTranslationID(id uuid.UUID) researchprojecttranslationOption {
	return func(m *ResearchProjectTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *ResearchProjectTranslation
		)
		m.oldValue = func(ctx context.Context) (*ResearchProjectTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResearchProjectTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearchProjectTranslation sets the old ResearchProjectTranslation of the mutation.
func withResearchProjectTranslation(node *ResearchProjectTranslation) researchprojecttranslationOption {
	return func(m *ResearchProjectTranslationMutation) {
		m.oldValue = func(context.Context) (*ResearchProjectTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchProjectTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchProjectTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResearchProjectTranslation entities.
func (m *ResearchProjectTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResearchProjectTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResearchProjectTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResearchProjectTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResearchProjectID sets the "research_project_id" field.
func (m *ResearchProjectTranslationMutation) SetResearchProjectID(u uuid.UUID) {
	m.research_project = &u
}

// ResearchProjectID returns the value of the "research_project_id" field in the mutation.
func (m *ResearchProjectTranslationMutation) ResearchProjectID() (r uuid.UUID, exists bool) {
	v := m.research_project
	if v == nil {
		return
	}
	return *v, true
}

// OldResearchProjectID returns the old "research_project_id" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldResearchProjectID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResearchProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResearchProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResearchProjectID: %w", err)
	}
	return oldValue.ResearchProjectID, nil
}

// ResetResearchProjectID resets all changes to the "research_project_id" field.
func (m *ResearchProjectTranslationMutation) ResetResearchProjectID() {
	m.research_project = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *ResearchProjectTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *ResearchProjectTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *ResearchProjectTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetTitle sets the "title" field.
func (m *ResearchProjectTranslationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResearchProjectTranslationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ResearchProjectTranslationMutation) ResetTitle() {
	m.title = nil
}

// SetLocation sets the "location" field.
func (m *ResearchProjectTranslationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ResearchProjectTranslationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ResearchProjectTranslationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[researchprojecttranslation.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ResearchProjectTranslationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[researchprojecttranslation.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ResearchProjectTranslationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, researchprojecttranslation.FieldLocation)
}

// SetResearchType sets the "research_type" field.
func (m *ResearchProjectTranslationMutation) SetResearchType(s string) {
	m.research_type = &s
}

// ResearchType returns the value of the "research_type" field in the mutation.
func (m *ResearchProjectTranslationMutation) ResearchType() (r string, exists bool) {
	v := m.research_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResearchType returns the old "research_type" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldResearchType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResearchType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResearchType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResearchType: %w", err)
	}
	return oldValue.ResearchType, nil
}

// ClearResearchType clears the value of the "research_type" field.
func (m *ResearchProjectTranslationMutation) ClearResearchType() {
	m.research_type = nil
	m.clearedFields[researchprojecttranslation.FieldResearchType] = struct{}{}
}

// ResearchTypeCleared returns if the "research_type" field was cleared in this mutation.
func (m *ResearchProjectTranslationMutation) ResearchTypeCleared() bool {
	_, ok := m.clearedFields[researchprojecttranslation.FieldResearchType]
	return ok
}

// ResetResearchType resets all changes to the "research_type" field.
func (m *ResearchProjectTranslationMutation) ResetResearchType() {
	m.research_type = nil
	delete(m.clearedFields, researchprojecttranslation.FieldResearchType)
}

// SetFundingSource sets the "funding_source" field.
func (m *ResearchProjectTranslationMutation) SetFundingSource(s string) {
	m.funding_source = &s
}

// FundingSource returns the value of the "funding_source" field in the mutation.
func (m *ResearchProjectTranslationMutation) FundingSource() (r string, exists bool) {
	v := m.funding_source
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingSource returns the old "funding_source" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldFundingSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingSource: %w", err)
	}
	return oldValue.FundingSource, nil
}

// ClearFundingSource clears the value of the "funding_source" field.
func (m *ResearchProjectTranslationMutation) ClearFundingSource() {
	m.funding_source = nil
	m.clearedFields[researchprojecttranslation.FieldFundingSource] = struct{}{}
}

// FundingSourceCleared returns if the "funding_source" field was cleared in this mutation.
func (m *ResearchProjectTranslationMutation) FundingSourceCleared() bool {
	_, ok := m.clearedFields[researchprojecttranslation.FieldFundingSource]
	return ok
}

// ResetFundingSource resets all changes to the "funding_source" field.
func (m *ResearchProjectTranslationMutation) ResetFundingSource() {
	m.funding_source = nil
	delete(m.clearedFields, researchprojecttranslation.FieldFundingSource)
}

// SetCreatedAt sets the "created_at" field.
func (m *ResearchProjectTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResearchProjectTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResearchProjectTranslation entity.
// If the ResearchProjectTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResearchProjectTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearResearchProject clears the "research_project" edge to the ResearchProject entity.
func (m *ResearchProjectTranslationMutation) ClearResearchProject() {
	m.clearedresearch_project = true
	m.clearedFields[researchprojecttranslation.FieldResearchProjectID] = struct{}{}
}

// ResearchProjectCleared reports if the "research_project" edge to the ResearchProject entity was cleared.
func (m *ResearchProjectTranslationMutation) ResearchProjectCleared() bool {
	return m.clearedresearch_project
}

// ResearchProjectIDs returns the "research_project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResearchProjectID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectTranslationMutation) ResearchProjectIDs() (ids []uuid.UUID) {
	if id := m.research_project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResearchProject resets all changes to the "research_project" edge.
func (m *ResearchProjectTranslationMutation) ResetResearchProject() {
	m.research_project = nil
	m.clearedresearch_project = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *ResearchProjectTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *ResearchProjectTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[researchprojecttranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *ResearchProjectTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *ResearchProjectTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *ResearchProjectTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the ResearchProjectTranslationMutation builder.
func (m *ResearchProjectTranslationMutation) Where(ps ...predicate.ResearchProjectTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResearchProjectTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResearchProjectTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResearchProjectTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResearchProjectTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResearchProjectTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResearchProjectTranslation).
func (m *ResearchProjectTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResearchProjectTranslationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.research_project != nil {
		fields = append(fields, researchprojecttranslation.FieldResearchProjectID)
	}
	if m.language != nil {
		fields = append(fields, researchprojecttranslation.FieldLanguageCode)
	}
	if m.title != nil {
		fields = append(fields, researchprojecttranslation.FieldTitle)
	}
	if m.location != nil {
		fields = append(fields, researchprojecttranslation.FieldLocation)
	}
	if m.research_type != nil {
		fields = append(fields, researchprojecttranslation.FieldResearchType)
	}
	if m.funding_source != nil {
		fields = append(fields, researchprojecttranslation.FieldFundingSource)
	}
	if m.created_at != nil {
		fields = append(fields, researchprojecttranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResearchProjectTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case researchprojecttranslation.FieldResearchProjectID:
		return m.ResearchProjectID()
	case researchprojecttranslation.FieldLanguageCode:
		return m.LanguageCode()
	case researchprojecttranslation.FieldTitle:
		return m.Title()
	case researchprojecttranslation.FieldLocation:
		return m.Location()
	case researchprojecttranslation.FieldResearchType:
		return m.ResearchType()
	case researchprojecttranslation.FieldFundingSource:
		return m.FundingSource()
	case researchprojecttranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResearchProjectTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case researchprojecttranslation.FieldResearchProjectID:
		return m.OldResearchProjectID(ctx)
	case researchprojecttranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case researchprojecttranslation.FieldTitle:
		return m.OldTitle(ctx)
	case researchprojecttranslation.FieldLocation:
		return m.OldLocation(ctx)
	case researchprojecttranslation.FieldResearchType:
		return m.OldResearchType(ctx)
	case researchprojecttranslation.FieldFundingSource:
		return m.OldFundingSource(ctx)
	case researchprojecttranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResearchProjectTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case researchprojecttranslation.FieldResearchProjectID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchProjectID(v)
		return nil
	case researchprojecttranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case researchprojecttranslation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case researchprojecttranslation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case researchprojecttranslation.FieldResearchType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchType(v)
		return nil
	case researchprojecttranslation.FieldFundingSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingSource(v)
		return nil
	case researchprojecttranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResearchProjectTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResearchProjectTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResearchProjectTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResearchProjectTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(researchprojecttranslation.FieldLocation) {
		fields = append(fields, researchprojecttranslation.FieldLocation)
	}
	if m.FieldCleared(researchprojecttranslation.FieldResearchType) {
		fields = append(fields, researchprojecttranslation.FieldResearchType)
	}
	if m.FieldCleared(researchprojecttranslation.FieldFundingSource) {
		fields = append(fields, researchprojecttranslation.FieldFundingSource)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResearchProjectTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchProjectTranslationMutation) ClearField(name string) error {
	switch name {
	case researchprojecttranslation.FieldLocation:
		m.ClearLocation()
		return nil
	case researchprojecttranslation.FieldResearchType:
		m.ClearResearchType()
		return nil
	case researchprojecttranslation.FieldFundingSource:
		m.ClearFundingSource()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResearchProjectTranslationMutation) ResetField(name string) error {
	switch name {
	case researchprojecttranslation.FieldResearchProjectID:
		m.ResetResearchProjectID()
		return nil
	case researchprojecttranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case researchprojecttranslation.FieldTitle:
		m.ResetTitle()
		return nil
	case researchprojecttranslation.FieldLocation:
		m.ResetLocation()
		return nil
	case researchprojecttranslation.FieldResearchType:
		m.ResetResearchType()
		return nil
	case researchprojecttranslation.FieldFundingSource:
		m.ResetFundingSource()
		return nil
	case researchprojecttranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResearchProjectTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.research_project != nil {
		edges = append(edges, researchprojecttranslation.EdgeResearchProject)
	}
	if m.language != nil {
		edges = append(edges, researchprojecttranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResearchProjectTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case researchprojecttranslation.EdgeResearchProject:
		if id := m.research_project; id != nil {
			return []ent.Value{*id}
		}
	case researchprojecttranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResearchProjectTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResearchProjectTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResearchProjectTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedresearch_project {
		edges = append(edges, researchprojecttranslation.EdgeResearchProject)
	}
	if m.clearedlanguage {
		edges = append(edges, researchprojecttranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResearchProjectTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case researchprojecttranslation.EdgeResearchProject:
		return m.clearedresearch_project
	case researchprojecttranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResearchProjectTranslationMutation) ClearEdge(name string) error {
	switch name {
	case researchprojecttranslation.EdgeResearchProject:
		m.ClearResearchProject()
		return nil
	case researchprojecttranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResearchProjectTranslationMutation) ResetEdge(name string) error {
	switch name {
	case researchprojecttranslation.EdgeResearchProject:
		m.ResetResearchProject()
		return nil
	case researchprojecttranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown ResearchProjectTranslation edge %s", name)
}

// SocialLinkMutation represents an operation that mutates the SocialLink nodes in the graph.
type SocialLinkMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	platform             *string
	url                  *string
	display_name         *string
	is_active            *bool
	sort_order           *int
	addsort_order        *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	personal_info        *uuid.UUID
	clearedpersonal_info bool
	done                 bool
	oldValue             func(context.Context) (*SocialLink, error)
	predicates           []predicate.SocialLink
}

var _ ent.Mutation = (*SocialLinkMutation)(nil)

// sociallinkOption allows management of the mutation configuration using functional options.
type sociallinkOption func(*SocialLinkMutation)

// newSocialLinkMutation creates new mutation for the SocialLink entity.
func newSocialLinkMutation(c config, op Op, opts ...sociallinkOption) *SocialLinkMutation {
	m := &SocialLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeSocialLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSocialLinkID sets the ID field of the mutation.
func withSocialLinkID(id uuid.UUID) sociallinkOption {
	return func(m *SocialLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *SocialLink
		)
		m.oldValue = func(ctx context.Context) (*SocialLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SocialLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSocialLink sets the old SocialLink of the mutation.
func withSocialLink(node *SocialLink) sociallinkOption {
	return func(m *SocialLinkMutation) {
		m.oldValue = func(context.Context) (*SocialLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SocialLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SocialLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SocialLink entities.
func (m *SocialLinkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SocialLinkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SocialLinkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SocialLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPersonalInfoID sets the "personal_info_id" field.
func (m *SocialLinkMutation) SetPersonalInfoID(u uuid.UUID) {
	m.personal_info = &u
}

// PersonalInfoID returns the value of the "personal_info_id" field in the mutation.
func (m *SocialLinkMutation) PersonalInfoID() (r uuid.UUID, exists bool) {
	v := m.personal_info
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalInfoID returns the old "personal_info_id" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldPersonalInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalInfoID: %w", err)
	}
	return oldValue.PersonalInfoID, nil
}

// ResetPersonalInfoID resets all changes to the "personal_info_id" field.
func (m *SocialLinkMutation) ResetPersonalInfoID() {
	m.personal_info = nil
}

// SetPlatform sets the "platform" field.
func (m *SocialLinkMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *SocialLinkMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *SocialLinkMutation) ResetPlatform() {
	m.platform = nil
}

// SetURL sets the "url" field.
func (m *SocialLinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SocialLinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *SocialLinkMutation) ResetURL() {
	m.url = nil
}

// SetDisplayName sets the "display_name" field.
func (m *SocialLinkMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SocialLinkMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SocialLinkMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[sociallink.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SocialLinkMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[sociallink.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SocialLinkMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, sociallink.FieldDisplayName)
}

// SetIsActive sets the "is_active" field.
func (m *SocialLinkMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *SocialLinkMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *SocialLinkMutation) ResetIsActive() {
	m.is_active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *SocialLinkMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *SocialLinkMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *SocialLinkMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *SocialLinkMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *SocialLinkMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SocialLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SocialLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SocialLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearPersonalInfo clears the "personal_info" edge to the PersonalInfo entity.
func (m *SocialLinkMutation) ClearPersonalInfo() {
	m.clearedpersonal_info = true
	m.clearedFields[sociallink.FieldPersonalInfoID] = struct{}{}
}

// PersonalInfoCleared reports if the "personal_info" edge to the PersonalInfo entity was cleared.
func (m *SocialLinkMutation) PersonalInfoCleared() bool {
	return m.clearedpersonal_info
}

// PersonalInfoIDs returns the "personal_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonalInfoID instead. It exists only for internal usage by the builders.
func (m *SocialLinkMutation) PersonalInfoIDs() (ids []uuid.UUID) {
	if id := m.personal_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPersonalInfo resets all changes to the "personal_info" edge.
func (m *SocialLinkMutation) ResetPersonalInfo() {
	m.personal_info = nil
	m.clearedpersonal_info = false
}

// Where appends a list predicates to the SocialLinkMutation builder.
func (m *SocialLinkMutation) Where(ps ...predicate.SocialLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SocialLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SocialLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SocialLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SocialLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SocialLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SocialLink).
func (m *SocialLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SocialLinkMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.personal_info != nil {
		fields = append(fields, sociallink.FieldPersonalInfoID)
	}
	if m.platform != nil {
		fields = append(fields, sociallink.FieldPlatform)
	}
	if m.url != nil {
		fields = append(fields, sociallink.FieldURL)
	}
	if m.display_name != nil {
		fields = append(fields, sociallink.FieldDisplayName)
	}
	if m.is_active != nil {
		fields = append(fields, sociallink.FieldIsActive)
	}
	if m.sort_order != nil {
		fields = append(fields, sociallink.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, sociallink.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SocialLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sociallink.FieldPersonalInfoID:
		return m.PersonalInfoID()
	case sociallink.FieldPlatform:
		return m.Platform()
	case sociallink.FieldURL:
		return m.URL()
	case sociallink.FieldDisplayName:
		return m.DisplayName()
	case sociallink.FieldIsActive:
		return m.IsActive()
	case sociallink.FieldSortOrder:
		return m.SortOrder()
	case sociallink.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SocialLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sociallink.FieldPersonalInfoID:
		return m.OldPersonalInfoID(ctx)
	case sociallink.FieldPlatform:
		return m.OldPlatform(ctx)
	case sociallink.FieldURL:
		return m.OldURL(ctx)
	case sociallink.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case sociallink.FieldIsActive:
		return m.OldIsActive(ctx)
	case sociallink.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case sociallink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SocialLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SocialLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sociallink.FieldPersonalInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalInfoID(v)
		return nil
	case sociallink.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case sociallink.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case sociallink.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case sociallink.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case sociallink.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case sociallink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SocialLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SocialLinkMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, sociallink.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SocialLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sociallink.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SocialLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sociallink.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown SocialLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SocialLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sociallink.FieldDisplayName) {
		fields = append(fields, sociallink.FieldDisplayName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SocialLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SocialLinkMutation) ClearField(name string) error {
	switch name {
	case sociallink.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	}
	return fmt.Errorf("unknown SocialLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SocialLinkMutation) ResetField(name string) error {
	switch name {
	case sociallink.FieldPersonalInfoID:
		m.ResetPersonalInfoID()
		return nil
	case sociallink.FieldPlatform:
		m.ResetPlatform()
		return nil
	case sociallink.FieldURL:
		m.ResetURL()
		return nil
	case sociallink.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case sociallink.FieldIsActive:
		m.ResetIsActive()
		return nil
	case sociallink.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case sociallink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SocialLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SocialLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.personal_info != nil {
		edges = append(edges, sociallink.EdgePersonalInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SocialLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sociallink.EdgePersonalInfo:
		if id := m.personal_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SocialLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SocialLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SocialLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpersonal_info {
		edges = append(edges, sociallink.EdgePersonalInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SocialLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case sociallink.EdgePersonalInfo:
		return m.clearedpersonal_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SocialLinkMutation) ClearEdge(name string) error {
	switch name {
	case sociallink.EdgePersonalInfo:
		m.ClearPersonalInfo()
		return nil
	}
	return fmt.Errorf("unknown SocialLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SocialLinkMutation) ResetEdge(name string) error {
	switch name {
	case sociallink.EdgePersonalInfo:
		m.ResetPersonalInfo()
		return nil
	}
	return fmt.Errorf("unknown SocialLink edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	username                 *string
	email                    *string
	password_hash            *string
	first_name               *string
	last_name                *string
	avatar_url               *string
	bio                      *string
	is_active                *bool
	is_admin                 *bool
	last_login_at            *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	personal_infos           map[uuid.UUID]struct{}
	removedpersonal_infos    map[uuid.UUID]struct{}
	clearedpersonal_infos    bool
	educations               map[uuid.UUID]struct{}
	removededucations        map[uuid.UUID]struct{}
	clearededucations        bool
	work_experiences         map[uuid.UUID]struct{}
	removedwork_experiences  map[uuid.UUID]struct{}
	clearedwork_experiences  bool
	projects                 map[uuid.UUID]struct{}
	removedprojects          map[uuid.UUID]struct{}
	clearedprojects          bool
	blog_posts               map[uuid.UUID]struct{}
	removedblog_posts        map[uuid.UUID]struct{}
	clearedblog_posts        bool
	ideas                    map[uuid.UUID]struct{}
	removedideas             map[uuid.UUID]struct{}
	clearedideas             bool
	research_projects        map[uuid.UUID]struct{}
	removedresearch_projects map[uuid.UUID]struct{}
	clearedresearch_projects bool
	publications             map[uuid.UUID]struct{}
	removedpublications      map[uuid.UUID]struct{}
	clearedpublications      bool
	awards                   map[uuid.UUID]struct{}
	removedawards            map[uuid.UUID]struct{}
	clearedawards            bool
	recent_updates           map[uuid.UUID]struct{}
	removedrecent_updates    map[uuid.UUID]struct{}
	clearedrecent_updates    bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPersonalInfoIDs adds the "personal_infos" edge to the PersonalInfo entity by ids.
func (m *UserMutation) AddPersonalInfoIDs(ids ...uuid.UUID) {
	if m.personal_infos == nil {
		m.personal_infos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.personal_infos[ids[i]] = struct{}{}
	}
}

// ClearPersonalInfos clears the "personal_infos" edge to the PersonalInfo entity.
func (m *UserMutation) ClearPersonalInfos() {
	m.clearedpersonal_infos = true
}

// PersonalInfosCleared reports if the "personal_infos" edge to the PersonalInfo entity was cleared.
func (m *UserMutation) PersonalInfosCleared() bool {
	return m.clearedpersonal_infos
}

// RemovePersonalInfoIDs removes the "personal_infos" edge to the PersonalInfo entity by IDs.
func (m *UserMutation) RemovePersonalInfoIDs(ids ...uuid.UUID) {
	if m.removedpersonal_infos == nil {
		m.removedpersonal_infos = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.personal_infos, ids[i])
		m.removedpersonal_infos[ids[i]] = struct{}{}
	}
}

// RemovedPersonalInfos returns the removed IDs of the "personal_infos" edge to the PersonalInfo entity.
func (m *UserMutation) RemovedPersonalInfosIDs() (ids []uuid.UUID) {
	for id := range m.removedpersonal_infos {
		ids = append(ids, id)
	}
	return
}

// PersonalInfosIDs returns the "personal_infos" edge IDs in the mutation.
func (m *UserMutation) PersonalInfosIDs() (ids []uuid.UUID) {
	for id := range m.personal_infos {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalInfos resets all changes to the "personal_infos" edge.
func (m *UserMutation) ResetPersonalInfos() {
	m.personal_infos = nil
	m.clearedpersonal_infos = false
	m.removedpersonal_infos = nil
}

// AddEducationIDs adds the "educations" edge to the Education entity by ids.
func (m *UserMutation) AddEducationIDs(ids ...uuid.UUID) {
	if m.educations == nil {
		m.educations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the Education entity.
func (m *UserMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the Education entity was cleared.
func (m *UserMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the Education entity by IDs.
func (m *UserMutation) RemoveEducationIDs(ids ...uuid.UUID) {
	if m.removededucations == nil {
		m.removededucations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the Education entity.
func (m *UserMutation) RemovedEducationsIDs() (ids []uuid.UUID) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *UserMutation) EducationsIDs() (ids []uuid.UUID) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *UserMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// AddWorkExperienceIDs adds the "work_experiences" edge to the WorkExperience entity by ids.
func (m *UserMutation) AddWorkExperienceIDs(ids ...uuid.UUID) {
	if m.work_experiences == nil {
		m.work_experiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.work_experiences[ids[i]] = struct{}{}
	}
}

// ClearWorkExperiences clears the "work_experiences" edge to the WorkExperience entity.
func (m *UserMutation) ClearWorkExperiences() {
	m.clearedwork_experiences = true
}

// WorkExperiencesCleared reports if the "work_experiences" edge to the WorkExperience entity was cleared.
func (m *UserMutation) WorkExperiencesCleared() bool {
	return m.clearedwork_experiences
}

// RemoveWorkExperienceIDs removes the "work_experiences" edge to the WorkExperience entity by IDs.
func (m *UserMutation) RemoveWorkExperienceIDs(ids ...uuid.UUID) {
	if m.removedwork_experiences == nil {
		m.removedwork_experiences = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.work_experiences, ids[i])
		m.removedwork_experiences[ids[i]] = struct{}{}
	}
}

// RemovedWorkExperiences returns the removed IDs of the "work_experiences" edge to the WorkExperience entity.
func (m *UserMutation) RemovedWorkExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.removedwork_experiences {
		ids = append(ids, id)
	}
	return
}

// WorkExperiencesIDs returns the "work_experiences" edge IDs in the mutation.
func (m *UserMutation) WorkExperiencesIDs() (ids []uuid.UUID) {
	for id := range m.work_experiences {
		ids = append(ids, id)
	}
	return
}

// ResetWorkExperiences resets all changes to the "work_experiences" edge.
func (m *UserMutation) ResetWorkExperiences() {
	m.work_experiences = nil
	m.clearedwork_experiences = false
	m.removedwork_experiences = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...uuid.UUID) {
	if m.projects == nil {
		m.projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...uuid.UUID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []uuid.UUID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *UserMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *UserMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *UserMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *UserMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *UserMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *UserMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *UserMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// AddIdeaIDs adds the "ideas" edge to the Idea entity by ids.
func (m *UserMutation) AddIdeaIDs(ids ...uuid.UUID) {
	if m.ideas == nil {
		m.ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ideas[ids[i]] = struct{}{}
	}
}

// ClearIdeas clears the "ideas" edge to the Idea entity.
func (m *UserMutation) ClearIdeas() {
	m.clearedideas = true
}

// IdeasCleared reports if the "ideas" edge to the Idea entity was cleared.
func (m *UserMutation) IdeasCleared() bool {
	return m.clearedideas
}

// RemoveIdeaIDs removes the "ideas" edge to the Idea entity by IDs.
func (m *UserMutation) RemoveIdeaIDs(ids ...uuid.UUID) {
	if m.removedideas == nil {
		m.removedideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ideas, ids[i])
		m.removedideas[ids[i]] = struct{}{}
	}
}

// RemovedIdeas returns the removed IDs of the "ideas" edge to the Idea entity.
func (m *UserMutation) RemovedIdeasIDs() (ids []uuid.UUID) {
	for id := range m.removedideas {
		ids = append(ids, id)
	}
	return
}

// IdeasIDs returns the "ideas" edge IDs in the mutation.
func (m *UserMutation) IdeasIDs() (ids []uuid.UUID) {
	for id := range m.ideas {
		ids = append(ids, id)
	}
	return
}

// ResetIdeas resets all changes to the "ideas" edge.
func (m *UserMutation) ResetIdeas() {
	m.ideas = nil
	m.clearedideas = false
	m.removedideas = nil
}

// AddResearchProjectIDs adds the "research_projects" edge to the ResearchProject entity by ids.
func (m *UserMutation) AddResearchProjectIDs(ids ...uuid.UUID) {
	if m.research_projects == nil {
		m.research_projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.research_projects[ids[i]] = struct{}{}
	}
}

// ClearResearchProjects clears the "research_projects" edge to the ResearchProject entity.
func (m *UserMutation) ClearResearchProjects() {
	m.clearedresearch_projects = true
}

// ResearchProjectsCleared reports if the "research_projects" edge to the ResearchProject entity was cleared.
func (m *UserMutation) ResearchProjectsCleared() bool {
	return m.clearedresearch_projects
}

// RemoveResearchProjectIDs removes the "research_projects" edge to the ResearchProject entity by IDs.
func (m *UserMutation) RemoveResearchProjectIDs(ids ...uuid.UUID) {
	if m.removedresearch_projects == nil {
		m.removedresearch_projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.research_projects, ids[i])
		m.removedresearch_projects[ids[i]] = struct{}{}
	}
}

// RemovedResearchProjects returns the removed IDs of the "research_projects" edge to the ResearchProject entity.
func (m *UserMutation) RemovedResearchProjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedresearch_projects {
		ids = append(ids, id)
	}
	return
}

// ResearchProjectsIDs returns the "research_projects" edge IDs in the mutation.
func (m *UserMutation) ResearchProjectsIDs() (ids []uuid.UUID) {
	for id := range m.research_projects {
		ids = append(ids, id)
	}
	return
}

// ResetResearchProjects resets all changes to the "research_projects" edge.
func (m *UserMutation) ResetResearchProjects() {
	m.research_projects = nil
	m.clearedresearch_projects = false
	m.removedresearch_projects = nil
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *UserMutation) AddPublicationIDs(ids ...uuid.UUID) {
	if m.publications == nil {
		m.publications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *UserMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *UserMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *UserMutation) RemovePublicationIDs(ids ...uuid.UUID) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *UserMutation) RemovedPublicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *UserMutation) PublicationsIDs() (ids []uuid.UUID) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *UserMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// AddAwardIDs adds the "awards" edge to the Award entity by ids.
func (m *UserMutation) AddAwardIDs(ids ...uuid.UUID) {
	if m.awards == nil {
		m.awards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.awards[ids[i]] = struct{}{}
	}
}

// ClearAwards clears the "awards" edge to the Award entity.
func (m *UserMutation) ClearAwards() {
	m.clearedawards = true
}

// AwardsCleared reports if the "awards" edge to the Award entity was cleared.
func (m *UserMutation) AwardsCleared() bool {
	return m.clearedawards
}

// RemoveAwardIDs removes the "awards" edge to the Award entity by IDs.
func (m *UserMutation) RemoveAwardIDs(ids ...uuid.UUID) {
	if m.removedawards == nil {
		m.removedawards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.awards, ids[i])
		m.removedawards[ids[i]] = struct{}{}
	}
}

// RemovedAwards returns the removed IDs of the "awards" edge to the Award entity.
func (m *UserMutation) RemovedAwardsIDs() (ids []uuid.UUID) {
	for id := range m.removedawards {
		ids = append(ids, id)
	}
	return
}

// AwardsIDs returns the "awards" edge IDs in the mutation.
func (m *UserMutation) AwardsIDs() (ids []uuid.UUID) {
	for id := range m.awards {
		ids = append(ids, id)
	}
	return
}

// ResetAwards resets all changes to the "awards" edge.
func (m *UserMutation) ResetAwards() {
	m.awards = nil
	m.clearedawards = false
	m.removedawards = nil
}

// AddRecentUpdateIDs adds the "recent_updates" edge to the RecentUpdate entity by ids.
func (m *UserMutation) AddRecentUpdateIDs(ids ...uuid.UUID) {
	if m.recent_updates == nil {
		m.recent_updates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.recent_updates[ids[i]] = struct{}{}
	}
}

// ClearRecentUpdates clears the "recent_updates" edge to the RecentUpdate entity.
func (m *UserMutation) ClearRecentUpdates() {
	m.clearedrecent_updates = true
}

// RecentUpdatesCleared reports if the "recent_updates" edge to the RecentUpdate entity was cleared.
func (m *UserMutation) RecentUpdatesCleared() bool {
	return m.clearedrecent_updates
}

// RemoveRecentUpdateIDs removes the "recent_updates" edge to the RecentUpdate entity by IDs.
func (m *UserMutation) RemoveRecentUpdateIDs(ids ...uuid.UUID) {
	if m.removedrecent_updates == nil {
		m.removedrecent_updates = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.recent_updates, ids[i])
		m.removedrecent_updates[ids[i]] = struct{}{}
	}
}

// RemovedRecentUpdates returns the removed IDs of the "recent_updates" edge to the RecentUpdate entity.
func (m *UserMutation) RemovedRecentUpdatesIDs() (ids []uuid.UUID) {
	for id := range m.removedrecent_updates {
		ids = append(ids, id)
	}
	return
}

// RecentUpdatesIDs returns the "recent_updates" edge IDs in the mutation.
func (m *UserMutation) RecentUpdatesIDs() (ids []uuid.UUID) {
	for id := range m.recent_updates {
		ids = append(ids, id)
	}
	return
}

// ResetRecentUpdates resets all changes to the "recent_updates" edge.
func (m *UserMutation) ResetRecentUpdates() {
	m.recent_updates = nil
	m.clearedrecent_updates = false
	m.removedrecent_updates = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldBio:
		return m.Bio()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.personal_infos != nil {
		edges = append(edges, user.EdgePersonalInfos)
	}
	if m.educations != nil {
		edges = append(edges, user.EdgeEducations)
	}
	if m.work_experiences != nil {
		edges = append(edges, user.EdgeWorkExperiences)
	}
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.blog_posts != nil {
		edges = append(edges, user.EdgeBlogPosts)
	}
	if m.ideas != nil {
		edges = append(edges, user.EdgeIdeas)
	}
	if m.research_projects != nil {
		edges = append(edges, user.EdgeResearchProjects)
	}
	if m.publications != nil {
		edges = append(edges, user.EdgePublications)
	}
	if m.awards != nil {
		edges = append(edges, user.EdgeAwards)
	}
	if m.recent_updates != nil {
		edges = append(edges, user.EdgeRecentUpdates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePersonalInfos:
		ids := make([]ent.Value, 0, len(m.personal_infos))
		for id := range m.personal_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkExperiences:
		ids := make([]ent.Value, 0, len(m.work_experiences))
		for id := range m.work_experiences {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdeas:
		ids := make([]ent.Value, 0, len(m.ideas))
		for id := range m.ideas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResearchProjects:
		ids := make([]ent.Value, 0, len(m.research_projects))
		for id := range m.research_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAwards:
		ids := make([]ent.Value, 0, len(m.awards))
		for id := range m.awards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecentUpdates:
		ids := make([]ent.Value, 0, len(m.recent_updates))
		for id := range m.recent_updates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedpersonal_infos != nil {
		edges = append(edges, user.EdgePersonalInfos)
	}
	if m.removededucations != nil {
		edges = append(edges, user.EdgeEducations)
	}
	if m.removedwork_experiences != nil {
		edges = append(edges, user.EdgeWorkExperiences)
	}
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.removedblog_posts != nil {
		edges = append(edges, user.EdgeBlogPosts)
	}
	if m.removedideas != nil {
		edges = append(edges, user.EdgeIdeas)
	}
	if m.removedresearch_projects != nil {
		edges = append(edges, user.EdgeResearchProjects)
	}
	if m.removedpublications != nil {
		edges = append(edges, user.EdgePublications)
	}
	if m.removedawards != nil {
		edges = append(edges, user.EdgeAwards)
	}
	if m.removedrecent_updates != nil {
		edges = append(edges, user.EdgeRecentUpdates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePersonalInfos:
		ids := make([]ent.Value, 0, len(m.removedpersonal_infos))
		for id := range m.removedpersonal_infos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkExperiences:
		ids := make([]ent.Value, 0, len(m.removedwork_experiences))
		for id := range m.removedwork_experiences {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdeas:
		ids := make([]ent.Value, 0, len(m.removedideas))
		for id := range m.removedideas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResearchProjects:
		ids := make([]ent.Value, 0, len(m.removedresearch_projects))
		for id := range m.removedresearch_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAwards:
		ids := make([]ent.Value, 0, len(m.removedawards))
		for id := range m.removedawards {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRecentUpdates:
		ids := make([]ent.Value, 0, len(m.removedrecent_updates))
		for id := range m.removedrecent_updates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedpersonal_infos {
		edges = append(edges, user.EdgePersonalInfos)
	}
	if m.clearededucations {
		edges = append(edges, user.EdgeEducations)
	}
	if m.clearedwork_experiences {
		edges = append(edges, user.EdgeWorkExperiences)
	}
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	if m.clearedblog_posts {
		edges = append(edges, user.EdgeBlogPosts)
	}
	if m.clearedideas {
		edges = append(edges, user.EdgeIdeas)
	}
	if m.clearedresearch_projects {
		edges = append(edges, user.EdgeResearchProjects)
	}
	if m.clearedpublications {
		edges = append(edges, user.EdgePublications)
	}
	if m.clearedawards {
		edges = append(edges, user.EdgeAwards)
	}
	if m.clearedrecent_updates {
		edges = append(edges, user.EdgeRecentUpdates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePersonalInfos:
		return m.clearedpersonal_infos
	case user.EdgeEducations:
		return m.clearededucations
	case user.EdgeWorkExperiences:
		return m.clearedwork_experiences
	case user.EdgeProjects:
		return m.clearedprojects
	case user.EdgeBlogPosts:
		return m.clearedblog_posts
	case user.EdgeIdeas:
		return m.clearedideas
	case user.EdgeResearchProjects:
		return m.clearedresearch_projects
	case user.EdgePublications:
		return m.clearedpublications
	case user.EdgeAwards:
		return m.clearedawards
	case user.EdgeRecentUpdates:
		return m.clearedrecent_updates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePersonalInfos:
		m.ResetPersonalInfos()
		return nil
	case user.EdgeEducations:
		m.ResetEducations()
		return nil
	case user.EdgeWorkExperiences:
		m.ResetWorkExperiences()
		return nil
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	case user.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	case user.EdgeIdeas:
		m.ResetIdeas()
		return nil
	case user.EdgeResearchProjects:
		m.ResetResearchProjects()
		return nil
	case user.EdgePublications:
		m.ResetPublications()
		return nil
	case user.EdgeAwards:
		m.ResetAwards()
		return nil
	case user.EdgeRecentUpdates:
		m.ResetRecentUpdates()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkExperienceMutation represents an operation that mutates the WorkExperience nodes in the graph.
type WorkExperienceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	company             *string
	position            *string
	start_date          *time.Time
	end_date            *time.Time
	is_current          *bool
	location            *string
	company_website     *string
	company_logo_url    *string
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	translations        map[uuid.UUID]struct{}
	removedtranslations map[uuid.UUID]struct{}
	clearedtranslations bool
	details             map[uuid.UUID]struct{}
	removeddetails      map[uuid.UUID]struct{}
	cleareddetails      bool
	done                bool
	oldValue            func(context.Context) (*WorkExperience, error)
	predicates          []predicate.WorkExperience
}

var _ ent.Mutation = (*WorkExperienceMutation)(nil)

// workexperienceOption allows management of the mutation configuration using functional options.
type workexperienceOption func(*WorkExperienceMutation)

// newWorkExperienceMutation creates new mutation for the WorkExperience entity.
func newWorkExperienceMutation(c config, op Op, opts ...workexperienceOption) *WorkExperienceMutation {
	m := &WorkExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkExperienceID sets the ID field of the mutation.
func withWorkExperienceID(id uuid.UUID) workexperienceOption {
	return func(m *WorkExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkExperience
		)
		m.oldValue = func(ctx context.Context) (*WorkExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkExperience sets the old WorkExperience of the mutation.
func withWorkExperience(node *WorkExperience) workexperienceOption {
	return func(m *WorkExperienceMutation) {
		m.oldValue = func(context.Context) (*WorkExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkExperience entities.
func (m *WorkExperienceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkExperienceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkExperienceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *WorkExperienceMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WorkExperienceMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WorkExperienceMutation) ResetUserID() {
	m.user = nil
}

// SetCompany sets the "company" field.
func (m *WorkExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *WorkExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *WorkExperienceMutation) ResetCompany() {
	m.company = nil
}

// SetPosition sets the "position" field.
func (m *WorkExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *WorkExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *WorkExperienceMutation) ResetPosition() {
	m.position = nil
}

// SetStartDate sets the "start_date" field.
func (m *WorkExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *WorkExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *WorkExperienceMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[workexperience.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *WorkExperienceMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *WorkExperienceMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, workexperience.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *WorkExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *WorkExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *WorkExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[workexperience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *WorkExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *WorkExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, workexperience.FieldEndDate)
}

// SetIsCurrent sets the "is_current" field.
func (m *WorkExperienceMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *WorkExperienceMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *WorkExperienceMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetLocation sets the "location" field.
func (m *WorkExperienceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *WorkExperienceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *WorkExperienceMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[workexperience.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *WorkExperienceMutation) LocationCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *WorkExperienceMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, workexperience.FieldLocation)
}

// SetCompanyWebsite sets the "company_website" field.
func (m *WorkExperienceMutation) SetCompanyWebsite(s string) {
	m.company_website = &s
}

// CompanyWebsite returns the value of the "company_website" field in the mutation.
func (m *WorkExperienceMutation) CompanyWebsite() (r string, exists bool) {
	v := m.company_website
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyWebsite returns the old "company_website" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompanyWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyWebsite: %w", err)
	}
	return oldValue.CompanyWebsite, nil
}

// ClearCompanyWebsite clears the value of the "company_website" field.
func (m *WorkExperienceMutation) ClearCompanyWebsite() {
	m.company_website = nil
	m.clearedFields[workexperience.FieldCompanyWebsite] = struct{}{}
}

// CompanyWebsiteCleared returns if the "company_website" field was cleared in this mutation.
func (m *WorkExperienceMutation) CompanyWebsiteCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldCompanyWebsite]
	return ok
}

// ResetCompanyWebsite resets all changes to the "company_website" field.
func (m *WorkExperienceMutation) ResetCompanyWebsite() {
	m.company_website = nil
	delete(m.clearedFields, workexperience.FieldCompanyWebsite)
}

// SetCompanyLogoURL sets the "company_logo_url" field.
func (m *WorkExperienceMutation) SetCompanyLogoURL(s string) {
	m.company_logo_url = &s
}

// CompanyLogoURL returns the value of the "company_logo_url" field in the mutation.
func (m *WorkExperienceMutation) CompanyLogoURL() (r string, exists bool) {
	v := m.company_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyLogoURL returns the old "company_logo_url" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompanyLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyLogoURL: %w", err)
	}
	return oldValue.CompanyLogoURL, nil
}

// ClearCompanyLogoURL clears the value of the "company_logo_url" field.
func (m *WorkExperienceMutation) ClearCompanyLogoURL() {
	m.company_logo_url = nil
	m.clearedFields[workexperience.FieldCompanyLogoURL] = struct{}{}
}

// CompanyLogoURLCleared returns if the "company_logo_url" field was cleared in this mutation.
func (m *WorkExperienceMutation) CompanyLogoURLCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldCompanyLogoURL]
	return ok
}

// ResetCompanyLogoURL resets all changes to the "company_logo_url" field.
func (m *WorkExperienceMutation) ResetCompanyLogoURL() {
	m.company_logo_url = nil
	delete(m.clearedFields, workexperience.FieldCompanyLogoURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *WorkExperienceMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *WorkExperienceMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *WorkExperienceMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *WorkExperienceMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *WorkExperienceMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkExperienceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkExperienceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkExperienceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkExperienceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkExperienceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[workexperience.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkExperienceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkExperienceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTranslationIDs adds the "translations" edge to the WorkExperienceTranslation entity by ids.
func (m *WorkExperienceMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the WorkExperienceTranslation entity.
func (m *WorkExperienceMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the WorkExperienceTranslation entity was cleared.
func (m *WorkExperienceMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the WorkExperienceTranslation entity by IDs.
func (m *WorkExperienceMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the WorkExperienceTranslation entity.
func (m *WorkExperienceMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *WorkExperienceMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *WorkExperienceMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// AddDetailIDs adds the "details" edge to the WorkExperienceDetail entity by ids.
func (m *WorkExperienceMutation) AddDetailIDs(ids ...uuid.UUID) {
	if m.details == nil {
		m.details = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.details[ids[i]] = struct{}{}
	}
}

// ClearDetails clears the "details" edge to the WorkExperienceDetail entity.
func (m *WorkExperienceMutation) ClearDetails() {
	m.cleareddetails = true
}

// DetailsCleared reports if the "details" edge to the WorkExperienceDetail entity was cleared.
func (m *WorkExperienceMutation) DetailsCleared() bool {
	return m.cleareddetails
}

// RemoveDetailIDs removes the "details" edge to the WorkExperienceDetail entity by IDs.
func (m *WorkExperienceMutation) RemoveDetailIDs(ids ...uuid.UUID) {
	if m.removeddetails == nil {
		m.removeddetails = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.details, ids[i])
		m.removeddetails[ids[i]] = struct{}{}
	}
}

// RemovedDetails returns the removed IDs of the "details" edge to the WorkExperienceDetail entity.
func (m *WorkExperienceMutation) RemovedDetailsIDs() (ids []uuid.UUID) {
	for id := range m.removeddetails {
		ids = append(ids, id)
	}
	return
}

// DetailsIDs returns the "details" edge IDs in the mutation.
func (m *WorkExperienceMutation) DetailsIDs() (ids []uuid.UUID) {
	for id := range m.details {
		ids = append(ids, id)
	}
	return
}

// ResetDetails resets all changes to the "details" edge.
func (m *WorkExperienceMutation) ResetDetails() {
	m.details = nil
	m.cleareddetails = false
	m.removeddetails = nil
}

// Where appends a list predicates to the WorkExperienceMutation builder.
func (m *WorkExperienceMutation) Where(ps ...predicate.WorkExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkExperience).
func (m *WorkExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkExperienceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, workexperience.FieldUserID)
	}
	if m.company != nil {
		fields = append(fields, workexperience.FieldCompany)
	}
	if m.position != nil {
		fields = append(fields, workexperience.FieldPosition)
	}
	if m.start_date != nil {
		fields = append(fields, workexperience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, workexperience.FieldEndDate)
	}
	if m.is_current != nil {
		fields = append(fields, workexperience.FieldIsCurrent)
	}
	if m.location != nil {
		fields = append(fields, workexperience.FieldLocation)
	}
	if m.company_website != nil {
		fields = append(fields, workexperience.FieldCompanyWebsite)
	}
	if m.company_logo_url != nil {
		fields = append(fields, workexperience.FieldCompanyLogoURL)
	}
	if m.sort_order != nil {
		fields = append(fields, workexperience.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, workexperience.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workexperience.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workexperience.FieldUserID:
		return m.UserID()
	case workexperience.FieldCompany:
		return m.Company()
	case workexperience.FieldPosition:
		return m.Position()
	case workexperience.FieldStartDate:
		return m.StartDate()
	case workexperience.FieldEndDate:
		return m.EndDate()
	case workexperience.FieldIsCurrent:
		return m.IsCurrent()
	case workexperience.FieldLocation:
		return m.Location()
	case workexperience.FieldCompanyWebsite:
		return m.CompanyWebsite()
	case workexperience.FieldCompanyLogoURL:
		return m.CompanyLogoURL()
	case workexperience.FieldSortOrder:
		return m.SortOrder()
	case workexperience.FieldCreatedAt:
		return m.CreatedAt()
	case workexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workexperience.FieldUserID:
		return m.OldUserID(ctx)
	case workexperience.FieldCompany:
		return m.OldCompany(ctx)
	case workexperience.FieldPosition:
		return m.OldPosition(ctx)
	case workexperience.FieldStartDate:
		return m.OldStartDate(ctx)
	case workexperience.FieldEndDate:
		return m.OldEndDate(ctx)
	case workexperience.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case workexperience.FieldLocation:
		return m.OldLocation(ctx)
	case workexperience.FieldCompanyWebsite:
		return m.OldCompanyWebsite(ctx)
	case workexperience.FieldCompanyLogoURL:
		return m.OldCompanyLogoURL(ctx)
	case workexperience.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case workexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workexperience.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case workexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case workexperience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case workexperience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case workexperience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case workexperience.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case workexperience.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case workexperience.FieldCompanyWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyWebsite(v)
		return nil
	case workexperience.FieldCompanyLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyLogoURL(v)
		return nil
	case workexperience.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case workexperience.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workexperience.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkExperienceMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, workexperience.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workexperience.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workexperience.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workexperience.FieldStartDate) {
		fields = append(fields, workexperience.FieldStartDate)
	}
	if m.FieldCleared(workexperience.FieldEndDate) {
		fields = append(fields, workexperience.FieldEndDate)
	}
	if m.FieldCleared(workexperience.FieldLocation) {
		fields = append(fields, workexperience.FieldLocation)
	}
	if m.FieldCleared(workexperience.FieldCompanyWebsite) {
		fields = append(fields, workexperience.FieldCompanyWebsite)
	}
	if m.FieldCleared(workexperience.FieldCompanyLogoURL) {
		fields = append(fields, workexperience.FieldCompanyLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkExperienceMutation) ClearField(name string) error {
	switch name {
	case workexperience.FieldStartDate:
		m.ClearStartDate()
		return nil
	case workexperience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case workexperience.FieldLocation:
		m.ClearLocation()
		return nil
	case workexperience.FieldCompanyWebsite:
		m.ClearCompanyWebsite()
		return nil
	case workexperience.FieldCompanyLogoURL:
		m.ClearCompanyLogoURL()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkExperienceMutation) ResetField(name string) error {
	switch name {
	case workexperience.FieldUserID:
		m.ResetUserID()
		return nil
	case workexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case workexperience.FieldPosition:
		m.ResetPosition()
		return nil
	case workexperience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case workexperience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case workexperience.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case workexperience.FieldLocation:
		m.ResetLocation()
		return nil
	case workexperience.FieldCompanyWebsite:
		m.ResetCompanyWebsite()
		return nil
	case workexperience.FieldCompanyLogoURL:
		m.ResetCompanyLogoURL()
		return nil
	case workexperience.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case workexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, workexperience.EdgeUser)
	}
	if m.translations != nil {
		edges = append(edges, workexperience.EdgeTranslations)
	}
	if m.details != nil {
		edges = append(edges, workexperience.EdgeDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workexperience.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case workexperience.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	case workexperience.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.details))
		for id := range m.details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtranslations != nil {
		edges = append(edges, workexperience.EdgeTranslations)
	}
	if m.removeddetails != nil {
		edges = append(edges, workexperience.EdgeDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkExperienceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workexperience.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	case workexperience.EdgeDetails:
		ids := make([]ent.Value, 0, len(m.removeddetails))
		for id := range m.removeddetails {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, workexperience.EdgeUser)
	}
	if m.clearedtranslations {
		edges = append(edges, workexperience.EdgeTranslations)
	}
	if m.cleareddetails {
		edges = append(edges, workexperience.EdgeDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case workexperience.EdgeUser:
		return m.cleareduser
	case workexperience.EdgeTranslations:
		return m.clearedtranslations
	case workexperience.EdgeDetails:
		return m.cleareddetails
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkExperienceMutation) ClearEdge(name string) error {
	switch name {
	case workexperience.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkExperienceMutation) ResetEdge(name string) error {
	switch name {
	case workexperience.EdgeUser:
		m.ResetUser()
		return nil
	case workexperience.EdgeTranslations:
		m.ResetTranslations()
		return nil
	case workexperience.EdgeDetails:
		m.ResetDetails()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience edge %s", name)
}

// WorkExperienceDetailMutation represents an operation that mutates the WorkExperienceDetail nodes in the graph.
type WorkExperienceDetailMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	detail_text            *string
	sort_order             *int
	addsort_order          *int
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	work_experience        *uuid.UUID
	clearedwork_experience bool
	translations           map[uuid.UUID]struct{}
	removedtranslations    map[uuid.UUID]struct{}
	clearedtranslations    bool
	done                   bool
	oldValue               func(context.Context) (*WorkExperienceDetail, error)
	predicates             []predicate.WorkExperienceDetail
}

var _ ent.Mutation = (*WorkExperienceDetailMutation)(nil)

// workexperiencedetailOption allows management of the mutation configuration using functional options.
type workexperiencedetailOption func(*WorkExperienceDetailMutation)

// newWorkExperienceDetailMutation creates new mutation for the WorkExperienceDetail entity.
func newWorkExperienceDetailMutation(c config, op Op, opts ...workexperiencedetailOption) *WorkExperienceDetailMutation {
	m := &WorkExperienceDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkExperienceDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkExperienceDetailID sets the ID field of the mutation.
func withWorkExperienceDetailID(id uuid.UUID) workexperiencedetailOption {
	return func(m *WorkExperienceDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkExperienceDetail
		)
		m.oldValue = func(ctx context.Context) (*WorkExperienceDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkExperienceDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkExperienceDetail sets the old WorkExperienceDetail of the mutation.
func withWorkExperienceDetail(node *WorkExperienceDetail) workexperiencedetailOption {
	return func(m *WorkExperienceDetailMutation) {
		m.oldValue = func(context.Context) (*WorkExperienceDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkExperienceDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkExperienceDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkExperienceDetail entities.
func (m *WorkExperienceDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkExperienceDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkExperienceDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkExperienceDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkExperienceID sets the "work_experience_id" field.
func (m *WorkExperienceDetailMutation) SetWorkExperienceID(u uuid.UUID) {
	m.work_experience = &u
}

// WorkExperienceID returns the value of the "work_experience_id" field in the mutation.
func (m *WorkExperienceDetailMutation) WorkExperienceID() (r uuid.UUID, exists bool) {
	v := m.work_experience
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkExperienceID returns the old "work_experience_id" field's value of the WorkExperienceDetail entity.
// If the WorkExperienceDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailMutation) OldWorkExperienceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkExperienceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkExperienceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkExperienceID: %w", err)
	}
	return oldValue.WorkExperienceID, nil
}

// ResetWorkExperienceID resets all changes to the "work_experience_id" field.
func (m *WorkExperienceDetailMutation) ResetWorkExperienceID() {
	m.work_experience = nil
}

// SetDetailText sets the "detail_text" field.
func (m *WorkExperienceDetailMutation) SetDetailText(s string) {
	m.detail_text = &s
}

// DetailText returns the value of the "detail_text" field in the mutation.
func (m *WorkExperienceDetailMutation) DetailText() (r string, exists bool) {
	v := m.detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailText returns the old "detail_text" field's value of the WorkExperienceDetail entity.
// If the WorkExperienceDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailMutation) OldDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailText: %w", err)
	}
	return oldValue.DetailText, nil
}

// ResetDetailText resets all changes to the "detail_text" field.
func (m *WorkExperienceDetailMutation) ResetDetailText() {
	m.detail_text = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *WorkExperienceDetailMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *WorkExperienceDetailMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the WorkExperienceDetail entity.
// If the WorkExperienceDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *WorkExperienceDetailMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *WorkExperienceDetailMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *WorkExperienceDetailMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkExperienceDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkExperienceDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkExperienceDetail entity.
// If the WorkExperienceDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkExperienceDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkExperienceDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkExperienceDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkExperienceDetail entity.
// If the WorkExperienceDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkExperienceDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWorkExperience clears the "work_experience" edge to the WorkExperience entity.
func (m *WorkExperienceDetailMutation) ClearWorkExperience() {
	m.clearedwork_experience = true
	m.clearedFields[workexperiencedetail.FieldWorkExperienceID] = struct{}{}
}

// WorkExperienceCleared reports if the "work_experience" edge to the WorkExperience entity was cleared.
func (m *WorkExperienceDetailMutation) WorkExperienceCleared() bool {
	return m.clearedwork_experience
}

// WorkExperienceIDs returns the "work_experience" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkExperienceID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceDetailMutation) WorkExperienceIDs() (ids []uuid.UUID) {
	if id := m.work_experience; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkExperience resets all changes to the "work_experience" edge.
func (m *WorkExperienceDetailMutation) ResetWorkExperience() {
	m.work_experience = nil
	m.clearedwork_experience = false
}

// AddTranslationIDs adds the "translations" edge to the WorkExperienceDetailTranslation entity by ids.
func (m *WorkExperienceDetailMutation) AddTranslationIDs(ids ...uuid.UUID) {
	if m.translations == nil {
		m.translations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.translations[ids[i]] = struct{}{}
	}
}

// ClearTranslations clears the "translations" edge to the WorkExperienceDetailTranslation entity.
func (m *WorkExperienceDetailMutation) ClearTranslations() {
	m.clearedtranslations = true
}

// TranslationsCleared reports if the "translations" edge to the WorkExperienceDetailTranslation entity was cleared.
func (m *WorkExperienceDetailMutation) TranslationsCleared() bool {
	return m.clearedtranslations
}

// RemoveTranslationIDs removes the "translations" edge to the WorkExperienceDetailTranslation entity by IDs.
func (m *WorkExperienceDetailMutation) RemoveTranslationIDs(ids ...uuid.UUID) {
	if m.removedtranslations == nil {
		m.removedtranslations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.translations, ids[i])
		m.removedtranslations[ids[i]] = struct{}{}
	}
}

// RemovedTranslations returns the removed IDs of the "translations" edge to the WorkExperienceDetailTranslation entity.
func (m *WorkExperienceDetailMutation) RemovedTranslationsIDs() (ids []uuid.UUID) {
	for id := range m.removedtranslations {
		ids = append(ids, id)
	}
	return
}

// TranslationsIDs returns the "translations" edge IDs in the mutation.
func (m *WorkExperienceDetailMutation) TranslationsIDs() (ids []uuid.UUID) {
	for id := range m.translations {
		ids = append(ids, id)
	}
	return
}

// ResetTranslations resets all changes to the "translations" edge.
func (m *WorkExperienceDetailMutation) ResetTranslations() {
	m.translations = nil
	m.clearedtranslations = false
	m.removedtranslations = nil
}

// Where appends a list predicates to the WorkExperienceDetailMutation builder.
func (m *WorkExperienceDetailMutation) Where(ps ...predicate.WorkExperienceDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkExperienceDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkExperienceDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkExperienceDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkExperienceDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkExperienceDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkExperienceDetail).
func (m *WorkExperienceDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkExperienceDetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.work_experience != nil {
		fields = append(fields, workexperiencedetail.FieldWorkExperienceID)
	}
	if m.detail_text != nil {
		fields = append(fields, workexperiencedetail.FieldDetailText)
	}
	if m.sort_order != nil {
		fields = append(fields, workexperiencedetail.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, workexperiencedetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workexperiencedetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkExperienceDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workexperiencedetail.FieldWorkExperienceID:
		return m.WorkExperienceID()
	case workexperiencedetail.FieldDetailText:
		return m.DetailText()
	case workexperiencedetail.FieldSortOrder:
		return m.SortOrder()
	case workexperiencedetail.FieldCreatedAt:
		return m.CreatedAt()
	case workexperiencedetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkExperienceDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workexperiencedetail.FieldWorkExperienceID:
		return m.OldWorkExperienceID(ctx)
	case workexperiencedetail.FieldDetailText:
		return m.OldDetailText(ctx)
	case workexperiencedetail.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case workexperiencedetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workexperiencedetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkExperienceDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workexperiencedetail.FieldWorkExperienceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkExperienceID(v)
		return nil
	case workexperiencedetail.FieldDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailText(v)
		return nil
	case workexperiencedetail.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case workexperiencedetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workexperiencedetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkExperienceDetailMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, workexperiencedetail.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkExperienceDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workexperiencedetail.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workexperiencedetail.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkExperienceDetailMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkExperienceDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkExperienceDetailMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkExperienceDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkExperienceDetailMutation) ResetField(name string) error {
	switch name {
	case workexperiencedetail.FieldWorkExperienceID:
		m.ResetWorkExperienceID()
		return nil
	case workexperiencedetail.FieldDetailText:
		m.ResetDetailText()
		return nil
	case workexperiencedetail.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case workexperiencedetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workexperiencedetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkExperienceDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.work_experience != nil {
		edges = append(edges, workexperiencedetail.EdgeWorkExperience)
	}
	if m.translations != nil {
		edges = append(edges, workexperiencedetail.EdgeTranslations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkExperienceDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workexperiencedetail.EdgeWorkExperience:
		if id := m.work_experience; id != nil {
			return []ent.Value{*id}
		}
	case workexperiencedetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.translations))
		for id := range m.translations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkExperienceDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtranslations != nil {
		edges = append(edges, workexperiencedetail.EdgeTranslations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkExperienceDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workexperiencedetail.EdgeTranslations:
		ids := make([]ent.Value, 0, len(m.removedtranslations))
		for id := range m.removedtranslations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkExperienceDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwork_experience {
		edges = append(edges, workexperiencedetail.EdgeWorkExperience)
	}
	if m.clearedtranslations {
		edges = append(edges, workexperiencedetail.EdgeTranslations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkExperienceDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case workexperiencedetail.EdgeWorkExperience:
		return m.clearedwork_experience
	case workexperiencedetail.EdgeTranslations:
		return m.clearedtranslations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkExperienceDetailMutation) ClearEdge(name string) error {
	switch name {
	case workexperiencedetail.EdgeWorkExperience:
		m.ClearWorkExperience()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkExperienceDetailMutation) ResetEdge(name string) error {
	switch name {
	case workexperiencedetail.EdgeWorkExperience:
		m.ResetWorkExperience()
		return nil
	case workexperiencedetail.EdgeTranslations:
		m.ResetTranslations()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetail edge %s", name)
}

// WorkExperienceDetailTranslationMutation represents an operation that mutates the WorkExperienceDetailTranslation nodes in the graph.
type WorkExperienceDetailTranslationMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	detail_text                   *string
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	work_experience_detail        *uuid.UUID
	clearedwork_experience_detail bool
	language                      *string
	clearedlanguage               bool
	done                          bool
	oldValue                      func(context.Context) (*WorkExperienceDetailTranslation, error)
	predicates                    []predicate.WorkExperienceDetailTranslation
}

var _ ent.Mutation = (*WorkExperienceDetailTranslationMutation)(nil)

// workexperiencedetailtranslationOption allows management of the mutation configuration using functional options.
type workexperiencedetailtranslationOption func(*WorkExperienceDetailTranslationMutation)

// newWorkExperienceDetailTranslationMutation creates new mutation for the WorkExperienceDetailTranslation entity.
func newWorkExperienceDetailTranslationMutation(c config, op Op, opts ...workexperiencedetailtranslationOption) *WorkExperienceDetailTranslationMutation {
	m := &WorkExperienceDetailTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkExperienceDetailTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkExperienceDetailTranslationID sets the ID field of the mutation.
func withWorkExperienceDetailTranslationID(id uuid.UUID) workexperiencedetailtranslationOption {
	return func(m *WorkExperienceDetailTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkExperienceDetailTranslation
		)
		m.oldValue = func(ctx context.Context) (*WorkExperienceDetailTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkExperienceDetailTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkExperienceDetailTranslation sets the old WorkExperienceDetailTranslation of the mutation.
func withWorkExperienceDetailTranslation(node *WorkExperienceDetailTranslation) workexperiencedetailtranslationOption {
	return func(m *WorkExperienceDetailTranslationMutation) {
		m.oldValue = func(context.Context) (*WorkExperienceDetailTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkExperienceDetailTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkExperienceDetailTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkExperienceDetailTranslation entities.
func (m *WorkExperienceDetailTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkExperienceDetailTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkExperienceDetailTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkExperienceDetailTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkExperienceDetailID sets the "work_experience_detail_id" field.
func (m *WorkExperienceDetailTranslationMutation) SetWorkExperienceDetailID(u uuid.UUID) {
	m.work_experience_detail = &u
}

// WorkExperienceDetailID returns the value of the "work_experience_detail_id" field in the mutation.
func (m *WorkExperienceDetailTranslationMutation) WorkExperienceDetailID() (r uuid.UUID, exists bool) {
	v := m.work_experience_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkExperienceDetailID returns the old "work_experience_detail_id" field's value of the WorkExperienceDetailTranslation entity.
// If the WorkExperienceDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailTranslationMutation) OldWorkExperienceDetailID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkExperienceDetailID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkExperienceDetailID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkExperienceDetailID: %w", err)
	}
	return oldValue.WorkExperienceDetailID, nil
}

// ResetWorkExperienceDetailID resets all changes to the "work_experience_detail_id" field.
func (m *WorkExperienceDetailTranslationMutation) ResetWorkExperienceDetailID() {
	m.work_experience_detail = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *WorkExperienceDetailTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *WorkExperienceDetailTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the WorkExperienceDetailTranslation entity.
// If the WorkExperienceDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *WorkExperienceDetailTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetDetailText sets the "detail_text" field.
func (m *WorkExperienceDetailTranslationMutation) SetDetailText(s string) {
	m.detail_text = &s
}

// DetailText returns the value of the "detail_text" field in the mutation.
func (m *WorkExperienceDetailTranslationMutation) DetailText() (r string, exists bool) {
	v := m.detail_text
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailText returns the old "detail_text" field's value of the WorkExperienceDetailTranslation entity.
// If the WorkExperienceDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailTranslationMutation) OldDetailText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailText: %w", err)
	}
	return oldValue.DetailText, nil
}

// ResetDetailText resets all changes to the "detail_text" field.
func (m *WorkExperienceDetailTranslationMutation) ResetDetailText() {
	m.detail_text = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkExperienceDetailTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkExperienceDetailTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkExperienceDetailTranslation entity.
// If the WorkExperienceDetailTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceDetailTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkExperienceDetailTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearWorkExperienceDetail clears the "work_experience_detail" edge to the WorkExperienceDetail entity.
func (m *WorkExperienceDetailTranslationMutation) ClearWorkExperienceDetail() {
	m.clearedwork_experience_detail = true
	m.clearedFields[workexperiencedetailtranslation.FieldWorkExperienceDetailID] = struct{}{}
}

// WorkExperienceDetailCleared reports if the "work_experience_detail" edge to the WorkExperienceDetail entity was cleared.
func (m *WorkExperienceDetailTranslationMutation) WorkExperienceDetailCleared() bool {
	return m.clearedwork_experience_detail
}

// WorkExperienceDetailIDs returns the "work_experience_detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkExperienceDetailID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceDetailTranslationMutation) WorkExperienceDetailIDs() (ids []uuid.UUID) {
	if id := m.work_experience_detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkExperienceDetail resets all changes to the "work_experience_detail" edge.
func (m *WorkExperienceDetailTranslationMutation) ResetWorkExperienceDetail() {
	m.work_experience_detail = nil
	m.clearedwork_experience_detail = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *WorkExperienceDetailTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *WorkExperienceDetailTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[workexperiencedetailtranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *WorkExperienceDetailTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *WorkExperienceDetailTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceDetailTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *WorkExperienceDetailTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the WorkExperienceDetailTranslationMutation builder.
func (m *WorkExperienceDetailTranslationMutation) Where(ps ...predicate.WorkExperienceDetailTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkExperienceDetailTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkExperienceDetailTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkExperienceDetailTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkExperienceDetailTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkExperienceDetailTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkExperienceDetailTranslation).
func (m *WorkExperienceDetailTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkExperienceDetailTranslationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.work_experience_detail != nil {
		fields = append(fields, workexperiencedetailtranslation.FieldWorkExperienceDetailID)
	}
	if m.language != nil {
		fields = append(fields, workexperiencedetailtranslation.FieldLanguageCode)
	}
	if m.detail_text != nil {
		fields = append(fields, workexperiencedetailtranslation.FieldDetailText)
	}
	if m.created_at != nil {
		fields = append(fields, workexperiencedetailtranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkExperienceDetailTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workexperiencedetailtranslation.FieldWorkExperienceDetailID:
		return m.WorkExperienceDetailID()
	case workexperiencedetailtranslation.FieldLanguageCode:
		return m.LanguageCode()
	case workexperiencedetailtranslation.FieldDetailText:
		return m.DetailText()
	case workexperiencedetailtranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkExperienceDetailTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workexperiencedetailtranslation.FieldWorkExperienceDetailID:
		return m.OldWorkExperienceDetailID(ctx)
	case workexperiencedetailtranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case workexperiencedetailtranslation.FieldDetailText:
		return m.OldDetailText(ctx)
	case workexperiencedetailtranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkExperienceDetailTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceDetailTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workexperiencedetailtranslation.FieldWorkExperienceDetailID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkExperienceDetailID(v)
		return nil
	case workexperiencedetailtranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case workexperiencedetailtranslation.FieldDetailText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailText(v)
		return nil
	case workexperiencedetailtranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetailTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkExperienceDetailTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkExperienceDetailTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceDetailTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkExperienceDetailTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkExperienceDetailTranslationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkExperienceDetailTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkExperienceDetailTranslationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkExperienceDetailTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkExperienceDetailTranslationMutation) ResetField(name string) error {
	switch name {
	case workexperiencedetailtranslation.FieldWorkExperienceDetailID:
		m.ResetWorkExperienceDetailID()
		return nil
	case workexperiencedetailtranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case workexperiencedetailtranslation.FieldDetailText:
		m.ResetDetailText()
		return nil
	case workexperiencedetailtranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetailTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkExperienceDetailTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.work_experience_detail != nil {
		edges = append(edges, workexperiencedetailtranslation.EdgeWorkExperienceDetail)
	}
	if m.language != nil {
		edges = append(edges, workexperiencedetailtranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkExperienceDetailTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workexperiencedetailtranslation.EdgeWorkExperienceDetail:
		if id := m.work_experience_detail; id != nil {
			return []ent.Value{*id}
		}
	case workexperiencedetailtranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkExperienceDetailTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkExperienceDetailTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkExperienceDetailTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwork_experience_detail {
		edges = append(edges, workexperiencedetailtranslation.EdgeWorkExperienceDetail)
	}
	if m.clearedlanguage {
		edges = append(edges, workexperiencedetailtranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkExperienceDetailTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case workexperiencedetailtranslation.EdgeWorkExperienceDetail:
		return m.clearedwork_experience_detail
	case workexperiencedetailtranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkExperienceDetailTranslationMutation) ClearEdge(name string) error {
	switch name {
	case workexperiencedetailtranslation.EdgeWorkExperienceDetail:
		m.ClearWorkExperienceDetail()
		return nil
	case workexperiencedetailtranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetailTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkExperienceDetailTranslationMutation) ResetEdge(name string) error {
	switch name {
	case workexperiencedetailtranslation.EdgeWorkExperienceDetail:
		m.ResetWorkExperienceDetail()
		return nil
	case workexperiencedetailtranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceDetailTranslation edge %s", name)
}

// WorkExperienceTranslationMutation represents an operation that mutates the WorkExperienceTranslation nodes in the graph.
type WorkExperienceTranslationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	company                *string
	position               *string
	location               *string
	created_at             *time.Time
	clearedFields          map[string]struct{}
	work_experience        *uuid.UUID
	clearedwork_experience bool
	language               *string
	clearedlanguage        bool
	done                   bool
	oldValue               func(context.Context) (*WorkExperienceTranslation, error)
	predicates             []predicate.WorkExperienceTranslation
}

var _ ent.Mutation = (*WorkExperienceTranslationMutation)(nil)

// workexperiencetranslationOption allows management of the mutation configuration using functional options.
type workexperiencetranslationOption func(*WorkExperienceTranslationMutation)

// newWorkExperienceTranslationMutation creates new mutation for the WorkExperienceTranslation entity.
func newWorkExperienceTranslationMutation(c config, op Op, opts ...workexperiencetranslationOption) *WorkExperienceTranslationMutation {
	m := &WorkExperienceTranslationMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkExperienceTranslation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkExperienceTranslationID sets the ID field of the mutation.
func withWorkExperienceTranslationID(id uuid.UUID) workexperiencetranslationOption {
	return func(m *WorkExperienceTranslationMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkExperienceTranslation
		)
		m.oldValue = func(ctx context.Context) (*WorkExperienceTranslation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkExperienceTranslation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkExperienceTranslation sets the old WorkExperienceTranslation of the mutation.
func withWorkExperienceTranslation(node *WorkExperienceTranslation) workexperiencetranslationOption {
	return func(m *WorkExperienceTranslationMutation) {
		m.oldValue = func(context.Context) (*WorkExperienceTranslation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkExperienceTranslationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkExperienceTranslationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkExperienceTranslation entities.
func (m *WorkExperienceTranslationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkExperienceTranslationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkExperienceTranslationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkExperienceTranslation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkExperienceID sets the "work_experience_id" field.
func (m *WorkExperienceTranslationMutation) SetWorkExperienceID(u uuid.UUID) {
	m.work_experience = &u
}

// WorkExperienceID returns the value of the "work_experience_id" field in the mutation.
func (m *WorkExperienceTranslationMutation) WorkExperienceID() (r uuid.UUID, exists bool) {
	v := m.work_experience
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkExperienceID returns the old "work_experience_id" field's value of the WorkExperienceTranslation entity.
// If the WorkExperienceTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceTranslationMutation) OldWorkExperienceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkExperienceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkExperienceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkExperienceID: %w", err)
	}
	return oldValue.WorkExperienceID, nil
}

// ResetWorkExperienceID resets all changes to the "work_experience_id" field.
func (m *WorkExperienceTranslationMutation) ResetWorkExperienceID() {
	m.work_experience = nil
}

// SetLanguageCode sets the "language_code" field.
func (m *WorkExperienceTranslationMutation) SetLanguageCode(s string) {
	m.language = &s
}

// LanguageCode returns the value of the "language_code" field in the mutation.
func (m *WorkExperienceTranslationMutation) LanguageCode() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguageCode returns the old "language_code" field's value of the WorkExperienceTranslation entity.
// If the WorkExperienceTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceTranslationMutation) OldLanguageCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguageCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguageCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguageCode: %w", err)
	}
	return oldValue.LanguageCode, nil
}

// ResetLanguageCode resets all changes to the "language_code" field.
func (m *WorkExperienceTranslationMutation) ResetLanguageCode() {
	m.language = nil
}

// SetCompany sets the "company" field.
func (m *WorkExperienceTranslationMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *WorkExperienceTranslationMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the WorkExperienceTranslation entity.
// If the WorkExperienceTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceTranslationMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *WorkExperienceTranslationMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[workexperiencetranslation.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *WorkExperienceTranslationMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[workexperiencetranslation.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *WorkExperienceTranslationMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, workexperiencetranslation.FieldCompany)
}

// SetPosition sets the "position" field.
func (m *WorkExperienceTranslationMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *WorkExperienceTranslationMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the WorkExperienceTranslation entity.
// If the WorkExperienceTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceTranslationMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "position" field.
func (m *WorkExperienceTranslationMutation) ClearPosition() {
	m.position = nil
	m.clearedFields[workexperiencetranslation.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "position" field was cleared in this mutation.
func (m *WorkExperienceTranslationMutation) PositionCleared() bool {
	_, ok := m.clearedFields[workexperiencetranslation.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "position" field.
func (m *WorkExperienceTranslationMutation) ResetPosition() {
	m.position = nil
	delete(m.clearedFields, workexperiencetranslation.FieldPosition)
}

// SetLocation sets the "location" field.
func (m *WorkExperienceTranslationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *WorkExperienceTranslationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the WorkExperienceTranslation entity.
// If the WorkExperienceTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceTranslationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *WorkExperienceTranslationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[workexperiencetranslation.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *WorkExperienceTranslationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[workexperiencetranslation.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *WorkExperienceTranslationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, workexperiencetranslation.FieldLocation)
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkExperienceTranslationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkExperienceTranslationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkExperienceTranslation entity.
// If the WorkExperienceTranslation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceTranslationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkExperienceTranslationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearWorkExperience clears the "work_experience" edge to the WorkExperience entity.
func (m *WorkExperienceTranslationMutation) ClearWorkExperience() {
	m.clearedwork_experience = true
	m.clearedFields[workexperiencetranslation.FieldWorkExperienceID] = struct{}{}
}

// WorkExperienceCleared reports if the "work_experience" edge to the WorkExperience entity was cleared.
func (m *WorkExperienceTranslationMutation) WorkExperienceCleared() bool {
	return m.clearedwork_experience
}

// WorkExperienceIDs returns the "work_experience" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkExperienceID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceTranslationMutation) WorkExperienceIDs() (ids []uuid.UUID) {
	if id := m.work_experience; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkExperience resets all changes to the "work_experience" edge.
func (m *WorkExperienceTranslationMutation) ResetWorkExperience() {
	m.work_experience = nil
	m.clearedwork_experience = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *WorkExperienceTranslationMutation) SetLanguageID(id string) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *WorkExperienceTranslationMutation) ClearLanguage() {
	m.clearedlanguage = true
	m.clearedFields[workexperiencetranslation.FieldLanguageCode] = struct{}{}
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *WorkExperienceTranslationMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *WorkExperienceTranslationMutation) LanguageID() (id string, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceTranslationMutation) LanguageIDs() (ids []string) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *WorkExperienceTranslationMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// Where appends a list predicates to the WorkExperienceTranslationMutation builder.
func (m *WorkExperienceTranslationMutation) Where(ps ...predicate.WorkExperienceTranslation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkExperienceTranslationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkExperienceTranslationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkExperienceTranslation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkExperienceTranslationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkExperienceTranslationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkExperienceTranslation).
func (m *WorkExperienceTranslationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkExperienceTranslationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.work_experience != nil {
		fields = append(fields, workexperiencetranslation.FieldWorkExperienceID)
	}
	if m.language != nil {
		fields = append(fields, workexperiencetranslation.FieldLanguageCode)
	}
	if m.company != nil {
		fields = append(fields, workexperiencetranslation.FieldCompany)
	}
	if m.position != nil {
		fields = append(fields, workexperiencetranslation.FieldPosition)
	}
	if m.location != nil {
		fields = append(fields, workexperiencetranslation.FieldLocation)
	}
	if m.created_at != nil {
		fields = append(fields, workexperiencetranslation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkExperienceTranslationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workexperiencetranslation.FieldWorkExperienceID:
		return m.WorkExperienceID()
	case workexperiencetranslation.FieldLanguageCode:
		return m.LanguageCode()
	case workexperiencetranslation.FieldCompany:
		return m.Company()
	case workexperiencetranslation.FieldPosition:
		return m.Position()
	case workexperiencetranslation.FieldLocation:
		return m.Location()
	case workexperiencetranslation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkExperienceTranslationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workexperiencetranslation.FieldWorkExperienceID:
		return m.OldWorkExperienceID(ctx)
	case workexperiencetranslation.FieldLanguageCode:
		return m.OldLanguageCode(ctx)
	case workexperiencetranslation.FieldCompany:
		return m.OldCompany(ctx)
	case workexperiencetranslation.FieldPosition:
		return m.OldPosition(ctx)
	case workexperiencetranslation.FieldLocation:
		return m.OldLocation(ctx)
	case workexperiencetranslation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkExperienceTranslation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceTranslationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workexperiencetranslation.FieldWorkExperienceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkExperienceID(v)
		return nil
	case workexperiencetranslation.FieldLanguageCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguageCode(v)
		return nil
	case workexperiencetranslation.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case workexperiencetranslation.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case workexperiencetranslation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case workexperiencetranslation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceTranslation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkExperienceTranslationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkExperienceTranslationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceTranslationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkExperienceTranslation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkExperienceTranslationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workexperiencetranslation.FieldCompany) {
		fields = append(fields, workexperiencetranslation.FieldCompany)
	}
	if m.FieldCleared(workexperiencetranslation.FieldPosition) {
		fields = append(fields, workexperiencetranslation.FieldPosition)
	}
	if m.FieldCleared(workexperiencetranslation.FieldLocation) {
		fields = append(fields, workexperiencetranslation.FieldLocation)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkExperienceTranslationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkExperienceTranslationMutation) ClearField(name string) error {
	switch name {
	case workexperiencetranslation.FieldCompany:
		m.ClearCompany()
		return nil
	case workexperiencetranslation.FieldPosition:
		m.ClearPosition()
		return nil
	case workexperiencetranslation.FieldLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceTranslation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkExperienceTranslationMutation) ResetField(name string) error {
	switch name {
	case workexperiencetranslation.FieldWorkExperienceID:
		m.ResetWorkExperienceID()
		return nil
	case workexperiencetranslation.FieldLanguageCode:
		m.ResetLanguageCode()
		return nil
	case workexperiencetranslation.FieldCompany:
		m.ResetCompany()
		return nil
	case workexperiencetranslation.FieldPosition:
		m.ResetPosition()
		return nil
	case workexperiencetranslation.FieldLocation:
		m.ResetLocation()
		return nil
	case workexperiencetranslation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceTranslation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkExperienceTranslationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.work_experience != nil {
		edges = append(edges, workexperiencetranslation.EdgeWorkExperience)
	}
	if m.language != nil {
		edges = append(edges, workexperiencetranslation.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkExperienceTranslationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workexperiencetranslation.EdgeWorkExperience:
		if id := m.work_experience; id != nil {
			return []ent.Value{*id}
		}
	case workexperiencetranslation.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkExperienceTranslationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkExperienceTranslationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkExperienceTranslationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedwork_experience {
		edges = append(edges, workexperiencetranslation.EdgeWorkExperience)
	}
	if m.clearedlanguage {
		edges = append(edges, workexperiencetranslation.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkExperienceTranslationMutation) EdgeCleared(name string) bool {
	switch name {
	case workexperiencetranslation.EdgeWorkExperience:
		return m.clearedwork_experience
	case workexperiencetranslation.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkExperienceTranslationMutation) ClearEdge(name string) error {
	switch name {
	case workexperiencetranslation.EdgeWorkExperience:
		m.ClearWorkExperience()
		return nil
	case workexperiencetranslation.EdgeLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceTranslation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkExperienceTranslationMutation) ResetEdge(name string) error {
	switch name {
	case workexperiencetranslation.EdgeWorkExperience:
		m.ResetWorkExperience()
		return nil
	case workexperiencetranslation.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown WorkExperienceTranslation edge %s", name)
}
