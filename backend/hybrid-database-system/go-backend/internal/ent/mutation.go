// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"silan-backend/internal/ent/award"
	"silan-backend/internal/ent/blogcategory"
	"silan-backend/internal/ent/blogcomment"
	"silan-backend/internal/ent/blogpost"
	"silan-backend/internal/ent/blogseries"
	"silan-backend/internal/ent/blogtag"
	"silan-backend/internal/ent/education"
	"silan-backend/internal/ent/idea"
	"silan-backend/internal/ent/language"
	"silan-backend/internal/ent/personalinfo"
	"silan-backend/internal/ent/predicate"
	"silan-backend/internal/ent/project"
	"silan-backend/internal/ent/projectdetail"
	"silan-backend/internal/ent/projectimage"
	"silan-backend/internal/ent/projecttechnology"
	"silan-backend/internal/ent/publication"
	"silan-backend/internal/ent/researchproject"
	"silan-backend/internal/ent/sociallink"
	"silan-backend/internal/ent/user"
	"silan-backend/internal/ent/workexperience"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAward             = "Award"
	TypeBlogCategory      = "BlogCategory"
	TypeBlogComment       = "BlogComment"
	TypeBlogPost          = "BlogPost"
	TypeBlogSeries        = "BlogSeries"
	TypeBlogTag           = "BlogTag"
	TypeEducation         = "Education"
	TypeIdea              = "Idea"
	TypeLanguage          = "Language"
	TypePersonalInfo      = "PersonalInfo"
	TypeProject           = "Project"
	TypeProjectDetail     = "ProjectDetail"
	TypeProjectImage      = "ProjectImage"
	TypeProjectTechnology = "ProjectTechnology"
	TypePublication       = "Publication"
	TypeResearchProject   = "ResearchProject"
	TypeSocialLink        = "SocialLink"
	TypeUser              = "User"
	TypeWorkExperience    = "WorkExperience"
)

// AwardMutation represents an operation that mutates the Award nodes in the graph.
type AwardMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	title                 *string
	awarding_organization *string
	award_date            *time.Time
	award_type            *string
	amount                *float64
	addamount             *float64
	description           *string
	certificate_url       *string
	sort_order            *int
	addsort_order         *int
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*Award, error)
	predicates            []predicate.Award
}

var _ ent.Mutation = (*AwardMutation)(nil)

// awardOption allows management of the mutation configuration using functional options.
type awardOption func(*AwardMutation)

// newAwardMutation creates new mutation for the Award entity.
func newAwardMutation(c config, op Op, opts ...awardOption) *AwardMutation {
	m := &AwardMutation{
		config:        c,
		op:            op,
		typ:           TypeAward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAwardID sets the ID field of the mutation.
func withAwardID(id uuid.UUID) awardOption {
	return func(m *AwardMutation) {
		var (
			err   error
			once  sync.Once
			value *Award
		)
		m.oldValue = func(ctx context.Context) (*Award, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Award.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAward sets the old Award of the mutation.
func withAward(node *Award) awardOption {
	return func(m *AwardMutation) {
		m.oldValue = func(context.Context) (*Award, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AwardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AwardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Award entities.
func (m *AwardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AwardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AwardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Award.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *AwardMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AwardMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AwardMutation) ResetTitle() {
	m.title = nil
}

// SetAwardingOrganization sets the "awarding_organization" field.
func (m *AwardMutation) SetAwardingOrganization(s string) {
	m.awarding_organization = &s
}

// AwardingOrganization returns the value of the "awarding_organization" field in the mutation.
func (m *AwardMutation) AwardingOrganization() (r string, exists bool) {
	v := m.awarding_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardingOrganization returns the old "awarding_organization" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAwardingOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardingOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardingOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardingOrganization: %w", err)
	}
	return oldValue.AwardingOrganization, nil
}

// ResetAwardingOrganization resets all changes to the "awarding_organization" field.
func (m *AwardMutation) ResetAwardingOrganization() {
	m.awarding_organization = nil
}

// SetAwardDate sets the "award_date" field.
func (m *AwardMutation) SetAwardDate(t time.Time) {
	m.award_date = &t
}

// AwardDate returns the value of the "award_date" field in the mutation.
func (m *AwardMutation) AwardDate() (r time.Time, exists bool) {
	v := m.award_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardDate returns the old "award_date" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAwardDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardDate: %w", err)
	}
	return oldValue.AwardDate, nil
}

// ClearAwardDate clears the value of the "award_date" field.
func (m *AwardMutation) ClearAwardDate() {
	m.award_date = nil
	m.clearedFields[award.FieldAwardDate] = struct{}{}
}

// AwardDateCleared returns if the "award_date" field was cleared in this mutation.
func (m *AwardMutation) AwardDateCleared() bool {
	_, ok := m.clearedFields[award.FieldAwardDate]
	return ok
}

// ResetAwardDate resets all changes to the "award_date" field.
func (m *AwardMutation) ResetAwardDate() {
	m.award_date = nil
	delete(m.clearedFields, award.FieldAwardDate)
}

// SetAwardType sets the "award_type" field.
func (m *AwardMutation) SetAwardType(s string) {
	m.award_type = &s
}

// AwardType returns the value of the "award_type" field in the mutation.
func (m *AwardMutation) AwardType() (r string, exists bool) {
	v := m.award_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAwardType returns the old "award_type" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAwardType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwardType: %w", err)
	}
	return oldValue.AwardType, nil
}

// ClearAwardType clears the value of the "award_type" field.
func (m *AwardMutation) ClearAwardType() {
	m.award_type = nil
	m.clearedFields[award.FieldAwardType] = struct{}{}
}

// AwardTypeCleared returns if the "award_type" field was cleared in this mutation.
func (m *AwardMutation) AwardTypeCleared() bool {
	_, ok := m.clearedFields[award.FieldAwardType]
	return ok
}

// ResetAwardType resets all changes to the "award_type" field.
func (m *AwardMutation) ResetAwardType() {
	m.award_type = nil
	delete(m.clearedFields, award.FieldAwardType)
}

// SetAmount sets the "amount" field.
func (m *AwardMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AwardMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AwardMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AwardMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *AwardMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[award.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *AwardMutation) AmountCleared() bool {
	_, ok := m.clearedFields[award.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *AwardMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, award.FieldAmount)
}

// SetDescription sets the "description" field.
func (m *AwardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AwardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AwardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[award.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AwardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[award.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AwardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, award.FieldDescription)
}

// SetCertificateURL sets the "certificate_url" field.
func (m *AwardMutation) SetCertificateURL(s string) {
	m.certificate_url = &s
}

// CertificateURL returns the value of the "certificate_url" field in the mutation.
func (m *AwardMutation) CertificateURL() (r string, exists bool) {
	v := m.certificate_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateURL returns the old "certificate_url" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldCertificateURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateURL: %w", err)
	}
	return oldValue.CertificateURL, nil
}

// ClearCertificateURL clears the value of the "certificate_url" field.
func (m *AwardMutation) ClearCertificateURL() {
	m.certificate_url = nil
	m.clearedFields[award.FieldCertificateURL] = struct{}{}
}

// CertificateURLCleared returns if the "certificate_url" field was cleared in this mutation.
func (m *AwardMutation) CertificateURLCleared() bool {
	_, ok := m.clearedFields[award.FieldCertificateURL]
	return ok
}

// ResetCertificateURL resets all changes to the "certificate_url" field.
func (m *AwardMutation) ResetCertificateURL() {
	m.certificate_url = nil
	delete(m.clearedFields, award.FieldCertificateURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *AwardMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AwardMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *AwardMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AwardMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AwardMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AwardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AwardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AwardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AwardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AwardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Award entity.
// If the Award object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AwardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AwardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AwardMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AwardMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AwardMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AwardMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AwardMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AwardMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AwardMutation builder.
func (m *AwardMutation) Where(ps ...predicate.Award) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AwardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AwardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Award, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AwardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AwardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Award).
func (m *AwardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AwardMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.title != nil {
		fields = append(fields, award.FieldTitle)
	}
	if m.awarding_organization != nil {
		fields = append(fields, award.FieldAwardingOrganization)
	}
	if m.award_date != nil {
		fields = append(fields, award.FieldAwardDate)
	}
	if m.award_type != nil {
		fields = append(fields, award.FieldAwardType)
	}
	if m.amount != nil {
		fields = append(fields, award.FieldAmount)
	}
	if m.description != nil {
		fields = append(fields, award.FieldDescription)
	}
	if m.certificate_url != nil {
		fields = append(fields, award.FieldCertificateURL)
	}
	if m.sort_order != nil {
		fields = append(fields, award.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, award.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, award.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AwardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case award.FieldTitle:
		return m.Title()
	case award.FieldAwardingOrganization:
		return m.AwardingOrganization()
	case award.FieldAwardDate:
		return m.AwardDate()
	case award.FieldAwardType:
		return m.AwardType()
	case award.FieldAmount:
		return m.Amount()
	case award.FieldDescription:
		return m.Description()
	case award.FieldCertificateURL:
		return m.CertificateURL()
	case award.FieldSortOrder:
		return m.SortOrder()
	case award.FieldCreatedAt:
		return m.CreatedAt()
	case award.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AwardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case award.FieldTitle:
		return m.OldTitle(ctx)
	case award.FieldAwardingOrganization:
		return m.OldAwardingOrganization(ctx)
	case award.FieldAwardDate:
		return m.OldAwardDate(ctx)
	case award.FieldAwardType:
		return m.OldAwardType(ctx)
	case award.FieldAmount:
		return m.OldAmount(ctx)
	case award.FieldDescription:
		return m.OldDescription(ctx)
	case award.FieldCertificateURL:
		return m.OldCertificateURL(ctx)
	case award.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case award.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case award.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Award field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case award.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case award.FieldAwardingOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardingOrganization(v)
		return nil
	case award.FieldAwardDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardDate(v)
		return nil
	case award.FieldAwardType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwardType(v)
		return nil
	case award.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case award.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case award.FieldCertificateURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateURL(v)
		return nil
	case award.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case award.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case award.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Award field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AwardMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, award.FieldAmount)
	}
	if m.addsort_order != nil {
		fields = append(fields, award.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AwardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case award.FieldAmount:
		return m.AddedAmount()
	case award.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AwardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case award.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case award.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Award numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AwardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(award.FieldAwardDate) {
		fields = append(fields, award.FieldAwardDate)
	}
	if m.FieldCleared(award.FieldAwardType) {
		fields = append(fields, award.FieldAwardType)
	}
	if m.FieldCleared(award.FieldAmount) {
		fields = append(fields, award.FieldAmount)
	}
	if m.FieldCleared(award.FieldDescription) {
		fields = append(fields, award.FieldDescription)
	}
	if m.FieldCleared(award.FieldCertificateURL) {
		fields = append(fields, award.FieldCertificateURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AwardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AwardMutation) ClearField(name string) error {
	switch name {
	case award.FieldAwardDate:
		m.ClearAwardDate()
		return nil
	case award.FieldAwardType:
		m.ClearAwardType()
		return nil
	case award.FieldAmount:
		m.ClearAmount()
		return nil
	case award.FieldDescription:
		m.ClearDescription()
		return nil
	case award.FieldCertificateURL:
		m.ClearCertificateURL()
		return nil
	}
	return fmt.Errorf("unknown Award nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AwardMutation) ResetField(name string) error {
	switch name {
	case award.FieldTitle:
		m.ResetTitle()
		return nil
	case award.FieldAwardingOrganization:
		m.ResetAwardingOrganization()
		return nil
	case award.FieldAwardDate:
		m.ResetAwardDate()
		return nil
	case award.FieldAwardType:
		m.ResetAwardType()
		return nil
	case award.FieldAmount:
		m.ResetAmount()
		return nil
	case award.FieldDescription:
		m.ResetDescription()
		return nil
	case award.FieldCertificateURL:
		m.ResetCertificateURL()
		return nil
	case award.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case award.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case award.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Award field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AwardMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, award.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AwardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case award.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AwardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AwardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AwardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, award.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AwardMutation) EdgeCleared(name string) bool {
	switch name {
	case award.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AwardMutation) ClearEdge(name string) error {
	switch name {
	case award.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Award unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AwardMutation) ResetEdge(name string) error {
	switch name {
	case award.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Award edge %s", name)
}

// BlogCategoryMutation represents an operation that mutates the BlogCategory nodes in the graph.
type BlogCategoryMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	slug              *string
	description       *string
	color             *string
	icon              *string
	post_count        *int
	addpost_count     *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	blog_posts        map[uuid.UUID]struct{}
	removedblog_posts map[uuid.UUID]struct{}
	clearedblog_posts bool
	done              bool
	oldValue          func(context.Context) (*BlogCategory, error)
	predicates        []predicate.BlogCategory
}

var _ ent.Mutation = (*BlogCategoryMutation)(nil)

// blogcategoryOption allows management of the mutation configuration using functional options.
type blogcategoryOption func(*BlogCategoryMutation)

// newBlogCategoryMutation creates new mutation for the BlogCategory entity.
func newBlogCategoryMutation(c config, op Op, opts ...blogcategoryOption) *BlogCategoryMutation {
	m := &BlogCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogCategoryID sets the ID field of the mutation.
func withBlogCategoryID(id uuid.UUID) blogcategoryOption {
	return func(m *BlogCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogCategory
		)
		m.oldValue = func(ctx context.Context) (*BlogCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogCategory sets the old BlogCategory of the mutation.
func withBlogCategory(node *BlogCategory) blogcategoryOption {
	return func(m *BlogCategoryMutation) {
		m.oldValue = func(context.Context) (*BlogCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogCategory entities.
func (m *BlogCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BlogCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlogCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlogCategoryMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *BlogCategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogCategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogCategoryMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BlogCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogcategory.FieldDescription)
}

// SetColor sets the "color" field.
func (m *BlogCategoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *BlogCategoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *BlogCategoryMutation) ClearColor() {
	m.color = nil
	m.clearedFields[blogcategory.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *BlogCategoryMutation) ColorCleared() bool {
	_, ok := m.clearedFields[blogcategory.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *BlogCategoryMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, blogcategory.FieldColor)
}

// SetIcon sets the "icon" field.
func (m *BlogCategoryMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *BlogCategoryMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *BlogCategoryMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[blogcategory.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *BlogCategoryMutation) IconCleared() bool {
	_, ok := m.clearedFields[blogcategory.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *BlogCategoryMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, blogcategory.FieldIcon)
}

// SetPostCount sets the "post_count" field.
func (m *BlogCategoryMutation) SetPostCount(i int) {
	m.post_count = &i
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *BlogCategoryMutation) PostCount() (r int, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldPostCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds i to the "post_count" field.
func (m *BlogCategoryMutation) AddPostCount(i int) {
	if m.addpost_count != nil {
		*m.addpost_count += i
	} else {
		m.addpost_count = &i
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *BlogCategoryMutation) AddedPostCount() (r int, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *BlogCategoryMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogCategory entity.
// If the BlogCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *BlogCategoryMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *BlogCategoryMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *BlogCategoryMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *BlogCategoryMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *BlogCategoryMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *BlogCategoryMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *BlogCategoryMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// Where appends a list predicates to the BlogCategoryMutation builder.
func (m *BlogCategoryMutation) Where(ps ...predicate.BlogCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogCategory).
func (m *BlogCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, blogcategory.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, blogcategory.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, blogcategory.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, blogcategory.FieldColor)
	}
	if m.icon != nil {
		fields = append(fields, blogcategory.FieldIcon)
	}
	if m.post_count != nil {
		fields = append(fields, blogcategory.FieldPostCount)
	}
	if m.created_at != nil {
		fields = append(fields, blogcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogcategory.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogcategory.FieldName:
		return m.Name()
	case blogcategory.FieldSlug:
		return m.Slug()
	case blogcategory.FieldDescription:
		return m.Description()
	case blogcategory.FieldColor:
		return m.Color()
	case blogcategory.FieldIcon:
		return m.Icon()
	case blogcategory.FieldPostCount:
		return m.PostCount()
	case blogcategory.FieldCreatedAt:
		return m.CreatedAt()
	case blogcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogcategory.FieldName:
		return m.OldName(ctx)
	case blogcategory.FieldSlug:
		return m.OldSlug(ctx)
	case blogcategory.FieldDescription:
		return m.OldDescription(ctx)
	case blogcategory.FieldColor:
		return m.OldColor(ctx)
	case blogcategory.FieldIcon:
		return m.OldIcon(ctx)
	case blogcategory.FieldPostCount:
		return m.OldPostCount(ctx)
	case blogcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blogcategory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogcategory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case blogcategory.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case blogcategory.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	case blogcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addpost_count != nil {
		fields = append(fields, blogcategory.FieldPostCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogcategory.FieldPostCount:
		return m.AddedPostCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogcategory.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown BlogCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogcategory.FieldDescription) {
		fields = append(fields, blogcategory.FieldDescription)
	}
	if m.FieldCleared(blogcategory.FieldColor) {
		fields = append(fields, blogcategory.FieldColor)
	}
	if m.FieldCleared(blogcategory.FieldIcon) {
		fields = append(fields, blogcategory.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogCategoryMutation) ClearField(name string) error {
	switch name {
	case blogcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case blogcategory.FieldColor:
		m.ClearColor()
		return nil
	case blogcategory.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown BlogCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogCategoryMutation) ResetField(name string) error {
	switch name {
	case blogcategory.FieldName:
		m.ResetName()
		return nil
	case blogcategory.FieldSlug:
		m.ResetSlug()
		return nil
	case blogcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case blogcategory.FieldColor:
		m.ResetColor()
		return nil
	case blogcategory.FieldIcon:
		m.ResetIcon()
		return nil
	case blogcategory.FieldPostCount:
		m.ResetPostCount()
		return nil
	case blogcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.blog_posts != nil {
		edges = append(edges, blogcategory.EdgeBlogPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogcategory.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedblog_posts != nil {
		edges = append(edges, blogcategory.EdgeBlogPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogcategory.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblog_posts {
		edges = append(edges, blogcategory.EdgeBlogPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case blogcategory.EdgeBlogPosts:
		return m.clearedblog_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogCategoryMutation) ResetEdge(name string) error {
	switch name {
	case blogcategory.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	}
	return fmt.Errorf("unknown BlogCategory edge %s", name)
}

// BlogCommentMutation represents an operation that mutates the BlogComment nodes in the graph.
type BlogCommentMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	blog_post_id     *uuid.UUID
	author_name      *string
	author_email     *string
	author_website   *string
	content          *string
	is_approved      *bool
	is_spam          *bool
	ip_address       *string
	user_agent       *string
	like_count       *int
	addlike_count    *int
	dislike_count    *int
	adddislike_count *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	post             *uuid.UUID
	clearedpost      bool
	parent           *uuid.UUID
	clearedparent    bool
	replies          map[uuid.UUID]struct{}
	removedreplies   map[uuid.UUID]struct{}
	clearedreplies   bool
	done             bool
	oldValue         func(context.Context) (*BlogComment, error)
	predicates       []predicate.BlogComment
}

var _ ent.Mutation = (*BlogCommentMutation)(nil)

// blogcommentOption allows management of the mutation configuration using functional options.
type blogcommentOption func(*BlogCommentMutation)

// newBlogCommentMutation creates new mutation for the BlogComment entity.
func newBlogCommentMutation(c config, op Op, opts ...blogcommentOption) *BlogCommentMutation {
	m := &BlogCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogCommentID sets the ID field of the mutation.
func withBlogCommentID(id uuid.UUID) blogcommentOption {
	return func(m *BlogCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogComment
		)
		m.oldValue = func(ctx context.Context) (*BlogComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogComment sets the old BlogComment of the mutation.
func withBlogComment(node *BlogComment) blogcommentOption {
	return func(m *BlogCommentMutation) {
		m.oldValue = func(context.Context) (*BlogComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogComment entities.
func (m *BlogCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlogPostID sets the "blog_post_id" field.
func (m *BlogCommentMutation) SetBlogPostID(u uuid.UUID) {
	m.blog_post_id = &u
}

// BlogPostID returns the value of the "blog_post_id" field in the mutation.
func (m *BlogCommentMutation) BlogPostID() (r uuid.UUID, exists bool) {
	v := m.blog_post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBlogPostID returns the old "blog_post_id" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldBlogPostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlogPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlogPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlogPostID: %w", err)
	}
	return oldValue.BlogPostID, nil
}

// ResetBlogPostID resets all changes to the "blog_post_id" field.
func (m *BlogCommentMutation) ResetBlogPostID() {
	m.blog_post_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *BlogCommentMutation) SetParentID(u uuid.UUID) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BlogCommentMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *BlogCommentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[blogcomment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *BlogCommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BlogCommentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, blogcomment.FieldParentID)
}

// SetAuthorName sets the "author_name" field.
func (m *BlogCommentMutation) SetAuthorName(s string) {
	m.author_name = &s
}

// AuthorName returns the value of the "author_name" field in the mutation.
func (m *BlogCommentMutation) AuthorName() (r string, exists bool) {
	v := m.author_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorName returns the old "author_name" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldAuthorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorName: %w", err)
	}
	return oldValue.AuthorName, nil
}

// ResetAuthorName resets all changes to the "author_name" field.
func (m *BlogCommentMutation) ResetAuthorName() {
	m.author_name = nil
}

// SetAuthorEmail sets the "author_email" field.
func (m *BlogCommentMutation) SetAuthorEmail(s string) {
	m.author_email = &s
}

// AuthorEmail returns the value of the "author_email" field in the mutation.
func (m *BlogCommentMutation) AuthorEmail() (r string, exists bool) {
	v := m.author_email
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorEmail returns the old "author_email" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldAuthorEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorEmail: %w", err)
	}
	return oldValue.AuthorEmail, nil
}

// ResetAuthorEmail resets all changes to the "author_email" field.
func (m *BlogCommentMutation) ResetAuthorEmail() {
	m.author_email = nil
}

// SetAuthorWebsite sets the "author_website" field.
func (m *BlogCommentMutation) SetAuthorWebsite(s string) {
	m.author_website = &s
}

// AuthorWebsite returns the value of the "author_website" field in the mutation.
func (m *BlogCommentMutation) AuthorWebsite() (r string, exists bool) {
	v := m.author_website
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorWebsite returns the old "author_website" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldAuthorWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorWebsite: %w", err)
	}
	return oldValue.AuthorWebsite, nil
}

// ClearAuthorWebsite clears the value of the "author_website" field.
func (m *BlogCommentMutation) ClearAuthorWebsite() {
	m.author_website = nil
	m.clearedFields[blogcomment.FieldAuthorWebsite] = struct{}{}
}

// AuthorWebsiteCleared returns if the "author_website" field was cleared in this mutation.
func (m *BlogCommentMutation) AuthorWebsiteCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldAuthorWebsite]
	return ok
}

// ResetAuthorWebsite resets all changes to the "author_website" field.
func (m *BlogCommentMutation) ResetAuthorWebsite() {
	m.author_website = nil
	delete(m.clearedFields, blogcomment.FieldAuthorWebsite)
}

// SetContent sets the "content" field.
func (m *BlogCommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogCommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogCommentMutation) ResetContent() {
	m.content = nil
}

// SetIsApproved sets the "is_approved" field.
func (m *BlogCommentMutation) SetIsApproved(b bool) {
	m.is_approved = &b
}

// IsApproved returns the value of the "is_approved" field in the mutation.
func (m *BlogCommentMutation) IsApproved() (r bool, exists bool) {
	v := m.is_approved
	if v == nil {
		return
	}
	return *v, true
}

// OldIsApproved returns the old "is_approved" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldIsApproved(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsApproved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsApproved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsApproved: %w", err)
	}
	return oldValue.IsApproved, nil
}

// ResetIsApproved resets all changes to the "is_approved" field.
func (m *BlogCommentMutation) ResetIsApproved() {
	m.is_approved = nil
}

// SetIsSpam sets the "is_spam" field.
func (m *BlogCommentMutation) SetIsSpam(b bool) {
	m.is_spam = &b
}

// IsSpam returns the value of the "is_spam" field in the mutation.
func (m *BlogCommentMutation) IsSpam() (r bool, exists bool) {
	v := m.is_spam
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSpam returns the old "is_spam" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldIsSpam(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSpam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSpam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSpam: %w", err)
	}
	return oldValue.IsSpam, nil
}

// ResetIsSpam resets all changes to the "is_spam" field.
func (m *BlogCommentMutation) ResetIsSpam() {
	m.is_spam = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *BlogCommentMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *BlogCommentMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *BlogCommentMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[blogcomment.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *BlogCommentMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *BlogCommentMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, blogcomment.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *BlogCommentMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *BlogCommentMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *BlogCommentMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[blogcomment.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *BlogCommentMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[blogcomment.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *BlogCommentMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, blogcomment.FieldUserAgent)
}

// SetLikeCount sets the "like_count" field.
func (m *BlogCommentMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *BlogCommentMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *BlogCommentMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *BlogCommentMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *BlogCommentMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetDislikeCount sets the "dislike_count" field.
func (m *BlogCommentMutation) SetDislikeCount(i int) {
	m.dislike_count = &i
	m.adddislike_count = nil
}

// DislikeCount returns the value of the "dislike_count" field in the mutation.
func (m *BlogCommentMutation) DislikeCount() (r int, exists bool) {
	v := m.dislike_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDislikeCount returns the old "dislike_count" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldDislikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDislikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDislikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDislikeCount: %w", err)
	}
	return oldValue.DislikeCount, nil
}

// AddDislikeCount adds i to the "dislike_count" field.
func (m *BlogCommentMutation) AddDislikeCount(i int) {
	if m.adddislike_count != nil {
		*m.adddislike_count += i
	} else {
		m.adddislike_count = &i
	}
}

// AddedDislikeCount returns the value that was added to the "dislike_count" field in this mutation.
func (m *BlogCommentMutation) AddedDislikeCount() (r int, exists bool) {
	v := m.adddislike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDislikeCount resets all changes to the "dislike_count" field.
func (m *BlogCommentMutation) ResetDislikeCount() {
	m.dislike_count = nil
	m.adddislike_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogComment entity.
// If the BlogComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPostID sets the "post" edge to the BlogPost entity by id.
func (m *BlogCommentMutation) SetPostID(id uuid.UUID) {
	m.post = &id
}

// ClearPost clears the "post" edge to the BlogPost entity.
func (m *BlogCommentMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the BlogPost entity was cleared.
func (m *BlogCommentMutation) PostCleared() bool {
	return m.clearedpost
}

// PostID returns the "post" edge ID in the mutation.
func (m *BlogCommentMutation) PostID() (id uuid.UUID, exists bool) {
	if m.post != nil {
		return *m.post, true
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostID instead. It exists only for internal usage by the builders.
func (m *BlogCommentMutation) PostIDs() (ids []uuid.UUID) {
	if id := m.post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *BlogCommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
}

// ClearParent clears the "parent" edge to the BlogComment entity.
func (m *BlogCommentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[blogcomment.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the BlogComment entity was cleared.
func (m *BlogCommentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BlogCommentMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BlogCommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddReplyIDs adds the "replies" edge to the BlogComment entity by ids.
func (m *BlogCommentMutation) AddReplyIDs(ids ...uuid.UUID) {
	if m.replies == nil {
		m.replies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the BlogComment entity.
func (m *BlogCommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the BlogComment entity was cleared.
func (m *BlogCommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the BlogComment entity by IDs.
func (m *BlogCommentMutation) RemoveReplyIDs(ids ...uuid.UUID) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the BlogComment entity.
func (m *BlogCommentMutation) RemovedRepliesIDs() (ids []uuid.UUID) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *BlogCommentMutation) RepliesIDs() (ids []uuid.UUID) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *BlogCommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// Where appends a list predicates to the BlogCommentMutation builder.
func (m *BlogCommentMutation) Where(ps ...predicate.BlogComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogComment).
func (m *BlogCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogCommentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.blog_post_id != nil {
		fields = append(fields, blogcomment.FieldBlogPostID)
	}
	if m.parent != nil {
		fields = append(fields, blogcomment.FieldParentID)
	}
	if m.author_name != nil {
		fields = append(fields, blogcomment.FieldAuthorName)
	}
	if m.author_email != nil {
		fields = append(fields, blogcomment.FieldAuthorEmail)
	}
	if m.author_website != nil {
		fields = append(fields, blogcomment.FieldAuthorWebsite)
	}
	if m.content != nil {
		fields = append(fields, blogcomment.FieldContent)
	}
	if m.is_approved != nil {
		fields = append(fields, blogcomment.FieldIsApproved)
	}
	if m.is_spam != nil {
		fields = append(fields, blogcomment.FieldIsSpam)
	}
	if m.ip_address != nil {
		fields = append(fields, blogcomment.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, blogcomment.FieldUserAgent)
	}
	if m.like_count != nil {
		fields = append(fields, blogcomment.FieldLikeCount)
	}
	if m.dislike_count != nil {
		fields = append(fields, blogcomment.FieldDislikeCount)
	}
	if m.created_at != nil {
		fields = append(fields, blogcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogcomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogcomment.FieldBlogPostID:
		return m.BlogPostID()
	case blogcomment.FieldParentID:
		return m.ParentID()
	case blogcomment.FieldAuthorName:
		return m.AuthorName()
	case blogcomment.FieldAuthorEmail:
		return m.AuthorEmail()
	case blogcomment.FieldAuthorWebsite:
		return m.AuthorWebsite()
	case blogcomment.FieldContent:
		return m.Content()
	case blogcomment.FieldIsApproved:
		return m.IsApproved()
	case blogcomment.FieldIsSpam:
		return m.IsSpam()
	case blogcomment.FieldIPAddress:
		return m.IPAddress()
	case blogcomment.FieldUserAgent:
		return m.UserAgent()
	case blogcomment.FieldLikeCount:
		return m.LikeCount()
	case blogcomment.FieldDislikeCount:
		return m.DislikeCount()
	case blogcomment.FieldCreatedAt:
		return m.CreatedAt()
	case blogcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogcomment.FieldBlogPostID:
		return m.OldBlogPostID(ctx)
	case blogcomment.FieldParentID:
		return m.OldParentID(ctx)
	case blogcomment.FieldAuthorName:
		return m.OldAuthorName(ctx)
	case blogcomment.FieldAuthorEmail:
		return m.OldAuthorEmail(ctx)
	case blogcomment.FieldAuthorWebsite:
		return m.OldAuthorWebsite(ctx)
	case blogcomment.FieldContent:
		return m.OldContent(ctx)
	case blogcomment.FieldIsApproved:
		return m.OldIsApproved(ctx)
	case blogcomment.FieldIsSpam:
		return m.OldIsSpam(ctx)
	case blogcomment.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case blogcomment.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case blogcomment.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case blogcomment.FieldDislikeCount:
		return m.OldDislikeCount(ctx)
	case blogcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogcomment.FieldBlogPostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlogPostID(v)
		return nil
	case blogcomment.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case blogcomment.FieldAuthorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorName(v)
		return nil
	case blogcomment.FieldAuthorEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorEmail(v)
		return nil
	case blogcomment.FieldAuthorWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorWebsite(v)
		return nil
	case blogcomment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogcomment.FieldIsApproved:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsApproved(v)
		return nil
	case blogcomment.FieldIsSpam:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSpam(v)
		return nil
	case blogcomment.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case blogcomment.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case blogcomment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case blogcomment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDislikeCount(v)
		return nil
	case blogcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogCommentMutation) AddedFields() []string {
	var fields []string
	if m.addlike_count != nil {
		fields = append(fields, blogcomment.FieldLikeCount)
	}
	if m.adddislike_count != nil {
		fields = append(fields, blogcomment.FieldDislikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogcomment.FieldLikeCount:
		return m.AddedLikeCount()
	case blogcomment.FieldDislikeCount:
		return m.AddedDislikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogcomment.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case blogcomment.FieldDislikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDislikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown BlogComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogCommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogcomment.FieldParentID) {
		fields = append(fields, blogcomment.FieldParentID)
	}
	if m.FieldCleared(blogcomment.FieldAuthorWebsite) {
		fields = append(fields, blogcomment.FieldAuthorWebsite)
	}
	if m.FieldCleared(blogcomment.FieldIPAddress) {
		fields = append(fields, blogcomment.FieldIPAddress)
	}
	if m.FieldCleared(blogcomment.FieldUserAgent) {
		fields = append(fields, blogcomment.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogCommentMutation) ClearField(name string) error {
	switch name {
	case blogcomment.FieldParentID:
		m.ClearParentID()
		return nil
	case blogcomment.FieldAuthorWebsite:
		m.ClearAuthorWebsite()
		return nil
	case blogcomment.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case blogcomment.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown BlogComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogCommentMutation) ResetField(name string) error {
	switch name {
	case blogcomment.FieldBlogPostID:
		m.ResetBlogPostID()
		return nil
	case blogcomment.FieldParentID:
		m.ResetParentID()
		return nil
	case blogcomment.FieldAuthorName:
		m.ResetAuthorName()
		return nil
	case blogcomment.FieldAuthorEmail:
		m.ResetAuthorEmail()
		return nil
	case blogcomment.FieldAuthorWebsite:
		m.ResetAuthorWebsite()
		return nil
	case blogcomment.FieldContent:
		m.ResetContent()
		return nil
	case blogcomment.FieldIsApproved:
		m.ResetIsApproved()
		return nil
	case blogcomment.FieldIsSpam:
		m.ResetIsSpam()
		return nil
	case blogcomment.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case blogcomment.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case blogcomment.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case blogcomment.FieldDislikeCount:
		m.ResetDislikeCount()
		return nil
	case blogcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.post != nil {
		edges = append(edges, blogcomment.EdgePost)
	}
	if m.parent != nil {
		edges = append(edges, blogcomment.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, blogcomment.EdgeReplies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogcomment.EdgePost:
		if id := m.post; id != nil {
			return []ent.Value{*id}
		}
	case blogcomment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case blogcomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreplies != nil {
		edges = append(edges, blogcomment.EdgeReplies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogCommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogcomment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpost {
		edges = append(edges, blogcomment.EdgePost)
	}
	if m.clearedparent {
		edges = append(edges, blogcomment.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, blogcomment.EdgeReplies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case blogcomment.EdgePost:
		return m.clearedpost
	case blogcomment.EdgeParent:
		return m.clearedparent
	case blogcomment.EdgeReplies:
		return m.clearedreplies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogCommentMutation) ClearEdge(name string) error {
	switch name {
	case blogcomment.EdgePost:
		m.ClearPost()
		return nil
	case blogcomment.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BlogComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogCommentMutation) ResetEdge(name string) error {
	switch name {
	case blogcomment.EdgePost:
		m.ResetPost()
		return nil
	case blogcomment.EdgeParent:
		m.ResetParent()
		return nil
	case blogcomment.EdgeReplies:
		m.ResetReplies()
		return nil
	}
	return fmt.Errorf("unknown BlogComment edge %s", name)
}

// BlogPostMutation represents an operation that mutates the BlogPost nodes in the graph.
type BlogPostMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	title                   *string
	slug                    *string
	excerpt                 *string
	content                 *string
	content_type            *blogpost.ContentType
	status                  *blogpost.Status
	is_featured             *bool
	featured_image_url      *string
	reading_time_minutes    *int
	addreading_time_minutes *int
	view_count              *int
	addview_count           *int
	like_count              *int
	addlike_count           *int
	comment_count           *int
	addcomment_count        *int
	published_at            *time.Time
	series_order            *int
	addseries_order         *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	user                    *uuid.UUID
	cleareduser             bool
	category                *uuid.UUID
	clearedcategory         bool
	series                  *uuid.UUID
	clearedseries           bool
	tags                    map[uuid.UUID]struct{}
	removedtags             map[uuid.UUID]struct{}
	clearedtags             bool
	comments                map[uuid.UUID]struct{}
	removedcomments         map[uuid.UUID]struct{}
	clearedcomments         bool
	done                    bool
	oldValue                func(context.Context) (*BlogPost, error)
	predicates              []predicate.BlogPost
}

var _ ent.Mutation = (*BlogPostMutation)(nil)

// blogpostOption allows management of the mutation configuration using functional options.
type blogpostOption func(*BlogPostMutation)

// newBlogPostMutation creates new mutation for the BlogPost entity.
func newBlogPostMutation(c config, op Op, opts ...blogpostOption) *BlogPostMutation {
	m := &BlogPostMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogPostID sets the ID field of the mutation.
func withBlogPostID(id uuid.UUID) blogpostOption {
	return func(m *BlogPostMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogPost
		)
		m.oldValue = func(ctx context.Context) (*BlogPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogPost sets the old BlogPost of the mutation.
func withBlogPost(node *BlogPost) blogpostOption {
	return func(m *BlogPostMutation) {
		m.oldValue = func(context.Context) (*BlogPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogPost entities.
func (m *BlogPostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogPostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogPostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *BlogPostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogPostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogPostMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *BlogPostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogPostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogPostMutation) ResetSlug() {
	m.slug = nil
}

// SetExcerpt sets the "excerpt" field.
func (m *BlogPostMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *BlogPostMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *BlogPostMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[blogpost.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *BlogPostMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *BlogPostMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, blogpost.FieldExcerpt)
}

// SetContent sets the "content" field.
func (m *BlogPostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *BlogPostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *BlogPostMutation) ResetContent() {
	m.content = nil
}

// SetContentType sets the "content_type" field.
func (m *BlogPostMutation) SetContentType(bt blogpost.ContentType) {
	m.content_type = &bt
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *BlogPostMutation) ContentType() (r blogpost.ContentType, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldContentType(ctx context.Context) (v blogpost.ContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *BlogPostMutation) ResetContentType() {
	m.content_type = nil
}

// SetStatus sets the "status" field.
func (m *BlogPostMutation) SetStatus(b blogpost.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BlogPostMutation) Status() (r blogpost.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldStatus(ctx context.Context) (v blogpost.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BlogPostMutation) ResetStatus() {
	m.status = nil
}

// SetIsFeatured sets the "is_featured" field.
func (m *BlogPostMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *BlogPostMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *BlogPostMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// SetFeaturedImageURL sets the "featured_image_url" field.
func (m *BlogPostMutation) SetFeaturedImageURL(s string) {
	m.featured_image_url = &s
}

// FeaturedImageURL returns the value of the "featured_image_url" field in the mutation.
func (m *BlogPostMutation) FeaturedImageURL() (r string, exists bool) {
	v := m.featured_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedImageURL returns the old "featured_image_url" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldFeaturedImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedImageURL: %w", err)
	}
	return oldValue.FeaturedImageURL, nil
}

// ClearFeaturedImageURL clears the value of the "featured_image_url" field.
func (m *BlogPostMutation) ClearFeaturedImageURL() {
	m.featured_image_url = nil
	m.clearedFields[blogpost.FieldFeaturedImageURL] = struct{}{}
}

// FeaturedImageURLCleared returns if the "featured_image_url" field was cleared in this mutation.
func (m *BlogPostMutation) FeaturedImageURLCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldFeaturedImageURL]
	return ok
}

// ResetFeaturedImageURL resets all changes to the "featured_image_url" field.
func (m *BlogPostMutation) ResetFeaturedImageURL() {
	m.featured_image_url = nil
	delete(m.clearedFields, blogpost.FieldFeaturedImageURL)
}

// SetReadingTimeMinutes sets the "reading_time_minutes" field.
func (m *BlogPostMutation) SetReadingTimeMinutes(i int) {
	m.reading_time_minutes = &i
	m.addreading_time_minutes = nil
}

// ReadingTimeMinutes returns the value of the "reading_time_minutes" field in the mutation.
func (m *BlogPostMutation) ReadingTimeMinutes() (r int, exists bool) {
	v := m.reading_time_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldReadingTimeMinutes returns the old "reading_time_minutes" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldReadingTimeMinutes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadingTimeMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadingTimeMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadingTimeMinutes: %w", err)
	}
	return oldValue.ReadingTimeMinutes, nil
}

// AddReadingTimeMinutes adds i to the "reading_time_minutes" field.
func (m *BlogPostMutation) AddReadingTimeMinutes(i int) {
	if m.addreading_time_minutes != nil {
		*m.addreading_time_minutes += i
	} else {
		m.addreading_time_minutes = &i
	}
}

// AddedReadingTimeMinutes returns the value that was added to the "reading_time_minutes" field in this mutation.
func (m *BlogPostMutation) AddedReadingTimeMinutes() (r int, exists bool) {
	v := m.addreading_time_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ClearReadingTimeMinutes clears the value of the "reading_time_minutes" field.
func (m *BlogPostMutation) ClearReadingTimeMinutes() {
	m.reading_time_minutes = nil
	m.addreading_time_minutes = nil
	m.clearedFields[blogpost.FieldReadingTimeMinutes] = struct{}{}
}

// ReadingTimeMinutesCleared returns if the "reading_time_minutes" field was cleared in this mutation.
func (m *BlogPostMutation) ReadingTimeMinutesCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldReadingTimeMinutes]
	return ok
}

// ResetReadingTimeMinutes resets all changes to the "reading_time_minutes" field.
func (m *BlogPostMutation) ResetReadingTimeMinutes() {
	m.reading_time_minutes = nil
	m.addreading_time_minutes = nil
	delete(m.clearedFields, blogpost.FieldReadingTimeMinutes)
}

// SetViewCount sets the "view_count" field.
func (m *BlogPostMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *BlogPostMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *BlogPostMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *BlogPostMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *BlogPostMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *BlogPostMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *BlogPostMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *BlogPostMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *BlogPostMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *BlogPostMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetCommentCount sets the "comment_count" field.
func (m *BlogPostMutation) SetCommentCount(i int) {
	m.comment_count = &i
	m.addcomment_count = nil
}

// CommentCount returns the value of the "comment_count" field in the mutation.
func (m *BlogPostMutation) CommentCount() (r int, exists bool) {
	v := m.comment_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentCount returns the old "comment_count" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldCommentCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentCount: %w", err)
	}
	return oldValue.CommentCount, nil
}

// AddCommentCount adds i to the "comment_count" field.
func (m *BlogPostMutation) AddCommentCount(i int) {
	if m.addcomment_count != nil {
		*m.addcomment_count += i
	} else {
		m.addcomment_count = &i
	}
}

// AddedCommentCount returns the value that was added to the "comment_count" field in this mutation.
func (m *BlogPostMutation) AddedCommentCount() (r int, exists bool) {
	v := m.addcomment_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommentCount resets all changes to the "comment_count" field.
func (m *BlogPostMutation) ResetCommentCount() {
	m.comment_count = nil
	m.addcomment_count = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *BlogPostMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *BlogPostMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *BlogPostMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[blogpost.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *BlogPostMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *BlogPostMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, blogpost.FieldPublishedAt)
}

// SetSeriesOrder sets the "series_order" field.
func (m *BlogPostMutation) SetSeriesOrder(i int) {
	m.series_order = &i
	m.addseries_order = nil
}

// SeriesOrder returns the value of the "series_order" field in the mutation.
func (m *BlogPostMutation) SeriesOrder() (r int, exists bool) {
	v := m.series_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriesOrder returns the old "series_order" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldSeriesOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriesOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriesOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriesOrder: %w", err)
	}
	return oldValue.SeriesOrder, nil
}

// AddSeriesOrder adds i to the "series_order" field.
func (m *BlogPostMutation) AddSeriesOrder(i int) {
	if m.addseries_order != nil {
		*m.addseries_order += i
	} else {
		m.addseries_order = &i
	}
}

// AddedSeriesOrder returns the value that was added to the "series_order" field in this mutation.
func (m *BlogPostMutation) AddedSeriesOrder() (r int, exists bool) {
	v := m.addseries_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeriesOrder clears the value of the "series_order" field.
func (m *BlogPostMutation) ClearSeriesOrder() {
	m.series_order = nil
	m.addseries_order = nil
	m.clearedFields[blogpost.FieldSeriesOrder] = struct{}{}
}

// SeriesOrderCleared returns if the "series_order" field was cleared in this mutation.
func (m *BlogPostMutation) SeriesOrderCleared() bool {
	_, ok := m.clearedFields[blogpost.FieldSeriesOrder]
	return ok
}

// ResetSeriesOrder resets all changes to the "series_order" field.
func (m *BlogPostMutation) ResetSeriesOrder() {
	m.series_order = nil
	m.addseries_order = nil
	delete(m.clearedFields, blogpost.FieldSeriesOrder)
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogPostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogPostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogPostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogPostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogPostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogPost entity.
// If the BlogPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogPostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogPostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BlogPostMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BlogPostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BlogPostMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BlogPostMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BlogPostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCategoryID sets the "category" edge to the BlogCategory entity by id.
func (m *BlogPostMutation) SetCategoryID(id uuid.UUID) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the BlogCategory entity.
func (m *BlogPostMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the BlogCategory entity was cleared.
func (m *BlogPostMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *BlogPostMutation) CategoryID() (id uuid.UUID, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) CategoryIDs() (ids []uuid.UUID) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *BlogPostMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// SetSeriesID sets the "series" edge to the BlogSeries entity by id.
func (m *BlogPostMutation) SetSeriesID(id uuid.UUID) {
	m.series = &id
}

// ClearSeries clears the "series" edge to the BlogSeries entity.
func (m *BlogPostMutation) ClearSeries() {
	m.clearedseries = true
}

// SeriesCleared reports if the "series" edge to the BlogSeries entity was cleared.
func (m *BlogPostMutation) SeriesCleared() bool {
	return m.clearedseries
}

// SeriesID returns the "series" edge ID in the mutation.
func (m *BlogPostMutation) SeriesID() (id uuid.UUID, exists bool) {
	if m.series != nil {
		return *m.series, true
	}
	return
}

// SeriesIDs returns the "series" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeriesID instead. It exists only for internal usage by the builders.
func (m *BlogPostMutation) SeriesIDs() (ids []uuid.UUID) {
	if id := m.series; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeries resets all changes to the "series" edge.
func (m *BlogPostMutation) ResetSeries() {
	m.series = nil
	m.clearedseries = false
}

// AddTagIDs adds the "tags" edge to the BlogTag entity by ids.
func (m *BlogPostMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the BlogTag entity.
func (m *BlogPostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the BlogTag entity was cleared.
func (m *BlogPostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the BlogTag entity by IDs.
func (m *BlogPostMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the BlogTag entity.
func (m *BlogPostMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *BlogPostMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *BlogPostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCommentIDs adds the "comments" edge to the BlogComment entity by ids.
func (m *BlogPostMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the BlogComment entity.
func (m *BlogPostMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the BlogComment entity was cleared.
func (m *BlogPostMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the BlogComment entity by IDs.
func (m *BlogPostMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the BlogComment entity.
func (m *BlogPostMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *BlogPostMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *BlogPostMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// Where appends a list predicates to the BlogPostMutation builder.
func (m *BlogPostMutation) Where(ps ...predicate.BlogPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogPost).
func (m *BlogPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogPostMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.title != nil {
		fields = append(fields, blogpost.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, blogpost.FieldSlug)
	}
	if m.excerpt != nil {
		fields = append(fields, blogpost.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, blogpost.FieldContent)
	}
	if m.content_type != nil {
		fields = append(fields, blogpost.FieldContentType)
	}
	if m.status != nil {
		fields = append(fields, blogpost.FieldStatus)
	}
	if m.is_featured != nil {
		fields = append(fields, blogpost.FieldIsFeatured)
	}
	if m.featured_image_url != nil {
		fields = append(fields, blogpost.FieldFeaturedImageURL)
	}
	if m.reading_time_minutes != nil {
		fields = append(fields, blogpost.FieldReadingTimeMinutes)
	}
	if m.view_count != nil {
		fields = append(fields, blogpost.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, blogpost.FieldLikeCount)
	}
	if m.comment_count != nil {
		fields = append(fields, blogpost.FieldCommentCount)
	}
	if m.published_at != nil {
		fields = append(fields, blogpost.FieldPublishedAt)
	}
	if m.series_order != nil {
		fields = append(fields, blogpost.FieldSeriesOrder)
	}
	if m.created_at != nil {
		fields = append(fields, blogpost.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogpost.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogpost.FieldTitle:
		return m.Title()
	case blogpost.FieldSlug:
		return m.Slug()
	case blogpost.FieldExcerpt:
		return m.Excerpt()
	case blogpost.FieldContent:
		return m.Content()
	case blogpost.FieldContentType:
		return m.ContentType()
	case blogpost.FieldStatus:
		return m.Status()
	case blogpost.FieldIsFeatured:
		return m.IsFeatured()
	case blogpost.FieldFeaturedImageURL:
		return m.FeaturedImageURL()
	case blogpost.FieldReadingTimeMinutes:
		return m.ReadingTimeMinutes()
	case blogpost.FieldViewCount:
		return m.ViewCount()
	case blogpost.FieldLikeCount:
		return m.LikeCount()
	case blogpost.FieldCommentCount:
		return m.CommentCount()
	case blogpost.FieldPublishedAt:
		return m.PublishedAt()
	case blogpost.FieldSeriesOrder:
		return m.SeriesOrder()
	case blogpost.FieldCreatedAt:
		return m.CreatedAt()
	case blogpost.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogpost.FieldTitle:
		return m.OldTitle(ctx)
	case blogpost.FieldSlug:
		return m.OldSlug(ctx)
	case blogpost.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case blogpost.FieldContent:
		return m.OldContent(ctx)
	case blogpost.FieldContentType:
		return m.OldContentType(ctx)
	case blogpost.FieldStatus:
		return m.OldStatus(ctx)
	case blogpost.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case blogpost.FieldFeaturedImageURL:
		return m.OldFeaturedImageURL(ctx)
	case blogpost.FieldReadingTimeMinutes:
		return m.OldReadingTimeMinutes(ctx)
	case blogpost.FieldViewCount:
		return m.OldViewCount(ctx)
	case blogpost.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case blogpost.FieldCommentCount:
		return m.OldCommentCount(ctx)
	case blogpost.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case blogpost.FieldSeriesOrder:
		return m.OldSeriesOrder(ctx)
	case blogpost.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogpost.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogpost.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogpost.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogpost.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case blogpost.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case blogpost.FieldContentType:
		v, ok := value.(blogpost.ContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case blogpost.FieldStatus:
		v, ok := value.(blogpost.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case blogpost.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case blogpost.FieldFeaturedImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedImageURL(v)
		return nil
	case blogpost.FieldReadingTimeMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadingTimeMinutes(v)
		return nil
	case blogpost.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case blogpost.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case blogpost.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentCount(v)
		return nil
	case blogpost.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case blogpost.FieldSeriesOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriesOrder(v)
		return nil
	case blogpost.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogpost.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogPostMutation) AddedFields() []string {
	var fields []string
	if m.addreading_time_minutes != nil {
		fields = append(fields, blogpost.FieldReadingTimeMinutes)
	}
	if m.addview_count != nil {
		fields = append(fields, blogpost.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, blogpost.FieldLikeCount)
	}
	if m.addcomment_count != nil {
		fields = append(fields, blogpost.FieldCommentCount)
	}
	if m.addseries_order != nil {
		fields = append(fields, blogpost.FieldSeriesOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogPostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogpost.FieldReadingTimeMinutes:
		return m.AddedReadingTimeMinutes()
	case blogpost.FieldViewCount:
		return m.AddedViewCount()
	case blogpost.FieldLikeCount:
		return m.AddedLikeCount()
	case blogpost.FieldCommentCount:
		return m.AddedCommentCount()
	case blogpost.FieldSeriesOrder:
		return m.AddedSeriesOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogpost.FieldReadingTimeMinutes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadingTimeMinutes(v)
		return nil
	case blogpost.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case blogpost.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	case blogpost.FieldCommentCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommentCount(v)
		return nil
	case blogpost.FieldSeriesOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeriesOrder(v)
		return nil
	}
	return fmt.Errorf("unknown BlogPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogpost.FieldExcerpt) {
		fields = append(fields, blogpost.FieldExcerpt)
	}
	if m.FieldCleared(blogpost.FieldFeaturedImageURL) {
		fields = append(fields, blogpost.FieldFeaturedImageURL)
	}
	if m.FieldCleared(blogpost.FieldReadingTimeMinutes) {
		fields = append(fields, blogpost.FieldReadingTimeMinutes)
	}
	if m.FieldCleared(blogpost.FieldPublishedAt) {
		fields = append(fields, blogpost.FieldPublishedAt)
	}
	if m.FieldCleared(blogpost.FieldSeriesOrder) {
		fields = append(fields, blogpost.FieldSeriesOrder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogPostMutation) ClearField(name string) error {
	switch name {
	case blogpost.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case blogpost.FieldFeaturedImageURL:
		m.ClearFeaturedImageURL()
		return nil
	case blogpost.FieldReadingTimeMinutes:
		m.ClearReadingTimeMinutes()
		return nil
	case blogpost.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case blogpost.FieldSeriesOrder:
		m.ClearSeriesOrder()
		return nil
	}
	return fmt.Errorf("unknown BlogPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogPostMutation) ResetField(name string) error {
	switch name {
	case blogpost.FieldTitle:
		m.ResetTitle()
		return nil
	case blogpost.FieldSlug:
		m.ResetSlug()
		return nil
	case blogpost.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case blogpost.FieldContent:
		m.ResetContent()
		return nil
	case blogpost.FieldContentType:
		m.ResetContentType()
		return nil
	case blogpost.FieldStatus:
		m.ResetStatus()
		return nil
	case blogpost.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case blogpost.FieldFeaturedImageURL:
		m.ResetFeaturedImageURL()
		return nil
	case blogpost.FieldReadingTimeMinutes:
		m.ResetReadingTimeMinutes()
		return nil
	case blogpost.FieldViewCount:
		m.ResetViewCount()
		return nil
	case blogpost.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case blogpost.FieldCommentCount:
		m.ResetCommentCount()
		return nil
	case blogpost.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case blogpost.FieldSeriesOrder:
		m.ResetSeriesOrder()
		return nil
	case blogpost.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogpost.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, blogpost.EdgeUser)
	}
	if m.category != nil {
		edges = append(edges, blogpost.EdgeCategory)
	}
	if m.series != nil {
		edges = append(edges, blogpost.EdgeSeries)
	}
	if m.tags != nil {
		edges = append(edges, blogpost.EdgeTags)
	}
	if m.comments != nil {
		edges = append(edges, blogpost.EdgeComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogpost.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeSeries:
		if id := m.series; id != nil {
			return []ent.Value{*id}
		}
	case blogpost.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case blogpost.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtags != nil {
		edges = append(edges, blogpost.EdgeTags)
	}
	if m.removedcomments != nil {
		edges = append(edges, blogpost.EdgeComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogpost.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case blogpost.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, blogpost.EdgeUser)
	}
	if m.clearedcategory {
		edges = append(edges, blogpost.EdgeCategory)
	}
	if m.clearedseries {
		edges = append(edges, blogpost.EdgeSeries)
	}
	if m.clearedtags {
		edges = append(edges, blogpost.EdgeTags)
	}
	if m.clearedcomments {
		edges = append(edges, blogpost.EdgeComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogPostMutation) EdgeCleared(name string) bool {
	switch name {
	case blogpost.EdgeUser:
		return m.cleareduser
	case blogpost.EdgeCategory:
		return m.clearedcategory
	case blogpost.EdgeSeries:
		return m.clearedseries
	case blogpost.EdgeTags:
		return m.clearedtags
	case blogpost.EdgeComments:
		return m.clearedcomments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogPostMutation) ClearEdge(name string) error {
	switch name {
	case blogpost.EdgeUser:
		m.ClearUser()
		return nil
	case blogpost.EdgeCategory:
		m.ClearCategory()
		return nil
	case blogpost.EdgeSeries:
		m.ClearSeries()
		return nil
	}
	return fmt.Errorf("unknown BlogPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogPostMutation) ResetEdge(name string) error {
	switch name {
	case blogpost.EdgeUser:
		m.ResetUser()
		return nil
	case blogpost.EdgeCategory:
		m.ResetCategory()
		return nil
	case blogpost.EdgeSeries:
		m.ResetSeries()
		return nil
	case blogpost.EdgeTags:
		m.ResetTags()
		return nil
	case blogpost.EdgeComments:
		m.ResetComments()
		return nil
	}
	return fmt.Errorf("unknown BlogPost edge %s", name)
}

// BlogSeriesMutation represents an operation that mutates the BlogSeries nodes in the graph.
type BlogSeriesMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	title              *string
	slug               *string
	description        *string
	featured_image_url *string
	post_count         *int
	addpost_count      *int
	is_completed       *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	blog_posts         map[uuid.UUID]struct{}
	removedblog_posts  map[uuid.UUID]struct{}
	clearedblog_posts  bool
	done               bool
	oldValue           func(context.Context) (*BlogSeries, error)
	predicates         []predicate.BlogSeries
}

var _ ent.Mutation = (*BlogSeriesMutation)(nil)

// blogseriesOption allows management of the mutation configuration using functional options.
type blogseriesOption func(*BlogSeriesMutation)

// newBlogSeriesMutation creates new mutation for the BlogSeries entity.
func newBlogSeriesMutation(c config, op Op, opts ...blogseriesOption) *BlogSeriesMutation {
	m := &BlogSeriesMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogSeries,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogSeriesID sets the ID field of the mutation.
func withBlogSeriesID(id uuid.UUID) blogseriesOption {
	return func(m *BlogSeriesMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogSeries
		)
		m.oldValue = func(ctx context.Context) (*BlogSeries, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogSeries.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogSeries sets the old BlogSeries of the mutation.
func withBlogSeries(node *BlogSeries) blogseriesOption {
	return func(m *BlogSeriesMutation) {
		m.oldValue = func(context.Context) (*BlogSeries, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogSeriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogSeriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogSeries entities.
func (m *BlogSeriesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogSeriesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogSeriesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogSeries.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *BlogSeriesMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BlogSeriesMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BlogSeriesMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *BlogSeriesMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogSeriesMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogSeriesMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BlogSeriesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogSeriesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogSeriesMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogseries.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogSeriesMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogseries.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogSeriesMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogseries.FieldDescription)
}

// SetFeaturedImageURL sets the "featured_image_url" field.
func (m *BlogSeriesMutation) SetFeaturedImageURL(s string) {
	m.featured_image_url = &s
}

// FeaturedImageURL returns the value of the "featured_image_url" field in the mutation.
func (m *BlogSeriesMutation) FeaturedImageURL() (r string, exists bool) {
	v := m.featured_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFeaturedImageURL returns the old "featured_image_url" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldFeaturedImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeaturedImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeaturedImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeaturedImageURL: %w", err)
	}
	return oldValue.FeaturedImageURL, nil
}

// ClearFeaturedImageURL clears the value of the "featured_image_url" field.
func (m *BlogSeriesMutation) ClearFeaturedImageURL() {
	m.featured_image_url = nil
	m.clearedFields[blogseries.FieldFeaturedImageURL] = struct{}{}
}

// FeaturedImageURLCleared returns if the "featured_image_url" field was cleared in this mutation.
func (m *BlogSeriesMutation) FeaturedImageURLCleared() bool {
	_, ok := m.clearedFields[blogseries.FieldFeaturedImageURL]
	return ok
}

// ResetFeaturedImageURL resets all changes to the "featured_image_url" field.
func (m *BlogSeriesMutation) ResetFeaturedImageURL() {
	m.featured_image_url = nil
	delete(m.clearedFields, blogseries.FieldFeaturedImageURL)
}

// SetPostCount sets the "post_count" field.
func (m *BlogSeriesMutation) SetPostCount(i int) {
	m.post_count = &i
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *BlogSeriesMutation) PostCount() (r int, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldPostCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds i to the "post_count" field.
func (m *BlogSeriesMutation) AddPostCount(i int) {
	if m.addpost_count != nil {
		*m.addpost_count += i
	} else {
		m.addpost_count = &i
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *BlogSeriesMutation) AddedPostCount() (r int, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *BlogSeriesMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
}

// SetIsCompleted sets the "is_completed" field.
func (m *BlogSeriesMutation) SetIsCompleted(b bool) {
	m.is_completed = &b
}

// IsCompleted returns the value of the "is_completed" field in the mutation.
func (m *BlogSeriesMutation) IsCompleted() (r bool, exists bool) {
	v := m.is_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCompleted returns the old "is_completed" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldIsCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCompleted: %w", err)
	}
	return oldValue.IsCompleted, nil
}

// ResetIsCompleted resets all changes to the "is_completed" field.
func (m *BlogSeriesMutation) ResetIsCompleted() {
	m.is_completed = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogSeriesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogSeriesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogSeriesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogSeriesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogSeriesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogSeries entity.
// If the BlogSeries object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogSeriesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogSeriesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *BlogSeriesMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *BlogSeriesMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *BlogSeriesMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *BlogSeriesMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *BlogSeriesMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *BlogSeriesMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *BlogSeriesMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *BlogSeriesMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *BlogSeriesMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *BlogSeriesMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *BlogSeriesMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *BlogSeriesMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *BlogSeriesMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// Where appends a list predicates to the BlogSeriesMutation builder.
func (m *BlogSeriesMutation) Where(ps ...predicate.BlogSeries) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogSeriesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogSeriesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogSeries, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogSeriesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogSeriesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogSeries).
func (m *BlogSeriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogSeriesMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, blogseries.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, blogseries.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, blogseries.FieldDescription)
	}
	if m.featured_image_url != nil {
		fields = append(fields, blogseries.FieldFeaturedImageURL)
	}
	if m.post_count != nil {
		fields = append(fields, blogseries.FieldPostCount)
	}
	if m.is_completed != nil {
		fields = append(fields, blogseries.FieldIsCompleted)
	}
	if m.created_at != nil {
		fields = append(fields, blogseries.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogseries.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogSeriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogseries.FieldTitle:
		return m.Title()
	case blogseries.FieldSlug:
		return m.Slug()
	case blogseries.FieldDescription:
		return m.Description()
	case blogseries.FieldFeaturedImageURL:
		return m.FeaturedImageURL()
	case blogseries.FieldPostCount:
		return m.PostCount()
	case blogseries.FieldIsCompleted:
		return m.IsCompleted()
	case blogseries.FieldCreatedAt:
		return m.CreatedAt()
	case blogseries.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogSeriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogseries.FieldTitle:
		return m.OldTitle(ctx)
	case blogseries.FieldSlug:
		return m.OldSlug(ctx)
	case blogseries.FieldDescription:
		return m.OldDescription(ctx)
	case blogseries.FieldFeaturedImageURL:
		return m.OldFeaturedImageURL(ctx)
	case blogseries.FieldPostCount:
		return m.OldPostCount(ctx)
	case blogseries.FieldIsCompleted:
		return m.OldIsCompleted(ctx)
	case blogseries.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogseries.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogSeries field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogSeriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogseries.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case blogseries.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogseries.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogseries.FieldFeaturedImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeaturedImageURL(v)
		return nil
	case blogseries.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	case blogseries.FieldIsCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCompleted(v)
		return nil
	case blogseries.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogseries.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogSeries field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogSeriesMutation) AddedFields() []string {
	var fields []string
	if m.addpost_count != nil {
		fields = append(fields, blogseries.FieldPostCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogSeriesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogseries.FieldPostCount:
		return m.AddedPostCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogSeriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogseries.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown BlogSeries numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogSeriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogseries.FieldDescription) {
		fields = append(fields, blogseries.FieldDescription)
	}
	if m.FieldCleared(blogseries.FieldFeaturedImageURL) {
		fields = append(fields, blogseries.FieldFeaturedImageURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogSeriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogSeriesMutation) ClearField(name string) error {
	switch name {
	case blogseries.FieldDescription:
		m.ClearDescription()
		return nil
	case blogseries.FieldFeaturedImageURL:
		m.ClearFeaturedImageURL()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogSeriesMutation) ResetField(name string) error {
	switch name {
	case blogseries.FieldTitle:
		m.ResetTitle()
		return nil
	case blogseries.FieldSlug:
		m.ResetSlug()
		return nil
	case blogseries.FieldDescription:
		m.ResetDescription()
		return nil
	case blogseries.FieldFeaturedImageURL:
		m.ResetFeaturedImageURL()
		return nil
	case blogseries.FieldPostCount:
		m.ResetPostCount()
		return nil
	case blogseries.FieldIsCompleted:
		m.ResetIsCompleted()
		return nil
	case blogseries.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogseries.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogSeriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, blogseries.EdgeUser)
	}
	if m.blog_posts != nil {
		edges = append(edges, blogseries.EdgeBlogPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogSeriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogseries.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case blogseries.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogSeriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedblog_posts != nil {
		edges = append(edges, blogseries.EdgeBlogPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogSeriesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogseries.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogSeriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, blogseries.EdgeUser)
	}
	if m.clearedblog_posts {
		edges = append(edges, blogseries.EdgeBlogPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogSeriesMutation) EdgeCleared(name string) bool {
	switch name {
	case blogseries.EdgeUser:
		return m.cleareduser
	case blogseries.EdgeBlogPosts:
		return m.clearedblog_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogSeriesMutation) ClearEdge(name string) error {
	switch name {
	case blogseries.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogSeriesMutation) ResetEdge(name string) error {
	switch name {
	case blogseries.EdgeUser:
		m.ResetUser()
		return nil
	case blogseries.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	}
	return fmt.Errorf("unknown BlogSeries edge %s", name)
}

// BlogTagMutation represents an operation that mutates the BlogTag nodes in the graph.
type BlogTagMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	slug              *string
	description       *string
	color             *string
	post_count        *int
	addpost_count     *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	blog_posts        map[uuid.UUID]struct{}
	removedblog_posts map[uuid.UUID]struct{}
	clearedblog_posts bool
	done              bool
	oldValue          func(context.Context) (*BlogTag, error)
	predicates        []predicate.BlogTag
}

var _ ent.Mutation = (*BlogTagMutation)(nil)

// blogtagOption allows management of the mutation configuration using functional options.
type blogtagOption func(*BlogTagMutation)

// newBlogTagMutation creates new mutation for the BlogTag entity.
func newBlogTagMutation(c config, op Op, opts ...blogtagOption) *BlogTagMutation {
	m := &BlogTagMutation{
		config:        c,
		op:            op,
		typ:           TypeBlogTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlogTagID sets the ID field of the mutation.
func withBlogTagID(id uuid.UUID) blogtagOption {
	return func(m *BlogTagMutation) {
		var (
			err   error
			once  sync.Once
			value *BlogTag
		)
		m.oldValue = func(ctx context.Context) (*BlogTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlogTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlogTag sets the old BlogTag of the mutation.
func withBlogTag(node *BlogTag) blogtagOption {
	return func(m *BlogTagMutation) {
		m.oldValue = func(context.Context) (*BlogTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlogTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlogTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlogTag entities.
func (m *BlogTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlogTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlogTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlogTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BlogTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlogTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlogTagMutation) ResetName() {
	m.name = nil
}

// SetSlug sets the "slug" field.
func (m *BlogTagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *BlogTagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *BlogTagMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *BlogTagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BlogTagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BlogTagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[blogtag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BlogTagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[blogtag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BlogTagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, blogtag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *BlogTagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *BlogTagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *BlogTagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[blogtag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *BlogTagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[blogtag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *BlogTagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, blogtag.FieldColor)
}

// SetPostCount sets the "post_count" field.
func (m *BlogTagMutation) SetPostCount(i int) {
	m.post_count = &i
	m.addpost_count = nil
}

// PostCount returns the value of the "post_count" field in the mutation.
func (m *BlogTagMutation) PostCount() (r int, exists bool) {
	v := m.post_count
	if v == nil {
		return
	}
	return *v, true
}

// OldPostCount returns the old "post_count" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldPostCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostCount: %w", err)
	}
	return oldValue.PostCount, nil
}

// AddPostCount adds i to the "post_count" field.
func (m *BlogTagMutation) AddPostCount(i int) {
	if m.addpost_count != nil {
		*m.addpost_count += i
	} else {
		m.addpost_count = &i
	}
}

// AddedPostCount returns the value that was added to the "post_count" field in this mutation.
func (m *BlogTagMutation) AddedPostCount() (r int, exists bool) {
	v := m.addpost_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostCount resets all changes to the "post_count" field.
func (m *BlogTagMutation) ResetPostCount() {
	m.post_count = nil
	m.addpost_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BlogTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BlogTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BlogTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BlogTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BlogTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BlogTag entity.
// If the BlogTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlogTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BlogTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *BlogTagMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *BlogTagMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *BlogTagMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *BlogTagMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *BlogTagMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *BlogTagMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *BlogTagMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// Where appends a list predicates to the BlogTagMutation builder.
func (m *BlogTagMutation) Where(ps ...predicate.BlogTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlogTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlogTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlogTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlogTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlogTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlogTag).
func (m *BlogTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlogTagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, blogtag.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, blogtag.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, blogtag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, blogtag.FieldColor)
	}
	if m.post_count != nil {
		fields = append(fields, blogtag.FieldPostCount)
	}
	if m.created_at != nil {
		fields = append(fields, blogtag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, blogtag.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlogTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blogtag.FieldName:
		return m.Name()
	case blogtag.FieldSlug:
		return m.Slug()
	case blogtag.FieldDescription:
		return m.Description()
	case blogtag.FieldColor:
		return m.Color()
	case blogtag.FieldPostCount:
		return m.PostCount()
	case blogtag.FieldCreatedAt:
		return m.CreatedAt()
	case blogtag.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlogTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blogtag.FieldName:
		return m.OldName(ctx)
	case blogtag.FieldSlug:
		return m.OldSlug(ctx)
	case blogtag.FieldDescription:
		return m.OldDescription(ctx)
	case blogtag.FieldColor:
		return m.OldColor(ctx)
	case blogtag.FieldPostCount:
		return m.OldPostCount(ctx)
	case blogtag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case blogtag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BlogTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blogtag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blogtag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case blogtag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case blogtag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case blogtag.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostCount(v)
		return nil
	case blogtag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case blogtag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BlogTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlogTagMutation) AddedFields() []string {
	var fields []string
	if m.addpost_count != nil {
		fields = append(fields, blogtag.FieldPostCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlogTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blogtag.FieldPostCount:
		return m.AddedPostCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlogTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blogtag.FieldPostCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostCount(v)
		return nil
	}
	return fmt.Errorf("unknown BlogTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlogTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blogtag.FieldDescription) {
		fields = append(fields, blogtag.FieldDescription)
	}
	if m.FieldCleared(blogtag.FieldColor) {
		fields = append(fields, blogtag.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlogTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlogTagMutation) ClearField(name string) error {
	switch name {
	case blogtag.FieldDescription:
		m.ClearDescription()
		return nil
	case blogtag.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown BlogTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlogTagMutation) ResetField(name string) error {
	switch name {
	case blogtag.FieldName:
		m.ResetName()
		return nil
	case blogtag.FieldSlug:
		m.ResetSlug()
		return nil
	case blogtag.FieldDescription:
		m.ResetDescription()
		return nil
	case blogtag.FieldColor:
		m.ResetColor()
		return nil
	case blogtag.FieldPostCount:
		m.ResetPostCount()
		return nil
	case blogtag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case blogtag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown BlogTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlogTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.blog_posts != nil {
		edges = append(edges, blogtag.EdgeBlogPosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlogTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case blogtag.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlogTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedblog_posts != nil {
		edges = append(edges, blogtag.EdgeBlogPosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlogTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case blogtag.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlogTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblog_posts {
		edges = append(edges, blogtag.EdgeBlogPosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlogTagMutation) EdgeCleared(name string) bool {
	switch name {
	case blogtag.EdgeBlogPosts:
		return m.clearedblog_posts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlogTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BlogTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlogTagMutation) ResetEdge(name string) error {
	switch name {
	case blogtag.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	}
	return fmt.Errorf("unknown BlogTag edge %s", name)
}

// EducationMutation represents an operation that mutates the Education nodes in the graph.
type EducationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	institution          *string
	degree               *string
	field_of_study       *string
	start_date           *time.Time
	end_date             *time.Time
	is_current           *bool
	gpa                  *string
	location             *string
	institution_website  *string
	institution_logo_url *string
	sort_order           *int
	addsort_order        *int
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Education, error)
	predicates           []predicate.Education
}

var _ ent.Mutation = (*EducationMutation)(nil)

// educationOption allows management of the mutation configuration using functional options.
type educationOption func(*EducationMutation)

// newEducationMutation creates new mutation for the Education entity.
func newEducationMutation(c config, op Op, opts ...educationOption) *EducationMutation {
	m := &EducationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationID sets the ID field of the mutation.
func withEducationID(id uuid.UUID) educationOption {
	return func(m *EducationMutation) {
		var (
			err   error
			once  sync.Once
			value *Education
		)
		m.oldValue = func(ctx context.Context) (*Education, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Education.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducation sets the old Education of the mutation.
func withEducation(node *Education) educationOption {
	return func(m *EducationMutation) {
		m.oldValue = func(context.Context) (*Education, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Education entities.
func (m *EducationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Education.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstitution sets the "institution" field.
func (m *EducationMutation) SetInstitution(s string) {
	m.institution = &s
}

// Institution returns the value of the "institution" field in the mutation.
func (m *EducationMutation) Institution() (r string, exists bool) {
	v := m.institution
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitution returns the old "institution" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitution(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitution: %w", err)
	}
	return oldValue.Institution, nil
}

// ResetInstitution resets all changes to the "institution" field.
func (m *EducationMutation) ResetInstitution() {
	m.institution = nil
}

// SetDegree sets the "degree" field.
func (m *EducationMutation) SetDegree(s string) {
	m.degree = &s
}

// Degree returns the value of the "degree" field in the mutation.
func (m *EducationMutation) Degree() (r string, exists bool) {
	v := m.degree
	if v == nil {
		return
	}
	return *v, true
}

// OldDegree returns the old "degree" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDegree(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegree: %w", err)
	}
	return oldValue.Degree, nil
}

// ResetDegree resets all changes to the "degree" field.
func (m *EducationMutation) ResetDegree() {
	m.degree = nil
}

// SetFieldOfStudy sets the "field_of_study" field.
func (m *EducationMutation) SetFieldOfStudy(s string) {
	m.field_of_study = &s
}

// FieldOfStudy returns the value of the "field_of_study" field in the mutation.
func (m *EducationMutation) FieldOfStudy() (r string, exists bool) {
	v := m.field_of_study
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldOfStudy returns the old "field_of_study" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldFieldOfStudy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldOfStudy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldOfStudy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldOfStudy: %w", err)
	}
	return oldValue.FieldOfStudy, nil
}

// ClearFieldOfStudy clears the value of the "field_of_study" field.
func (m *EducationMutation) ClearFieldOfStudy() {
	m.field_of_study = nil
	m.clearedFields[education.FieldFieldOfStudy] = struct{}{}
}

// FieldOfStudyCleared returns if the "field_of_study" field was cleared in this mutation.
func (m *EducationMutation) FieldOfStudyCleared() bool {
	_, ok := m.clearedFields[education.FieldFieldOfStudy]
	return ok
}

// ResetFieldOfStudy resets all changes to the "field_of_study" field.
func (m *EducationMutation) ResetFieldOfStudy() {
	m.field_of_study = nil
	delete(m.clearedFields, education.FieldFieldOfStudy)
}

// SetStartDate sets the "start_date" field.
func (m *EducationMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EducationMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *EducationMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[education.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *EducationMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[education.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EducationMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, education.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *EducationMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EducationMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *EducationMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[education.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *EducationMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[education.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EducationMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, education.FieldEndDate)
}

// SetIsCurrent sets the "is_current" field.
func (m *EducationMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *EducationMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *EducationMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetGpa sets the "gpa" field.
func (m *EducationMutation) SetGpa(s string) {
	m.gpa = &s
}

// Gpa returns the value of the "gpa" field in the mutation.
func (m *EducationMutation) Gpa() (r string, exists bool) {
	v := m.gpa
	if v == nil {
		return
	}
	return *v, true
}

// OldGpa returns the old "gpa" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldGpa(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGpa is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGpa requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpa: %w", err)
	}
	return oldValue.Gpa, nil
}

// ClearGpa clears the value of the "gpa" field.
func (m *EducationMutation) ClearGpa() {
	m.gpa = nil
	m.clearedFields[education.FieldGpa] = struct{}{}
}

// GpaCleared returns if the "gpa" field was cleared in this mutation.
func (m *EducationMutation) GpaCleared() bool {
	_, ok := m.clearedFields[education.FieldGpa]
	return ok
}

// ResetGpa resets all changes to the "gpa" field.
func (m *EducationMutation) ResetGpa() {
	m.gpa = nil
	delete(m.clearedFields, education.FieldGpa)
}

// SetLocation sets the "location" field.
func (m *EducationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *EducationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *EducationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[education.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *EducationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[education.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *EducationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, education.FieldLocation)
}

// SetInstitutionWebsite sets the "institution_website" field.
func (m *EducationMutation) SetInstitutionWebsite(s string) {
	m.institution_website = &s
}

// InstitutionWebsite returns the value of the "institution_website" field in the mutation.
func (m *EducationMutation) InstitutionWebsite() (r string, exists bool) {
	v := m.institution_website
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionWebsite returns the old "institution_website" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitutionWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionWebsite: %w", err)
	}
	return oldValue.InstitutionWebsite, nil
}

// ClearInstitutionWebsite clears the value of the "institution_website" field.
func (m *EducationMutation) ClearInstitutionWebsite() {
	m.institution_website = nil
	m.clearedFields[education.FieldInstitutionWebsite] = struct{}{}
}

// InstitutionWebsiteCleared returns if the "institution_website" field was cleared in this mutation.
func (m *EducationMutation) InstitutionWebsiteCleared() bool {
	_, ok := m.clearedFields[education.FieldInstitutionWebsite]
	return ok
}

// ResetInstitutionWebsite resets all changes to the "institution_website" field.
func (m *EducationMutation) ResetInstitutionWebsite() {
	m.institution_website = nil
	delete(m.clearedFields, education.FieldInstitutionWebsite)
}

// SetInstitutionLogoURL sets the "institution_logo_url" field.
func (m *EducationMutation) SetInstitutionLogoURL(s string) {
	m.institution_logo_url = &s
}

// InstitutionLogoURL returns the value of the "institution_logo_url" field in the mutation.
func (m *EducationMutation) InstitutionLogoURL() (r string, exists bool) {
	v := m.institution_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitutionLogoURL returns the old "institution_logo_url" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitutionLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitutionLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitutionLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitutionLogoURL: %w", err)
	}
	return oldValue.InstitutionLogoURL, nil
}

// ClearInstitutionLogoURL clears the value of the "institution_logo_url" field.
func (m *EducationMutation) ClearInstitutionLogoURL() {
	m.institution_logo_url = nil
	m.clearedFields[education.FieldInstitutionLogoURL] = struct{}{}
}

// InstitutionLogoURLCleared returns if the "institution_logo_url" field was cleared in this mutation.
func (m *EducationMutation) InstitutionLogoURLCleared() bool {
	_, ok := m.clearedFields[education.FieldInstitutionLogoURL]
	return ok
}

// ResetInstitutionLogoURL resets all changes to the "institution_logo_url" field.
func (m *EducationMutation) ResetInstitutionLogoURL() {
	m.institution_logo_url = nil
	delete(m.clearedFields, education.FieldInstitutionLogoURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *EducationMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *EducationMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *EducationMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *EducationMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *EducationMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EducationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EducationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EducationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *EducationMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *EducationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EducationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *EducationMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EducationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EducationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EducationMutation builder.
func (m *EducationMutation) Where(ps ...predicate.Education) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Education, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Education).
func (m *EducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.institution != nil {
		fields = append(fields, education.FieldInstitution)
	}
	if m.degree != nil {
		fields = append(fields, education.FieldDegree)
	}
	if m.field_of_study != nil {
		fields = append(fields, education.FieldFieldOfStudy)
	}
	if m.start_date != nil {
		fields = append(fields, education.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, education.FieldEndDate)
	}
	if m.is_current != nil {
		fields = append(fields, education.FieldIsCurrent)
	}
	if m.gpa != nil {
		fields = append(fields, education.FieldGpa)
	}
	if m.location != nil {
		fields = append(fields, education.FieldLocation)
	}
	if m.institution_website != nil {
		fields = append(fields, education.FieldInstitutionWebsite)
	}
	if m.institution_logo_url != nil {
		fields = append(fields, education.FieldInstitutionLogoURL)
	}
	if m.sort_order != nil {
		fields = append(fields, education.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, education.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, education.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case education.FieldInstitution:
		return m.Institution()
	case education.FieldDegree:
		return m.Degree()
	case education.FieldFieldOfStudy:
		return m.FieldOfStudy()
	case education.FieldStartDate:
		return m.StartDate()
	case education.FieldEndDate:
		return m.EndDate()
	case education.FieldIsCurrent:
		return m.IsCurrent()
	case education.FieldGpa:
		return m.Gpa()
	case education.FieldLocation:
		return m.Location()
	case education.FieldInstitutionWebsite:
		return m.InstitutionWebsite()
	case education.FieldInstitutionLogoURL:
		return m.InstitutionLogoURL()
	case education.FieldSortOrder:
		return m.SortOrder()
	case education.FieldCreatedAt:
		return m.CreatedAt()
	case education.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case education.FieldInstitution:
		return m.OldInstitution(ctx)
	case education.FieldDegree:
		return m.OldDegree(ctx)
	case education.FieldFieldOfStudy:
		return m.OldFieldOfStudy(ctx)
	case education.FieldStartDate:
		return m.OldStartDate(ctx)
	case education.FieldEndDate:
		return m.OldEndDate(ctx)
	case education.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case education.FieldGpa:
		return m.OldGpa(ctx)
	case education.FieldLocation:
		return m.OldLocation(ctx)
	case education.FieldInstitutionWebsite:
		return m.OldInstitutionWebsite(ctx)
	case education.FieldInstitutionLogoURL:
		return m.OldInstitutionLogoURL(ctx)
	case education.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case education.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case education.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Education field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case education.FieldInstitution:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitution(v)
		return nil
	case education.FieldDegree:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegree(v)
		return nil
	case education.FieldFieldOfStudy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldOfStudy(v)
		return nil
	case education.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case education.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case education.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case education.FieldGpa:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpa(v)
		return nil
	case education.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case education.FieldInstitutionWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionWebsite(v)
		return nil
	case education.FieldInstitutionLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitutionLogoURL(v)
		return nil
	case education.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case education.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case education.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, education.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case education.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case education.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Education numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(education.FieldFieldOfStudy) {
		fields = append(fields, education.FieldFieldOfStudy)
	}
	if m.FieldCleared(education.FieldStartDate) {
		fields = append(fields, education.FieldStartDate)
	}
	if m.FieldCleared(education.FieldEndDate) {
		fields = append(fields, education.FieldEndDate)
	}
	if m.FieldCleared(education.FieldGpa) {
		fields = append(fields, education.FieldGpa)
	}
	if m.FieldCleared(education.FieldLocation) {
		fields = append(fields, education.FieldLocation)
	}
	if m.FieldCleared(education.FieldInstitutionWebsite) {
		fields = append(fields, education.FieldInstitutionWebsite)
	}
	if m.FieldCleared(education.FieldInstitutionLogoURL) {
		fields = append(fields, education.FieldInstitutionLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationMutation) ClearField(name string) error {
	switch name {
	case education.FieldFieldOfStudy:
		m.ClearFieldOfStudy()
		return nil
	case education.FieldStartDate:
		m.ClearStartDate()
		return nil
	case education.FieldEndDate:
		m.ClearEndDate()
		return nil
	case education.FieldGpa:
		m.ClearGpa()
		return nil
	case education.FieldLocation:
		m.ClearLocation()
		return nil
	case education.FieldInstitutionWebsite:
		m.ClearInstitutionWebsite()
		return nil
	case education.FieldInstitutionLogoURL:
		m.ClearInstitutionLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Education nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationMutation) ResetField(name string) error {
	switch name {
	case education.FieldInstitution:
		m.ResetInstitution()
		return nil
	case education.FieldDegree:
		m.ResetDegree()
		return nil
	case education.FieldFieldOfStudy:
		m.ResetFieldOfStudy()
		return nil
	case education.FieldStartDate:
		m.ResetStartDate()
		return nil
	case education.FieldEndDate:
		m.ResetEndDate()
		return nil
	case education.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case education.FieldGpa:
		m.ResetGpa()
		return nil
	case education.FieldLocation:
		m.ResetLocation()
		return nil
	case education.FieldInstitutionWebsite:
		m.ResetInstitutionWebsite()
		return nil
	case education.FieldInstitutionLogoURL:
		m.ResetInstitutionLogoURL()
		return nil
	case education.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case education.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case education.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, education.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, education.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationMutation) EdgeCleared(name string) bool {
	switch name {
	case education.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationMutation) ClearEdge(name string) error {
	switch name {
	case education.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Education unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationMutation) ResetEdge(name string) error {
	switch name {
	case education.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Education edge %s", name)
}

// IdeaMutation represents an operation that mutates the Idea nodes in the graph.
type IdeaMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	title                        *string
	slug                         *string
	abstract                     *string
	motivation                   *string
	methodology                  *string
	expected_outcome             *string
	status                       *idea.Status
	priority                     *idea.Priority
	estimated_duration_months    *int
	addestimated_duration_months *int
	required_resources           *string
	collaboration_needed         *bool
	funding_required             *bool
	estimated_budget             *float64
	addestimated_budget          *float64
	is_public                    *bool
	view_count                   *int
	addview_count                *int
	like_count                   *int
	addlike_count                *int
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	user                         *uuid.UUID
	cleareduser                  bool
	done                         bool
	oldValue                     func(context.Context) (*Idea, error)
	predicates                   []predicate.Idea
}

var _ ent.Mutation = (*IdeaMutation)(nil)

// ideaOption allows management of the mutation configuration using functional options.
type ideaOption func(*IdeaMutation)

// newIdeaMutation creates new mutation for the Idea entity.
func newIdeaMutation(c config, op Op, opts ...ideaOption) *IdeaMutation {
	m := &IdeaMutation{
		config:        c,
		op:            op,
		typ:           TypeIdea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdeaID sets the ID field of the mutation.
func withIdeaID(id uuid.UUID) ideaOption {
	return func(m *IdeaMutation) {
		var (
			err   error
			once  sync.Once
			value *Idea
		)
		m.oldValue = func(ctx context.Context) (*Idea, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Idea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdea sets the old Idea of the mutation.
func withIdea(node *Idea) ideaOption {
	return func(m *IdeaMutation) {
		m.oldValue = func(context.Context) (*Idea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdeaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdeaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Idea entities.
func (m *IdeaMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdeaMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdeaMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Idea.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *IdeaMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *IdeaMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *IdeaMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *IdeaMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *IdeaMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *IdeaMutation) ResetSlug() {
	m.slug = nil
}

// SetAbstract sets the "abstract" field.
func (m *IdeaMutation) SetAbstract(s string) {
	m.abstract = &s
}

// Abstract returns the value of the "abstract" field in the mutation.
func (m *IdeaMutation) Abstract() (r string, exists bool) {
	v := m.abstract
	if v == nil {
		return
	}
	return *v, true
}

// OldAbstract returns the old "abstract" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldAbstract(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbstract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbstract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbstract: %w", err)
	}
	return oldValue.Abstract, nil
}

// ClearAbstract clears the value of the "abstract" field.
func (m *IdeaMutation) ClearAbstract() {
	m.abstract = nil
	m.clearedFields[idea.FieldAbstract] = struct{}{}
}

// AbstractCleared returns if the "abstract" field was cleared in this mutation.
func (m *IdeaMutation) AbstractCleared() bool {
	_, ok := m.clearedFields[idea.FieldAbstract]
	return ok
}

// ResetAbstract resets all changes to the "abstract" field.
func (m *IdeaMutation) ResetAbstract() {
	m.abstract = nil
	delete(m.clearedFields, idea.FieldAbstract)
}

// SetMotivation sets the "motivation" field.
func (m *IdeaMutation) SetMotivation(s string) {
	m.motivation = &s
}

// Motivation returns the value of the "motivation" field in the mutation.
func (m *IdeaMutation) Motivation() (r string, exists bool) {
	v := m.motivation
	if v == nil {
		return
	}
	return *v, true
}

// OldMotivation returns the old "motivation" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldMotivation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotivation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotivation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotivation: %w", err)
	}
	return oldValue.Motivation, nil
}

// ClearMotivation clears the value of the "motivation" field.
func (m *IdeaMutation) ClearMotivation() {
	m.motivation = nil
	m.clearedFields[idea.FieldMotivation] = struct{}{}
}

// MotivationCleared returns if the "motivation" field was cleared in this mutation.
func (m *IdeaMutation) MotivationCleared() bool {
	_, ok := m.clearedFields[idea.FieldMotivation]
	return ok
}

// ResetMotivation resets all changes to the "motivation" field.
func (m *IdeaMutation) ResetMotivation() {
	m.motivation = nil
	delete(m.clearedFields, idea.FieldMotivation)
}

// SetMethodology sets the "methodology" field.
func (m *IdeaMutation) SetMethodology(s string) {
	m.methodology = &s
}

// Methodology returns the value of the "methodology" field in the mutation.
func (m *IdeaMutation) Methodology() (r string, exists bool) {
	v := m.methodology
	if v == nil {
		return
	}
	return *v, true
}

// OldMethodology returns the old "methodology" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldMethodology(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethodology is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethodology requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethodology: %w", err)
	}
	return oldValue.Methodology, nil
}

// ClearMethodology clears the value of the "methodology" field.
func (m *IdeaMutation) ClearMethodology() {
	m.methodology = nil
	m.clearedFields[idea.FieldMethodology] = struct{}{}
}

// MethodologyCleared returns if the "methodology" field was cleared in this mutation.
func (m *IdeaMutation) MethodologyCleared() bool {
	_, ok := m.clearedFields[idea.FieldMethodology]
	return ok
}

// ResetMethodology resets all changes to the "methodology" field.
func (m *IdeaMutation) ResetMethodology() {
	m.methodology = nil
	delete(m.clearedFields, idea.FieldMethodology)
}

// SetExpectedOutcome sets the "expected_outcome" field.
func (m *IdeaMutation) SetExpectedOutcome(s string) {
	m.expected_outcome = &s
}

// ExpectedOutcome returns the value of the "expected_outcome" field in the mutation.
func (m *IdeaMutation) ExpectedOutcome() (r string, exists bool) {
	v := m.expected_outcome
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedOutcome returns the old "expected_outcome" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldExpectedOutcome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedOutcome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedOutcome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedOutcome: %w", err)
	}
	return oldValue.ExpectedOutcome, nil
}

// ClearExpectedOutcome clears the value of the "expected_outcome" field.
func (m *IdeaMutation) ClearExpectedOutcome() {
	m.expected_outcome = nil
	m.clearedFields[idea.FieldExpectedOutcome] = struct{}{}
}

// ExpectedOutcomeCleared returns if the "expected_outcome" field was cleared in this mutation.
func (m *IdeaMutation) ExpectedOutcomeCleared() bool {
	_, ok := m.clearedFields[idea.FieldExpectedOutcome]
	return ok
}

// ResetExpectedOutcome resets all changes to the "expected_outcome" field.
func (m *IdeaMutation) ResetExpectedOutcome() {
	m.expected_outcome = nil
	delete(m.clearedFields, idea.FieldExpectedOutcome)
}

// SetStatus sets the "status" field.
func (m *IdeaMutation) SetStatus(i idea.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *IdeaMutation) Status() (r idea.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldStatus(ctx context.Context) (v idea.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *IdeaMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *IdeaMutation) SetPriority(i idea.Priority) {
	m.priority = &i
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IdeaMutation) Priority() (r idea.Priority, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldPriority(ctx context.Context) (v idea.Priority, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *IdeaMutation) ResetPriority() {
	m.priority = nil
}

// SetEstimatedDurationMonths sets the "estimated_duration_months" field.
func (m *IdeaMutation) SetEstimatedDurationMonths(i int) {
	m.estimated_duration_months = &i
	m.addestimated_duration_months = nil
}

// EstimatedDurationMonths returns the value of the "estimated_duration_months" field in the mutation.
func (m *IdeaMutation) EstimatedDurationMonths() (r int, exists bool) {
	v := m.estimated_duration_months
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedDurationMonths returns the old "estimated_duration_months" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldEstimatedDurationMonths(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedDurationMonths is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedDurationMonths requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedDurationMonths: %w", err)
	}
	return oldValue.EstimatedDurationMonths, nil
}

// AddEstimatedDurationMonths adds i to the "estimated_duration_months" field.
func (m *IdeaMutation) AddEstimatedDurationMonths(i int) {
	if m.addestimated_duration_months != nil {
		*m.addestimated_duration_months += i
	} else {
		m.addestimated_duration_months = &i
	}
}

// AddedEstimatedDurationMonths returns the value that was added to the "estimated_duration_months" field in this mutation.
func (m *IdeaMutation) AddedEstimatedDurationMonths() (r int, exists bool) {
	v := m.addestimated_duration_months
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedDurationMonths clears the value of the "estimated_duration_months" field.
func (m *IdeaMutation) ClearEstimatedDurationMonths() {
	m.estimated_duration_months = nil
	m.addestimated_duration_months = nil
	m.clearedFields[idea.FieldEstimatedDurationMonths] = struct{}{}
}

// EstimatedDurationMonthsCleared returns if the "estimated_duration_months" field was cleared in this mutation.
func (m *IdeaMutation) EstimatedDurationMonthsCleared() bool {
	_, ok := m.clearedFields[idea.FieldEstimatedDurationMonths]
	return ok
}

// ResetEstimatedDurationMonths resets all changes to the "estimated_duration_months" field.
func (m *IdeaMutation) ResetEstimatedDurationMonths() {
	m.estimated_duration_months = nil
	m.addestimated_duration_months = nil
	delete(m.clearedFields, idea.FieldEstimatedDurationMonths)
}

// SetRequiredResources sets the "required_resources" field.
func (m *IdeaMutation) SetRequiredResources(s string) {
	m.required_resources = &s
}

// RequiredResources returns the value of the "required_resources" field in the mutation.
func (m *IdeaMutation) RequiredResources() (r string, exists bool) {
	v := m.required_resources
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiredResources returns the old "required_resources" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldRequiredResources(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiredResources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiredResources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiredResources: %w", err)
	}
	return oldValue.RequiredResources, nil
}

// ClearRequiredResources clears the value of the "required_resources" field.
func (m *IdeaMutation) ClearRequiredResources() {
	m.required_resources = nil
	m.clearedFields[idea.FieldRequiredResources] = struct{}{}
}

// RequiredResourcesCleared returns if the "required_resources" field was cleared in this mutation.
func (m *IdeaMutation) RequiredResourcesCleared() bool {
	_, ok := m.clearedFields[idea.FieldRequiredResources]
	return ok
}

// ResetRequiredResources resets all changes to the "required_resources" field.
func (m *IdeaMutation) ResetRequiredResources() {
	m.required_resources = nil
	delete(m.clearedFields, idea.FieldRequiredResources)
}

// SetCollaborationNeeded sets the "collaboration_needed" field.
func (m *IdeaMutation) SetCollaborationNeeded(b bool) {
	m.collaboration_needed = &b
}

// CollaborationNeeded returns the value of the "collaboration_needed" field in the mutation.
func (m *IdeaMutation) CollaborationNeeded() (r bool, exists bool) {
	v := m.collaboration_needed
	if v == nil {
		return
	}
	return *v, true
}

// OldCollaborationNeeded returns the old "collaboration_needed" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldCollaborationNeeded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollaborationNeeded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollaborationNeeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollaborationNeeded: %w", err)
	}
	return oldValue.CollaborationNeeded, nil
}

// ResetCollaborationNeeded resets all changes to the "collaboration_needed" field.
func (m *IdeaMutation) ResetCollaborationNeeded() {
	m.collaboration_needed = nil
}

// SetFundingRequired sets the "funding_required" field.
func (m *IdeaMutation) SetFundingRequired(b bool) {
	m.funding_required = &b
}

// FundingRequired returns the value of the "funding_required" field in the mutation.
func (m *IdeaMutation) FundingRequired() (r bool, exists bool) {
	v := m.funding_required
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingRequired returns the old "funding_required" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldFundingRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingRequired: %w", err)
	}
	return oldValue.FundingRequired, nil
}

// ResetFundingRequired resets all changes to the "funding_required" field.
func (m *IdeaMutation) ResetFundingRequired() {
	m.funding_required = nil
}

// SetEstimatedBudget sets the "estimated_budget" field.
func (m *IdeaMutation) SetEstimatedBudget(f float64) {
	m.estimated_budget = &f
	m.addestimated_budget = nil
}

// EstimatedBudget returns the value of the "estimated_budget" field in the mutation.
func (m *IdeaMutation) EstimatedBudget() (r float64, exists bool) {
	v := m.estimated_budget
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedBudget returns the old "estimated_budget" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldEstimatedBudget(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedBudget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedBudget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedBudget: %w", err)
	}
	return oldValue.EstimatedBudget, nil
}

// AddEstimatedBudget adds f to the "estimated_budget" field.
func (m *IdeaMutation) AddEstimatedBudget(f float64) {
	if m.addestimated_budget != nil {
		*m.addestimated_budget += f
	} else {
		m.addestimated_budget = &f
	}
}

// AddedEstimatedBudget returns the value that was added to the "estimated_budget" field in this mutation.
func (m *IdeaMutation) AddedEstimatedBudget() (r float64, exists bool) {
	v := m.addestimated_budget
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedBudget clears the value of the "estimated_budget" field.
func (m *IdeaMutation) ClearEstimatedBudget() {
	m.estimated_budget = nil
	m.addestimated_budget = nil
	m.clearedFields[idea.FieldEstimatedBudget] = struct{}{}
}

// EstimatedBudgetCleared returns if the "estimated_budget" field was cleared in this mutation.
func (m *IdeaMutation) EstimatedBudgetCleared() bool {
	_, ok := m.clearedFields[idea.FieldEstimatedBudget]
	return ok
}

// ResetEstimatedBudget resets all changes to the "estimated_budget" field.
func (m *IdeaMutation) ResetEstimatedBudget() {
	m.estimated_budget = nil
	m.addestimated_budget = nil
	delete(m.clearedFields, idea.FieldEstimatedBudget)
}

// SetIsPublic sets the "is_public" field.
func (m *IdeaMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *IdeaMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *IdeaMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetViewCount sets the "view_count" field.
func (m *IdeaMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *IdeaMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *IdeaMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *IdeaMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *IdeaMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetLikeCount sets the "like_count" field.
func (m *IdeaMutation) SetLikeCount(i int) {
	m.like_count = &i
	m.addlike_count = nil
}

// LikeCount returns the value of the "like_count" field in the mutation.
func (m *IdeaMutation) LikeCount() (r int, exists bool) {
	v := m.like_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLikeCount returns the old "like_count" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldLikeCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLikeCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLikeCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLikeCount: %w", err)
	}
	return oldValue.LikeCount, nil
}

// AddLikeCount adds i to the "like_count" field.
func (m *IdeaMutation) AddLikeCount(i int) {
	if m.addlike_count != nil {
		*m.addlike_count += i
	} else {
		m.addlike_count = &i
	}
}

// AddedLikeCount returns the value that was added to the "like_count" field in this mutation.
func (m *IdeaMutation) AddedLikeCount() (r int, exists bool) {
	v := m.addlike_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLikeCount resets all changes to the "like_count" field.
func (m *IdeaMutation) ResetLikeCount() {
	m.like_count = nil
	m.addlike_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *IdeaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IdeaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IdeaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IdeaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IdeaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Idea entity.
// If the Idea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdeaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IdeaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *IdeaMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *IdeaMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *IdeaMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *IdeaMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *IdeaMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *IdeaMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the IdeaMutation builder.
func (m *IdeaMutation) Where(ps ...predicate.Idea) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdeaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdeaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Idea, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdeaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdeaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Idea).
func (m *IdeaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdeaMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.title != nil {
		fields = append(fields, idea.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, idea.FieldSlug)
	}
	if m.abstract != nil {
		fields = append(fields, idea.FieldAbstract)
	}
	if m.motivation != nil {
		fields = append(fields, idea.FieldMotivation)
	}
	if m.methodology != nil {
		fields = append(fields, idea.FieldMethodology)
	}
	if m.expected_outcome != nil {
		fields = append(fields, idea.FieldExpectedOutcome)
	}
	if m.status != nil {
		fields = append(fields, idea.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, idea.FieldPriority)
	}
	if m.estimated_duration_months != nil {
		fields = append(fields, idea.FieldEstimatedDurationMonths)
	}
	if m.required_resources != nil {
		fields = append(fields, idea.FieldRequiredResources)
	}
	if m.collaboration_needed != nil {
		fields = append(fields, idea.FieldCollaborationNeeded)
	}
	if m.funding_required != nil {
		fields = append(fields, idea.FieldFundingRequired)
	}
	if m.estimated_budget != nil {
		fields = append(fields, idea.FieldEstimatedBudget)
	}
	if m.is_public != nil {
		fields = append(fields, idea.FieldIsPublic)
	}
	if m.view_count != nil {
		fields = append(fields, idea.FieldViewCount)
	}
	if m.like_count != nil {
		fields = append(fields, idea.FieldLikeCount)
	}
	if m.created_at != nil {
		fields = append(fields, idea.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, idea.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdeaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case idea.FieldTitle:
		return m.Title()
	case idea.FieldSlug:
		return m.Slug()
	case idea.FieldAbstract:
		return m.Abstract()
	case idea.FieldMotivation:
		return m.Motivation()
	case idea.FieldMethodology:
		return m.Methodology()
	case idea.FieldExpectedOutcome:
		return m.ExpectedOutcome()
	case idea.FieldStatus:
		return m.Status()
	case idea.FieldPriority:
		return m.Priority()
	case idea.FieldEstimatedDurationMonths:
		return m.EstimatedDurationMonths()
	case idea.FieldRequiredResources:
		return m.RequiredResources()
	case idea.FieldCollaborationNeeded:
		return m.CollaborationNeeded()
	case idea.FieldFundingRequired:
		return m.FundingRequired()
	case idea.FieldEstimatedBudget:
		return m.EstimatedBudget()
	case idea.FieldIsPublic:
		return m.IsPublic()
	case idea.FieldViewCount:
		return m.ViewCount()
	case idea.FieldLikeCount:
		return m.LikeCount()
	case idea.FieldCreatedAt:
		return m.CreatedAt()
	case idea.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdeaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case idea.FieldTitle:
		return m.OldTitle(ctx)
	case idea.FieldSlug:
		return m.OldSlug(ctx)
	case idea.FieldAbstract:
		return m.OldAbstract(ctx)
	case idea.FieldMotivation:
		return m.OldMotivation(ctx)
	case idea.FieldMethodology:
		return m.OldMethodology(ctx)
	case idea.FieldExpectedOutcome:
		return m.OldExpectedOutcome(ctx)
	case idea.FieldStatus:
		return m.OldStatus(ctx)
	case idea.FieldPriority:
		return m.OldPriority(ctx)
	case idea.FieldEstimatedDurationMonths:
		return m.OldEstimatedDurationMonths(ctx)
	case idea.FieldRequiredResources:
		return m.OldRequiredResources(ctx)
	case idea.FieldCollaborationNeeded:
		return m.OldCollaborationNeeded(ctx)
	case idea.FieldFundingRequired:
		return m.OldFundingRequired(ctx)
	case idea.FieldEstimatedBudget:
		return m.OldEstimatedBudget(ctx)
	case idea.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case idea.FieldViewCount:
		return m.OldViewCount(ctx)
	case idea.FieldLikeCount:
		return m.OldLikeCount(ctx)
	case idea.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case idea.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Idea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case idea.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case idea.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case idea.FieldAbstract:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbstract(v)
		return nil
	case idea.FieldMotivation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotivation(v)
		return nil
	case idea.FieldMethodology:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethodology(v)
		return nil
	case idea.FieldExpectedOutcome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedOutcome(v)
		return nil
	case idea.FieldStatus:
		v, ok := value.(idea.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case idea.FieldPriority:
		v, ok := value.(idea.Priority)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case idea.FieldEstimatedDurationMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedDurationMonths(v)
		return nil
	case idea.FieldRequiredResources:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiredResources(v)
		return nil
	case idea.FieldCollaborationNeeded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollaborationNeeded(v)
		return nil
	case idea.FieldFundingRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingRequired(v)
		return nil
	case idea.FieldEstimatedBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedBudget(v)
		return nil
	case idea.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case idea.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case idea.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLikeCount(v)
		return nil
	case idea.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case idea.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Idea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdeaMutation) AddedFields() []string {
	var fields []string
	if m.addestimated_duration_months != nil {
		fields = append(fields, idea.FieldEstimatedDurationMonths)
	}
	if m.addestimated_budget != nil {
		fields = append(fields, idea.FieldEstimatedBudget)
	}
	if m.addview_count != nil {
		fields = append(fields, idea.FieldViewCount)
	}
	if m.addlike_count != nil {
		fields = append(fields, idea.FieldLikeCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdeaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case idea.FieldEstimatedDurationMonths:
		return m.AddedEstimatedDurationMonths()
	case idea.FieldEstimatedBudget:
		return m.AddedEstimatedBudget()
	case idea.FieldViewCount:
		return m.AddedViewCount()
	case idea.FieldLikeCount:
		return m.AddedLikeCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdeaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case idea.FieldEstimatedDurationMonths:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedDurationMonths(v)
		return nil
	case idea.FieldEstimatedBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedBudget(v)
		return nil
	case idea.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case idea.FieldLikeCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLikeCount(v)
		return nil
	}
	return fmt.Errorf("unknown Idea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdeaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(idea.FieldAbstract) {
		fields = append(fields, idea.FieldAbstract)
	}
	if m.FieldCleared(idea.FieldMotivation) {
		fields = append(fields, idea.FieldMotivation)
	}
	if m.FieldCleared(idea.FieldMethodology) {
		fields = append(fields, idea.FieldMethodology)
	}
	if m.FieldCleared(idea.FieldExpectedOutcome) {
		fields = append(fields, idea.FieldExpectedOutcome)
	}
	if m.FieldCleared(idea.FieldEstimatedDurationMonths) {
		fields = append(fields, idea.FieldEstimatedDurationMonths)
	}
	if m.FieldCleared(idea.FieldRequiredResources) {
		fields = append(fields, idea.FieldRequiredResources)
	}
	if m.FieldCleared(idea.FieldEstimatedBudget) {
		fields = append(fields, idea.FieldEstimatedBudget)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdeaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdeaMutation) ClearField(name string) error {
	switch name {
	case idea.FieldAbstract:
		m.ClearAbstract()
		return nil
	case idea.FieldMotivation:
		m.ClearMotivation()
		return nil
	case idea.FieldMethodology:
		m.ClearMethodology()
		return nil
	case idea.FieldExpectedOutcome:
		m.ClearExpectedOutcome()
		return nil
	case idea.FieldEstimatedDurationMonths:
		m.ClearEstimatedDurationMonths()
		return nil
	case idea.FieldRequiredResources:
		m.ClearRequiredResources()
		return nil
	case idea.FieldEstimatedBudget:
		m.ClearEstimatedBudget()
		return nil
	}
	return fmt.Errorf("unknown Idea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdeaMutation) ResetField(name string) error {
	switch name {
	case idea.FieldTitle:
		m.ResetTitle()
		return nil
	case idea.FieldSlug:
		m.ResetSlug()
		return nil
	case idea.FieldAbstract:
		m.ResetAbstract()
		return nil
	case idea.FieldMotivation:
		m.ResetMotivation()
		return nil
	case idea.FieldMethodology:
		m.ResetMethodology()
		return nil
	case idea.FieldExpectedOutcome:
		m.ResetExpectedOutcome()
		return nil
	case idea.FieldStatus:
		m.ResetStatus()
		return nil
	case idea.FieldPriority:
		m.ResetPriority()
		return nil
	case idea.FieldEstimatedDurationMonths:
		m.ResetEstimatedDurationMonths()
		return nil
	case idea.FieldRequiredResources:
		m.ResetRequiredResources()
		return nil
	case idea.FieldCollaborationNeeded:
		m.ResetCollaborationNeeded()
		return nil
	case idea.FieldFundingRequired:
		m.ResetFundingRequired()
		return nil
	case idea.FieldEstimatedBudget:
		m.ResetEstimatedBudget()
		return nil
	case idea.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case idea.FieldViewCount:
		m.ResetViewCount()
		return nil
	case idea.FieldLikeCount:
		m.ResetLikeCount()
		return nil
	case idea.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case idea.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Idea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdeaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, idea.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdeaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case idea.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdeaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdeaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdeaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, idea.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdeaMutation) EdgeCleared(name string) bool {
	switch name {
	case idea.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdeaMutation) ClearEdge(name string) error {
	switch name {
	case idea.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Idea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdeaMutation) ResetEdge(name string) error {
	switch name {
	case idea.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Idea edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	code          *string
	name          *string
	native_name   *string
	is_active     *bool
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Language, error)
	predicates    []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id int) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *LanguageMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *LanguageMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *LanguageMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *LanguageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LanguageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LanguageMutation) ResetName() {
	m.name = nil
}

// SetNativeName sets the "native_name" field.
func (m *LanguageMutation) SetNativeName(s string) {
	m.native_name = &s
}

// NativeName returns the value of the "native_name" field in the mutation.
func (m *LanguageMutation) NativeName() (r string, exists bool) {
	v := m.native_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNativeName returns the old "native_name" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldNativeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNativeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNativeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNativeName: %w", err)
	}
	return oldValue.NativeName, nil
}

// ResetNativeName resets all changes to the "native_name" field.
func (m *LanguageMutation) ResetNativeName() {
	m.native_name = nil
}

// SetIsActive sets the "is_active" field.
func (m *LanguageMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *LanguageMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *LanguageMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LanguageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LanguageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LanguageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.code != nil {
		fields = append(fields, language.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, language.FieldName)
	}
	if m.native_name != nil {
		fields = append(fields, language.FieldNativeName)
	}
	if m.is_active != nil {
		fields = append(fields, language.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, language.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldCode:
		return m.Code()
	case language.FieldName:
		return m.Name()
	case language.FieldNativeName:
		return m.NativeName()
	case language.FieldIsActive:
		return m.IsActive()
	case language.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldCode:
		return m.OldCode(ctx)
	case language.FieldName:
		return m.OldName(ctx)
	case language.FieldNativeName:
		return m.OldNativeName(ctx)
	case language.FieldIsActive:
		return m.OldIsActive(ctx)
	case language.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case language.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case language.FieldNativeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNativeName(v)
		return nil
	case language.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case language.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldCode:
		m.ResetCode()
		return nil
	case language.FieldName:
		m.ResetName()
		return nil
	case language.FieldNativeName:
		m.ResetNativeName()
		return nil
	case language.FieldIsActive:
		m.ResetIsActive()
		return nil
	case language.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Language edge %s", name)
}

// PersonalInfoMutation represents an operation that mutates the PersonalInfo nodes in the graph.
type PersonalInfoMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	phone          *string
	website        *string
	location       *string
	address        *string
	linkedin       *string
	github         *string
	twitter        *string
	personal_email *string
	summary        *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*PersonalInfo, error)
	predicates     []predicate.PersonalInfo
}

var _ ent.Mutation = (*PersonalInfoMutation)(nil)

// personalinfoOption allows management of the mutation configuration using functional options.
type personalinfoOption func(*PersonalInfoMutation)

// newPersonalInfoMutation creates new mutation for the PersonalInfo entity.
func newPersonalInfoMutation(c config, op Op, opts ...personalinfoOption) *PersonalInfoMutation {
	m := &PersonalInfoMutation{
		config:        c,
		op:            op,
		typ:           TypePersonalInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonalInfoID sets the ID field of the mutation.
func withPersonalInfoID(id uuid.UUID) personalinfoOption {
	return func(m *PersonalInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *PersonalInfo
		)
		m.oldValue = func(ctx context.Context) (*PersonalInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PersonalInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPersonalInfo sets the old PersonalInfo of the mutation.
func withPersonalInfo(node *PersonalInfo) personalinfoOption {
	return func(m *PersonalInfoMutation) {
		m.oldValue = func(context.Context) (*PersonalInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonalInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonalInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PersonalInfo entities.
func (m *PersonalInfoMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonalInfoMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonalInfoMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PersonalInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPhone sets the "phone" field.
func (m *PersonalInfoMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PersonalInfoMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PersonalInfoMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[personalinfo.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PersonalInfoMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PersonalInfoMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, personalinfo.FieldPhone)
}

// SetWebsite sets the "website" field.
func (m *PersonalInfoMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PersonalInfoMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PersonalInfoMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[personalinfo.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PersonalInfoMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PersonalInfoMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, personalinfo.FieldWebsite)
}

// SetLocation sets the "location" field.
func (m *PersonalInfoMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *PersonalInfoMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *PersonalInfoMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[personalinfo.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *PersonalInfoMutation) LocationCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *PersonalInfoMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, personalinfo.FieldLocation)
}

// SetAddress sets the "address" field.
func (m *PersonalInfoMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PersonalInfoMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PersonalInfoMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[personalinfo.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PersonalInfoMutation) AddressCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PersonalInfoMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, personalinfo.FieldAddress)
}

// SetLinkedin sets the "linkedin" field.
func (m *PersonalInfoMutation) SetLinkedin(s string) {
	m.linkedin = &s
}

// Linkedin returns the value of the "linkedin" field in the mutation.
func (m *PersonalInfoMutation) Linkedin() (r string, exists bool) {
	v := m.linkedin
	if v == nil {
		return
	}
	return *v, true
}

// OldLinkedin returns the old "linkedin" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldLinkedin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLinkedin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLinkedin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLinkedin: %w", err)
	}
	return oldValue.Linkedin, nil
}

// ClearLinkedin clears the value of the "linkedin" field.
func (m *PersonalInfoMutation) ClearLinkedin() {
	m.linkedin = nil
	m.clearedFields[personalinfo.FieldLinkedin] = struct{}{}
}

// LinkedinCleared returns if the "linkedin" field was cleared in this mutation.
func (m *PersonalInfoMutation) LinkedinCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldLinkedin]
	return ok
}

// ResetLinkedin resets all changes to the "linkedin" field.
func (m *PersonalInfoMutation) ResetLinkedin() {
	m.linkedin = nil
	delete(m.clearedFields, personalinfo.FieldLinkedin)
}

// SetGithub sets the "github" field.
func (m *PersonalInfoMutation) SetGithub(s string) {
	m.github = &s
}

// Github returns the value of the "github" field in the mutation.
func (m *PersonalInfoMutation) Github() (r string, exists bool) {
	v := m.github
	if v == nil {
		return
	}
	return *v, true
}

// OldGithub returns the old "github" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldGithub(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithub is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithub requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithub: %w", err)
	}
	return oldValue.Github, nil
}

// ClearGithub clears the value of the "github" field.
func (m *PersonalInfoMutation) ClearGithub() {
	m.github = nil
	m.clearedFields[personalinfo.FieldGithub] = struct{}{}
}

// GithubCleared returns if the "github" field was cleared in this mutation.
func (m *PersonalInfoMutation) GithubCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldGithub]
	return ok
}

// ResetGithub resets all changes to the "github" field.
func (m *PersonalInfoMutation) ResetGithub() {
	m.github = nil
	delete(m.clearedFields, personalinfo.FieldGithub)
}

// SetTwitter sets the "twitter" field.
func (m *PersonalInfoMutation) SetTwitter(s string) {
	m.twitter = &s
}

// Twitter returns the value of the "twitter" field in the mutation.
func (m *PersonalInfoMutation) Twitter() (r string, exists bool) {
	v := m.twitter
	if v == nil {
		return
	}
	return *v, true
}

// OldTwitter returns the old "twitter" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldTwitter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwitter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwitter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwitter: %w", err)
	}
	return oldValue.Twitter, nil
}

// ClearTwitter clears the value of the "twitter" field.
func (m *PersonalInfoMutation) ClearTwitter() {
	m.twitter = nil
	m.clearedFields[personalinfo.FieldTwitter] = struct{}{}
}

// TwitterCleared returns if the "twitter" field was cleared in this mutation.
func (m *PersonalInfoMutation) TwitterCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldTwitter]
	return ok
}

// ResetTwitter resets all changes to the "twitter" field.
func (m *PersonalInfoMutation) ResetTwitter() {
	m.twitter = nil
	delete(m.clearedFields, personalinfo.FieldTwitter)
}

// SetPersonalEmail sets the "personal_email" field.
func (m *PersonalInfoMutation) SetPersonalEmail(s string) {
	m.personal_email = &s
}

// PersonalEmail returns the value of the "personal_email" field in the mutation.
func (m *PersonalInfoMutation) PersonalEmail() (r string, exists bool) {
	v := m.personal_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalEmail returns the old "personal_email" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldPersonalEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalEmail: %w", err)
	}
	return oldValue.PersonalEmail, nil
}

// ClearPersonalEmail clears the value of the "personal_email" field.
func (m *PersonalInfoMutation) ClearPersonalEmail() {
	m.personal_email = nil
	m.clearedFields[personalinfo.FieldPersonalEmail] = struct{}{}
}

// PersonalEmailCleared returns if the "personal_email" field was cleared in this mutation.
func (m *PersonalInfoMutation) PersonalEmailCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldPersonalEmail]
	return ok
}

// ResetPersonalEmail resets all changes to the "personal_email" field.
func (m *PersonalInfoMutation) ResetPersonalEmail() {
	m.personal_email = nil
	delete(m.clearedFields, personalinfo.FieldPersonalEmail)
}

// SetSummary sets the "summary" field.
func (m *PersonalInfoMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *PersonalInfoMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *PersonalInfoMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[personalinfo.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *PersonalInfoMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[personalinfo.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *PersonalInfoMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, personalinfo.FieldSummary)
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonalInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonalInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonalInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonalInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonalInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PersonalInfo entity.
// If the PersonalInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonalInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonalInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PersonalInfoMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PersonalInfoMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PersonalInfoMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PersonalInfoMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PersonalInfoMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PersonalInfoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PersonalInfoMutation builder.
func (m *PersonalInfoMutation) Where(ps ...predicate.PersonalInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonalInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonalInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PersonalInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonalInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonalInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PersonalInfo).
func (m *PersonalInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonalInfoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.phone != nil {
		fields = append(fields, personalinfo.FieldPhone)
	}
	if m.website != nil {
		fields = append(fields, personalinfo.FieldWebsite)
	}
	if m.location != nil {
		fields = append(fields, personalinfo.FieldLocation)
	}
	if m.address != nil {
		fields = append(fields, personalinfo.FieldAddress)
	}
	if m.linkedin != nil {
		fields = append(fields, personalinfo.FieldLinkedin)
	}
	if m.github != nil {
		fields = append(fields, personalinfo.FieldGithub)
	}
	if m.twitter != nil {
		fields = append(fields, personalinfo.FieldTwitter)
	}
	if m.personal_email != nil {
		fields = append(fields, personalinfo.FieldPersonalEmail)
	}
	if m.summary != nil {
		fields = append(fields, personalinfo.FieldSummary)
	}
	if m.created_at != nil {
		fields = append(fields, personalinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, personalinfo.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonalInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case personalinfo.FieldPhone:
		return m.Phone()
	case personalinfo.FieldWebsite:
		return m.Website()
	case personalinfo.FieldLocation:
		return m.Location()
	case personalinfo.FieldAddress:
		return m.Address()
	case personalinfo.FieldLinkedin:
		return m.Linkedin()
	case personalinfo.FieldGithub:
		return m.Github()
	case personalinfo.FieldTwitter:
		return m.Twitter()
	case personalinfo.FieldPersonalEmail:
		return m.PersonalEmail()
	case personalinfo.FieldSummary:
		return m.Summary()
	case personalinfo.FieldCreatedAt:
		return m.CreatedAt()
	case personalinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonalInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case personalinfo.FieldPhone:
		return m.OldPhone(ctx)
	case personalinfo.FieldWebsite:
		return m.OldWebsite(ctx)
	case personalinfo.FieldLocation:
		return m.OldLocation(ctx)
	case personalinfo.FieldAddress:
		return m.OldAddress(ctx)
	case personalinfo.FieldLinkedin:
		return m.OldLinkedin(ctx)
	case personalinfo.FieldGithub:
		return m.OldGithub(ctx)
	case personalinfo.FieldTwitter:
		return m.OldTwitter(ctx)
	case personalinfo.FieldPersonalEmail:
		return m.OldPersonalEmail(ctx)
	case personalinfo.FieldSummary:
		return m.OldSummary(ctx)
	case personalinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case personalinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PersonalInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case personalinfo.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case personalinfo.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case personalinfo.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case personalinfo.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case personalinfo.FieldLinkedin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLinkedin(v)
		return nil
	case personalinfo.FieldGithub:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithub(v)
		return nil
	case personalinfo.FieldTwitter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwitter(v)
		return nil
	case personalinfo.FieldPersonalEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalEmail(v)
		return nil
	case personalinfo.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case personalinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case personalinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonalInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonalInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonalInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PersonalInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonalInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(personalinfo.FieldPhone) {
		fields = append(fields, personalinfo.FieldPhone)
	}
	if m.FieldCleared(personalinfo.FieldWebsite) {
		fields = append(fields, personalinfo.FieldWebsite)
	}
	if m.FieldCleared(personalinfo.FieldLocation) {
		fields = append(fields, personalinfo.FieldLocation)
	}
	if m.FieldCleared(personalinfo.FieldAddress) {
		fields = append(fields, personalinfo.FieldAddress)
	}
	if m.FieldCleared(personalinfo.FieldLinkedin) {
		fields = append(fields, personalinfo.FieldLinkedin)
	}
	if m.FieldCleared(personalinfo.FieldGithub) {
		fields = append(fields, personalinfo.FieldGithub)
	}
	if m.FieldCleared(personalinfo.FieldTwitter) {
		fields = append(fields, personalinfo.FieldTwitter)
	}
	if m.FieldCleared(personalinfo.FieldPersonalEmail) {
		fields = append(fields, personalinfo.FieldPersonalEmail)
	}
	if m.FieldCleared(personalinfo.FieldSummary) {
		fields = append(fields, personalinfo.FieldSummary)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonalInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonalInfoMutation) ClearField(name string) error {
	switch name {
	case personalinfo.FieldPhone:
		m.ClearPhone()
		return nil
	case personalinfo.FieldWebsite:
		m.ClearWebsite()
		return nil
	case personalinfo.FieldLocation:
		m.ClearLocation()
		return nil
	case personalinfo.FieldAddress:
		m.ClearAddress()
		return nil
	case personalinfo.FieldLinkedin:
		m.ClearLinkedin()
		return nil
	case personalinfo.FieldGithub:
		m.ClearGithub()
		return nil
	case personalinfo.FieldTwitter:
		m.ClearTwitter()
		return nil
	case personalinfo.FieldPersonalEmail:
		m.ClearPersonalEmail()
		return nil
	case personalinfo.FieldSummary:
		m.ClearSummary()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonalInfoMutation) ResetField(name string) error {
	switch name {
	case personalinfo.FieldPhone:
		m.ResetPhone()
		return nil
	case personalinfo.FieldWebsite:
		m.ResetWebsite()
		return nil
	case personalinfo.FieldLocation:
		m.ResetLocation()
		return nil
	case personalinfo.FieldAddress:
		m.ResetAddress()
		return nil
	case personalinfo.FieldLinkedin:
		m.ResetLinkedin()
		return nil
	case personalinfo.FieldGithub:
		m.ResetGithub()
		return nil
	case personalinfo.FieldTwitter:
		m.ResetTwitter()
		return nil
	case personalinfo.FieldPersonalEmail:
		m.ResetPersonalEmail()
		return nil
	case personalinfo.FieldSummary:
		m.ResetSummary()
		return nil
	case personalinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case personalinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonalInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, personalinfo.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonalInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case personalinfo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonalInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonalInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonalInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, personalinfo.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonalInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case personalinfo.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonalInfoMutation) ClearEdge(name string) error {
	switch name {
	case personalinfo.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonalInfoMutation) ResetEdge(name string) error {
	switch name {
	case personalinfo.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PersonalInfo edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	title               *string
	slug                *string
	description         *string
	project_type        *string
	status              *project.Status
	start_date          *time.Time
	end_date            *time.Time
	github_url          *string
	demo_url            *string
	documentation_url   *string
	thumbnail_url       *string
	is_featured         *bool
	is_public           *bool
	view_count          *int
	addview_count       *int
	star_count          *int
	addstar_count       *int
	sort_order          *int
	addsort_order       *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uuid.UUID
	cleareduser         bool
	technologies        map[uuid.UUID]struct{}
	removedtechnologies map[uuid.UUID]struct{}
	clearedtechnologies bool
	detail              *uuid.UUID
	cleareddetail       bool
	images              map[uuid.UUID]struct{}
	removedimages       map[uuid.UUID]struct{}
	clearedimages       bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id uuid.UUID) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *ProjectMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ProjectMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ProjectMutation) ResetSlug() {
	m.slug = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetProjectType sets the "project_type" field.
func (m *ProjectMutation) SetProjectType(s string) {
	m.project_type = &s
}

// ProjectType returns the value of the "project_type" field in the mutation.
func (m *ProjectMutation) ProjectType() (r string, exists bool) {
	v := m.project_type
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectType returns the old "project_type" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProjectType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectType: %w", err)
	}
	return oldValue.ProjectType, nil
}

// ResetProjectType resets all changes to the "project_type" field.
func (m *ProjectMutation) ResetProjectType() {
	m.project_type = nil
}

// SetStatus sets the "status" field.
func (m *ProjectMutation) SetStatus(pr project.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProjectMutation) Status() (r project.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStatus(ctx context.Context) (v project.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProjectMutation) ResetStatus() {
	m.status = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ProjectMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[project.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ProjectMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[project.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, project.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[project.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[project.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, project.FieldEndDate)
}

// SetGithubURL sets the "github_url" field.
func (m *ProjectMutation) SetGithubURL(s string) {
	m.github_url = &s
}

// GithubURL returns the value of the "github_url" field in the mutation.
func (m *ProjectMutation) GithubURL() (r string, exists bool) {
	v := m.github_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubURL returns the old "github_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubURL: %w", err)
	}
	return oldValue.GithubURL, nil
}

// ClearGithubURL clears the value of the "github_url" field.
func (m *ProjectMutation) ClearGithubURL() {
	m.github_url = nil
	m.clearedFields[project.FieldGithubURL] = struct{}{}
}

// GithubURLCleared returns if the "github_url" field was cleared in this mutation.
func (m *ProjectMutation) GithubURLCleared() bool {
	_, ok := m.clearedFields[project.FieldGithubURL]
	return ok
}

// ResetGithubURL resets all changes to the "github_url" field.
func (m *ProjectMutation) ResetGithubURL() {
	m.github_url = nil
	delete(m.clearedFields, project.FieldGithubURL)
}

// SetDemoURL sets the "demo_url" field.
func (m *ProjectMutation) SetDemoURL(s string) {
	m.demo_url = &s
}

// DemoURL returns the value of the "demo_url" field in the mutation.
func (m *ProjectMutation) DemoURL() (r string, exists bool) {
	v := m.demo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDemoURL returns the old "demo_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDemoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDemoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDemoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDemoURL: %w", err)
	}
	return oldValue.DemoURL, nil
}

// ClearDemoURL clears the value of the "demo_url" field.
func (m *ProjectMutation) ClearDemoURL() {
	m.demo_url = nil
	m.clearedFields[project.FieldDemoURL] = struct{}{}
}

// DemoURLCleared returns if the "demo_url" field was cleared in this mutation.
func (m *ProjectMutation) DemoURLCleared() bool {
	_, ok := m.clearedFields[project.FieldDemoURL]
	return ok
}

// ResetDemoURL resets all changes to the "demo_url" field.
func (m *ProjectMutation) ResetDemoURL() {
	m.demo_url = nil
	delete(m.clearedFields, project.FieldDemoURL)
}

// SetDocumentationURL sets the "documentation_url" field.
func (m *ProjectMutation) SetDocumentationURL(s string) {
	m.documentation_url = &s
}

// DocumentationURL returns the value of the "documentation_url" field in the mutation.
func (m *ProjectMutation) DocumentationURL() (r string, exists bool) {
	v := m.documentation_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationURL returns the old "documentation_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDocumentationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationURL: %w", err)
	}
	return oldValue.DocumentationURL, nil
}

// ClearDocumentationURL clears the value of the "documentation_url" field.
func (m *ProjectMutation) ClearDocumentationURL() {
	m.documentation_url = nil
	m.clearedFields[project.FieldDocumentationURL] = struct{}{}
}

// DocumentationURLCleared returns if the "documentation_url" field was cleared in this mutation.
func (m *ProjectMutation) DocumentationURLCleared() bool {
	_, ok := m.clearedFields[project.FieldDocumentationURL]
	return ok
}

// ResetDocumentationURL resets all changes to the "documentation_url" field.
func (m *ProjectMutation) ResetDocumentationURL() {
	m.documentation_url = nil
	delete(m.clearedFields, project.FieldDocumentationURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *ProjectMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *ProjectMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *ProjectMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[project.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *ProjectMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[project.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *ProjectMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, project.FieldThumbnailURL)
}

// SetIsFeatured sets the "is_featured" field.
func (m *ProjectMutation) SetIsFeatured(b bool) {
	m.is_featured = &b
}

// IsFeatured returns the value of the "is_featured" field in the mutation.
func (m *ProjectMutation) IsFeatured() (r bool, exists bool) {
	v := m.is_featured
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFeatured returns the old "is_featured" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsFeatured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFeatured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFeatured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFeatured: %w", err)
	}
	return oldValue.IsFeatured, nil
}

// ResetIsFeatured resets all changes to the "is_featured" field.
func (m *ProjectMutation) ResetIsFeatured() {
	m.is_featured = nil
}

// SetIsPublic sets the "is_public" field.
func (m *ProjectMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ProjectMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ProjectMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetViewCount sets the "view_count" field.
func (m *ProjectMutation) SetViewCount(i int) {
	m.view_count = &i
	m.addview_count = nil
}

// ViewCount returns the value of the "view_count" field in the mutation.
func (m *ProjectMutation) ViewCount() (r int, exists bool) {
	v := m.view_count
	if v == nil {
		return
	}
	return *v, true
}

// OldViewCount returns the old "view_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldViewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewCount: %w", err)
	}
	return oldValue.ViewCount, nil
}

// AddViewCount adds i to the "view_count" field.
func (m *ProjectMutation) AddViewCount(i int) {
	if m.addview_count != nil {
		*m.addview_count += i
	} else {
		m.addview_count = &i
	}
}

// AddedViewCount returns the value that was added to the "view_count" field in this mutation.
func (m *ProjectMutation) AddedViewCount() (r int, exists bool) {
	v := m.addview_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetViewCount resets all changes to the "view_count" field.
func (m *ProjectMutation) ResetViewCount() {
	m.view_count = nil
	m.addview_count = nil
}

// SetStarCount sets the "star_count" field.
func (m *ProjectMutation) SetStarCount(i int) {
	m.star_count = &i
	m.addstar_count = nil
}

// StarCount returns the value of the "star_count" field in the mutation.
func (m *ProjectMutation) StarCount() (r int, exists bool) {
	v := m.star_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStarCount returns the old "star_count" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStarCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarCount: %w", err)
	}
	return oldValue.StarCount, nil
}

// AddStarCount adds i to the "star_count" field.
func (m *ProjectMutation) AddStarCount(i int) {
	if m.addstar_count != nil {
		*m.addstar_count += i
	} else {
		m.addstar_count = &i
	}
}

// AddedStarCount returns the value that was added to the "star_count" field in this mutation.
func (m *ProjectMutation) AddedStarCount() (r int, exists bool) {
	v := m.addstar_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStarCount resets all changes to the "star_count" field.
func (m *ProjectMutation) ResetStarCount() {
	m.star_count = nil
	m.addstar_count = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *ProjectMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProjectMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProjectMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProjectMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProjectMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProjectMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProjectMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTechnologyIDs adds the "technologies" edge to the ProjectTechnology entity by ids.
func (m *ProjectMutation) AddTechnologyIDs(ids ...uuid.UUID) {
	if m.technologies == nil {
		m.technologies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.technologies[ids[i]] = struct{}{}
	}
}

// ClearTechnologies clears the "technologies" edge to the ProjectTechnology entity.
func (m *ProjectMutation) ClearTechnologies() {
	m.clearedtechnologies = true
}

// TechnologiesCleared reports if the "technologies" edge to the ProjectTechnology entity was cleared.
func (m *ProjectMutation) TechnologiesCleared() bool {
	return m.clearedtechnologies
}

// RemoveTechnologyIDs removes the "technologies" edge to the ProjectTechnology entity by IDs.
func (m *ProjectMutation) RemoveTechnologyIDs(ids ...uuid.UUID) {
	if m.removedtechnologies == nil {
		m.removedtechnologies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.technologies, ids[i])
		m.removedtechnologies[ids[i]] = struct{}{}
	}
}

// RemovedTechnologies returns the removed IDs of the "technologies" edge to the ProjectTechnology entity.
func (m *ProjectMutation) RemovedTechnologiesIDs() (ids []uuid.UUID) {
	for id := range m.removedtechnologies {
		ids = append(ids, id)
	}
	return
}

// TechnologiesIDs returns the "technologies" edge IDs in the mutation.
func (m *ProjectMutation) TechnologiesIDs() (ids []uuid.UUID) {
	for id := range m.technologies {
		ids = append(ids, id)
	}
	return
}

// ResetTechnologies resets all changes to the "technologies" edge.
func (m *ProjectMutation) ResetTechnologies() {
	m.technologies = nil
	m.clearedtechnologies = false
	m.removedtechnologies = nil
}

// SetDetailID sets the "detail" edge to the ProjectDetail entity by id.
func (m *ProjectMutation) SetDetailID(id uuid.UUID) {
	m.detail = &id
}

// ClearDetail clears the "detail" edge to the ProjectDetail entity.
func (m *ProjectMutation) ClearDetail() {
	m.cleareddetail = true
}

// DetailCleared reports if the "detail" edge to the ProjectDetail entity was cleared.
func (m *ProjectMutation) DetailCleared() bool {
	return m.cleareddetail
}

// DetailID returns the "detail" edge ID in the mutation.
func (m *ProjectMutation) DetailID() (id uuid.UUID, exists bool) {
	if m.detail != nil {
		return *m.detail, true
	}
	return
}

// DetailIDs returns the "detail" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DetailID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) DetailIDs() (ids []uuid.UUID) {
	if id := m.detail; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDetail resets all changes to the "detail" edge.
func (m *ProjectMutation) ResetDetail() {
	m.detail = nil
	m.cleareddetail = false
}

// AddImageIDs adds the "images" edge to the ProjectImage entity by ids.
func (m *ProjectMutation) AddImageIDs(ids ...uuid.UUID) {
	if m.images == nil {
		m.images = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.images[ids[i]] = struct{}{}
	}
}

// ClearImages clears the "images" edge to the ProjectImage entity.
func (m *ProjectMutation) ClearImages() {
	m.clearedimages = true
}

// ImagesCleared reports if the "images" edge to the ProjectImage entity was cleared.
func (m *ProjectMutation) ImagesCleared() bool {
	return m.clearedimages
}

// RemoveImageIDs removes the "images" edge to the ProjectImage entity by IDs.
func (m *ProjectMutation) RemoveImageIDs(ids ...uuid.UUID) {
	if m.removedimages == nil {
		m.removedimages = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.images, ids[i])
		m.removedimages[ids[i]] = struct{}{}
	}
}

// RemovedImages returns the removed IDs of the "images" edge to the ProjectImage entity.
func (m *ProjectMutation) RemovedImagesIDs() (ids []uuid.UUID) {
	for id := range m.removedimages {
		ids = append(ids, id)
	}
	return
}

// ImagesIDs returns the "images" edge IDs in the mutation.
func (m *ProjectMutation) ImagesIDs() (ids []uuid.UUID) {
	for id := range m.images {
		ids = append(ids, id)
	}
	return
}

// ResetImages resets all changes to the "images" edge.
func (m *ProjectMutation) ResetImages() {
	m.images = nil
	m.clearedimages = false
	m.removedimages = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.title != nil {
		fields = append(fields, project.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, project.FieldSlug)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.project_type != nil {
		fields = append(fields, project.FieldProjectType)
	}
	if m.status != nil {
		fields = append(fields, project.FieldStatus)
	}
	if m.start_date != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	if m.github_url != nil {
		fields = append(fields, project.FieldGithubURL)
	}
	if m.demo_url != nil {
		fields = append(fields, project.FieldDemoURL)
	}
	if m.documentation_url != nil {
		fields = append(fields, project.FieldDocumentationURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, project.FieldThumbnailURL)
	}
	if m.is_featured != nil {
		fields = append(fields, project.FieldIsFeatured)
	}
	if m.is_public != nil {
		fields = append(fields, project.FieldIsPublic)
	}
	if m.view_count != nil {
		fields = append(fields, project.FieldViewCount)
	}
	if m.star_count != nil {
		fields = append(fields, project.FieldStarCount)
	}
	if m.sort_order != nil {
		fields = append(fields, project.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldTitle:
		return m.Title()
	case project.FieldSlug:
		return m.Slug()
	case project.FieldDescription:
		return m.Description()
	case project.FieldProjectType:
		return m.ProjectType()
	case project.FieldStatus:
		return m.Status()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	case project.FieldGithubURL:
		return m.GithubURL()
	case project.FieldDemoURL:
		return m.DemoURL()
	case project.FieldDocumentationURL:
		return m.DocumentationURL()
	case project.FieldThumbnailURL:
		return m.ThumbnailURL()
	case project.FieldIsFeatured:
		return m.IsFeatured()
	case project.FieldIsPublic:
		return m.IsPublic()
	case project.FieldViewCount:
		return m.ViewCount()
	case project.FieldStarCount:
		return m.StarCount()
	case project.FieldSortOrder:
		return m.SortOrder()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldTitle:
		return m.OldTitle(ctx)
	case project.FieldSlug:
		return m.OldSlug(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldProjectType:
		return m.OldProjectType(ctx)
	case project.FieldStatus:
		return m.OldStatus(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	case project.FieldGithubURL:
		return m.OldGithubURL(ctx)
	case project.FieldDemoURL:
		return m.OldDemoURL(ctx)
	case project.FieldDocumentationURL:
		return m.OldDocumentationURL(ctx)
	case project.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case project.FieldIsFeatured:
		return m.OldIsFeatured(ctx)
	case project.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case project.FieldViewCount:
		return m.OldViewCount(ctx)
	case project.FieldStarCount:
		return m.OldStarCount(ctx)
	case project.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case project.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldProjectType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectType(v)
		return nil
	case project.FieldStatus:
		v, ok := value.(project.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case project.FieldGithubURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubURL(v)
		return nil
	case project.FieldDemoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDemoURL(v)
		return nil
	case project.FieldDocumentationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationURL(v)
		return nil
	case project.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case project.FieldIsFeatured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFeatured(v)
		return nil
	case project.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case project.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewCount(v)
		return nil
	case project.FieldStarCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarCount(v)
		return nil
	case project.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addview_count != nil {
		fields = append(fields, project.FieldViewCount)
	}
	if m.addstar_count != nil {
		fields = append(fields, project.FieldStarCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, project.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldViewCount:
		return m.AddedViewCount()
	case project.FieldStarCount:
		return m.AddedStarCount()
	case project.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldViewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddViewCount(v)
		return nil
	case project.FieldStarCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarCount(v)
		return nil
	case project.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldStartDate) {
		fields = append(fields, project.FieldStartDate)
	}
	if m.FieldCleared(project.FieldEndDate) {
		fields = append(fields, project.FieldEndDate)
	}
	if m.FieldCleared(project.FieldGithubURL) {
		fields = append(fields, project.FieldGithubURL)
	}
	if m.FieldCleared(project.FieldDemoURL) {
		fields = append(fields, project.FieldDemoURL)
	}
	if m.FieldCleared(project.FieldDocumentationURL) {
		fields = append(fields, project.FieldDocumentationURL)
	}
	if m.FieldCleared(project.FieldThumbnailURL) {
		fields = append(fields, project.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldStartDate:
		m.ClearStartDate()
		return nil
	case project.FieldEndDate:
		m.ClearEndDate()
		return nil
	case project.FieldGithubURL:
		m.ClearGithubURL()
		return nil
	case project.FieldDemoURL:
		m.ClearDemoURL()
		return nil
	case project.FieldDocumentationURL:
		m.ClearDocumentationURL()
		return nil
	case project.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldTitle:
		m.ResetTitle()
		return nil
	case project.FieldSlug:
		m.ResetSlug()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldProjectType:
		m.ResetProjectType()
		return nil
	case project.FieldStatus:
		m.ResetStatus()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	case project.FieldGithubURL:
		m.ResetGithubURL()
		return nil
	case project.FieldDemoURL:
		m.ResetDemoURL()
		return nil
	case project.FieldDocumentationURL:
		m.ResetDocumentationURL()
		return nil
	case project.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case project.FieldIsFeatured:
		m.ResetIsFeatured()
		return nil
	case project.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case project.FieldViewCount:
		m.ResetViewCount()
		return nil
	case project.FieldStarCount:
		m.ResetStarCount()
		return nil
	case project.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, project.EdgeUser)
	}
	if m.technologies != nil {
		edges = append(edges, project.EdgeTechnologies)
	}
	if m.detail != nil {
		edges = append(edges, project.EdgeDetail)
	}
	if m.images != nil {
		edges = append(edges, project.EdgeImages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTechnologies:
		ids := make([]ent.Value, 0, len(m.technologies))
		for id := range m.technologies {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeDetail:
		if id := m.detail; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.images))
		for id := range m.images {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtechnologies != nil {
		edges = append(edges, project.EdgeTechnologies)
	}
	if m.removedimages != nil {
		edges = append(edges, project.EdgeImages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeTechnologies:
		ids := make([]ent.Value, 0, len(m.removedtechnologies))
		for id := range m.removedtechnologies {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeImages:
		ids := make([]ent.Value, 0, len(m.removedimages))
		for id := range m.removedimages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, project.EdgeUser)
	}
	if m.clearedtechnologies {
		edges = append(edges, project.EdgeTechnologies)
	}
	if m.cleareddetail {
		edges = append(edges, project.EdgeDetail)
	}
	if m.clearedimages {
		edges = append(edges, project.EdgeImages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeUser:
		return m.cleareduser
	case project.EdgeTechnologies:
		return m.clearedtechnologies
	case project.EdgeDetail:
		return m.cleareddetail
	case project.EdgeImages:
		return m.clearedimages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ClearUser()
		return nil
	case project.EdgeDetail:
		m.ClearDetail()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeUser:
		m.ResetUser()
		return nil
	case project.EdgeTechnologies:
		m.ResetTechnologies()
		return nil
	case project.EdgeDetail:
		m.ResetDetail()
		return nil
	case project.EdgeImages:
		m.ResetImages()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectDetailMutation represents an operation that mutates the ProjectDetail nodes in the graph.
type ProjectDetailMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	full_description          *string
	features                  *[]string
	appendfeatures            []string
	key_achievements          *[]string
	appendkey_achievements    []string
	challenges_faced          *[]string
	appendchallenges_faced    []string
	lessons_learned           *[]string
	appendlessons_learned     []string
	technical_overview        *string
	installation_instructions *string
	usage_instructions        *string
	api_documentation         *string
	deployment_notes          *string
	future_enhancements       *string
	team_members              *[]string
	appendteam_members        []string
	project_duration          *string
	target_audience           *string
	performance_metrics       *map[string]interface{}
	testing_approach          *map[string]interface{}
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	project                   *uuid.UUID
	clearedproject            bool
	done                      bool
	oldValue                  func(context.Context) (*ProjectDetail, error)
	predicates                []predicate.ProjectDetail
}

var _ ent.Mutation = (*ProjectDetailMutation)(nil)

// projectdetailOption allows management of the mutation configuration using functional options.
type projectdetailOption func(*ProjectDetailMutation)

// newProjectDetailMutation creates new mutation for the ProjectDetail entity.
func newProjectDetailMutation(c config, op Op, opts ...projectdetailOption) *ProjectDetailMutation {
	m := &ProjectDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectDetailID sets the ID field of the mutation.
func withProjectDetailID(id uuid.UUID) projectdetailOption {
	return func(m *ProjectDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectDetail
		)
		m.oldValue = func(ctx context.Context) (*ProjectDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectDetail sets the old ProjectDetail of the mutation.
func withProjectDetail(node *ProjectDetail) projectdetailOption {
	return func(m *ProjectDetailMutation) {
		m.oldValue = func(context.Context) (*ProjectDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectDetail entities.
func (m *ProjectDetailMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectDetailMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectDetailMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFullDescription sets the "full_description" field.
func (m *ProjectDetailMutation) SetFullDescription(s string) {
	m.full_description = &s
}

// FullDescription returns the value of the "full_description" field in the mutation.
func (m *ProjectDetailMutation) FullDescription() (r string, exists bool) {
	v := m.full_description
	if v == nil {
		return
	}
	return *v, true
}

// OldFullDescription returns the old "full_description" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldFullDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullDescription: %w", err)
	}
	return oldValue.FullDescription, nil
}

// ClearFullDescription clears the value of the "full_description" field.
func (m *ProjectDetailMutation) ClearFullDescription() {
	m.full_description = nil
	m.clearedFields[projectdetail.FieldFullDescription] = struct{}{}
}

// FullDescriptionCleared returns if the "full_description" field was cleared in this mutation.
func (m *ProjectDetailMutation) FullDescriptionCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldFullDescription]
	return ok
}

// ResetFullDescription resets all changes to the "full_description" field.
func (m *ProjectDetailMutation) ResetFullDescription() {
	m.full_description = nil
	delete(m.clearedFields, projectdetail.FieldFullDescription)
}

// SetFeatures sets the "features" field.
func (m *ProjectDetailMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *ProjectDetailMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *ProjectDetailMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *ProjectDetailMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ClearFeatures clears the value of the "features" field.
func (m *ProjectDetailMutation) ClearFeatures() {
	m.features = nil
	m.appendfeatures = nil
	m.clearedFields[projectdetail.FieldFeatures] = struct{}{}
}

// FeaturesCleared returns if the "features" field was cleared in this mutation.
func (m *ProjectDetailMutation) FeaturesCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldFeatures]
	return ok
}

// ResetFeatures resets all changes to the "features" field.
func (m *ProjectDetailMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
	delete(m.clearedFields, projectdetail.FieldFeatures)
}

// SetKeyAchievements sets the "key_achievements" field.
func (m *ProjectDetailMutation) SetKeyAchievements(s []string) {
	m.key_achievements = &s
	m.appendkey_achievements = nil
}

// KeyAchievements returns the value of the "key_achievements" field in the mutation.
func (m *ProjectDetailMutation) KeyAchievements() (r []string, exists bool) {
	v := m.key_achievements
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyAchievements returns the old "key_achievements" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldKeyAchievements(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyAchievements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyAchievements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyAchievements: %w", err)
	}
	return oldValue.KeyAchievements, nil
}

// AppendKeyAchievements adds s to the "key_achievements" field.
func (m *ProjectDetailMutation) AppendKeyAchievements(s []string) {
	m.appendkey_achievements = append(m.appendkey_achievements, s...)
}

// AppendedKeyAchievements returns the list of values that were appended to the "key_achievements" field in this mutation.
func (m *ProjectDetailMutation) AppendedKeyAchievements() ([]string, bool) {
	if len(m.appendkey_achievements) == 0 {
		return nil, false
	}
	return m.appendkey_achievements, true
}

// ClearKeyAchievements clears the value of the "key_achievements" field.
func (m *ProjectDetailMutation) ClearKeyAchievements() {
	m.key_achievements = nil
	m.appendkey_achievements = nil
	m.clearedFields[projectdetail.FieldKeyAchievements] = struct{}{}
}

// KeyAchievementsCleared returns if the "key_achievements" field was cleared in this mutation.
func (m *ProjectDetailMutation) KeyAchievementsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldKeyAchievements]
	return ok
}

// ResetKeyAchievements resets all changes to the "key_achievements" field.
func (m *ProjectDetailMutation) ResetKeyAchievements() {
	m.key_achievements = nil
	m.appendkey_achievements = nil
	delete(m.clearedFields, projectdetail.FieldKeyAchievements)
}

// SetChallengesFaced sets the "challenges_faced" field.
func (m *ProjectDetailMutation) SetChallengesFaced(s []string) {
	m.challenges_faced = &s
	m.appendchallenges_faced = nil
}

// ChallengesFaced returns the value of the "challenges_faced" field in the mutation.
func (m *ProjectDetailMutation) ChallengesFaced() (r []string, exists bool) {
	v := m.challenges_faced
	if v == nil {
		return
	}
	return *v, true
}

// OldChallengesFaced returns the old "challenges_faced" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldChallengesFaced(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChallengesFaced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChallengesFaced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChallengesFaced: %w", err)
	}
	return oldValue.ChallengesFaced, nil
}

// AppendChallengesFaced adds s to the "challenges_faced" field.
func (m *ProjectDetailMutation) AppendChallengesFaced(s []string) {
	m.appendchallenges_faced = append(m.appendchallenges_faced, s...)
}

// AppendedChallengesFaced returns the list of values that were appended to the "challenges_faced" field in this mutation.
func (m *ProjectDetailMutation) AppendedChallengesFaced() ([]string, bool) {
	if len(m.appendchallenges_faced) == 0 {
		return nil, false
	}
	return m.appendchallenges_faced, true
}

// ClearChallengesFaced clears the value of the "challenges_faced" field.
func (m *ProjectDetailMutation) ClearChallengesFaced() {
	m.challenges_faced = nil
	m.appendchallenges_faced = nil
	m.clearedFields[projectdetail.FieldChallengesFaced] = struct{}{}
}

// ChallengesFacedCleared returns if the "challenges_faced" field was cleared in this mutation.
func (m *ProjectDetailMutation) ChallengesFacedCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldChallengesFaced]
	return ok
}

// ResetChallengesFaced resets all changes to the "challenges_faced" field.
func (m *ProjectDetailMutation) ResetChallengesFaced() {
	m.challenges_faced = nil
	m.appendchallenges_faced = nil
	delete(m.clearedFields, projectdetail.FieldChallengesFaced)
}

// SetLessonsLearned sets the "lessons_learned" field.
func (m *ProjectDetailMutation) SetLessonsLearned(s []string) {
	m.lessons_learned = &s
	m.appendlessons_learned = nil
}

// LessonsLearned returns the value of the "lessons_learned" field in the mutation.
func (m *ProjectDetailMutation) LessonsLearned() (r []string, exists bool) {
	v := m.lessons_learned
	if v == nil {
		return
	}
	return *v, true
}

// OldLessonsLearned returns the old "lessons_learned" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldLessonsLearned(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLessonsLearned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLessonsLearned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLessonsLearned: %w", err)
	}
	return oldValue.LessonsLearned, nil
}

// AppendLessonsLearned adds s to the "lessons_learned" field.
func (m *ProjectDetailMutation) AppendLessonsLearned(s []string) {
	m.appendlessons_learned = append(m.appendlessons_learned, s...)
}

// AppendedLessonsLearned returns the list of values that were appended to the "lessons_learned" field in this mutation.
func (m *ProjectDetailMutation) AppendedLessonsLearned() ([]string, bool) {
	if len(m.appendlessons_learned) == 0 {
		return nil, false
	}
	return m.appendlessons_learned, true
}

// ClearLessonsLearned clears the value of the "lessons_learned" field.
func (m *ProjectDetailMutation) ClearLessonsLearned() {
	m.lessons_learned = nil
	m.appendlessons_learned = nil
	m.clearedFields[projectdetail.FieldLessonsLearned] = struct{}{}
}

// LessonsLearnedCleared returns if the "lessons_learned" field was cleared in this mutation.
func (m *ProjectDetailMutation) LessonsLearnedCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldLessonsLearned]
	return ok
}

// ResetLessonsLearned resets all changes to the "lessons_learned" field.
func (m *ProjectDetailMutation) ResetLessonsLearned() {
	m.lessons_learned = nil
	m.appendlessons_learned = nil
	delete(m.clearedFields, projectdetail.FieldLessonsLearned)
}

// SetTechnicalOverview sets the "technical_overview" field.
func (m *ProjectDetailMutation) SetTechnicalOverview(s string) {
	m.technical_overview = &s
}

// TechnicalOverview returns the value of the "technical_overview" field in the mutation.
func (m *ProjectDetailMutation) TechnicalOverview() (r string, exists bool) {
	v := m.technical_overview
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnicalOverview returns the old "technical_overview" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldTechnicalOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnicalOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnicalOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnicalOverview: %w", err)
	}
	return oldValue.TechnicalOverview, nil
}

// ClearTechnicalOverview clears the value of the "technical_overview" field.
func (m *ProjectDetailMutation) ClearTechnicalOverview() {
	m.technical_overview = nil
	m.clearedFields[projectdetail.FieldTechnicalOverview] = struct{}{}
}

// TechnicalOverviewCleared returns if the "technical_overview" field was cleared in this mutation.
func (m *ProjectDetailMutation) TechnicalOverviewCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldTechnicalOverview]
	return ok
}

// ResetTechnicalOverview resets all changes to the "technical_overview" field.
func (m *ProjectDetailMutation) ResetTechnicalOverview() {
	m.technical_overview = nil
	delete(m.clearedFields, projectdetail.FieldTechnicalOverview)
}

// SetInstallationInstructions sets the "installation_instructions" field.
func (m *ProjectDetailMutation) SetInstallationInstructions(s string) {
	m.installation_instructions = &s
}

// InstallationInstructions returns the value of the "installation_instructions" field in the mutation.
func (m *ProjectDetailMutation) InstallationInstructions() (r string, exists bool) {
	v := m.installation_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallationInstructions returns the old "installation_instructions" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldInstallationInstructions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallationInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallationInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallationInstructions: %w", err)
	}
	return oldValue.InstallationInstructions, nil
}

// ClearInstallationInstructions clears the value of the "installation_instructions" field.
func (m *ProjectDetailMutation) ClearInstallationInstructions() {
	m.installation_instructions = nil
	m.clearedFields[projectdetail.FieldInstallationInstructions] = struct{}{}
}

// InstallationInstructionsCleared returns if the "installation_instructions" field was cleared in this mutation.
func (m *ProjectDetailMutation) InstallationInstructionsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldInstallationInstructions]
	return ok
}

// ResetInstallationInstructions resets all changes to the "installation_instructions" field.
func (m *ProjectDetailMutation) ResetInstallationInstructions() {
	m.installation_instructions = nil
	delete(m.clearedFields, projectdetail.FieldInstallationInstructions)
}

// SetUsageInstructions sets the "usage_instructions" field.
func (m *ProjectDetailMutation) SetUsageInstructions(s string) {
	m.usage_instructions = &s
}

// UsageInstructions returns the value of the "usage_instructions" field in the mutation.
func (m *ProjectDetailMutation) UsageInstructions() (r string, exists bool) {
	v := m.usage_instructions
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageInstructions returns the old "usage_instructions" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldUsageInstructions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageInstructions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageInstructions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageInstructions: %w", err)
	}
	return oldValue.UsageInstructions, nil
}

// ClearUsageInstructions clears the value of the "usage_instructions" field.
func (m *ProjectDetailMutation) ClearUsageInstructions() {
	m.usage_instructions = nil
	m.clearedFields[projectdetail.FieldUsageInstructions] = struct{}{}
}

// UsageInstructionsCleared returns if the "usage_instructions" field was cleared in this mutation.
func (m *ProjectDetailMutation) UsageInstructionsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldUsageInstructions]
	return ok
}

// ResetUsageInstructions resets all changes to the "usage_instructions" field.
func (m *ProjectDetailMutation) ResetUsageInstructions() {
	m.usage_instructions = nil
	delete(m.clearedFields, projectdetail.FieldUsageInstructions)
}

// SetAPIDocumentation sets the "api_documentation" field.
func (m *ProjectDetailMutation) SetAPIDocumentation(s string) {
	m.api_documentation = &s
}

// APIDocumentation returns the value of the "api_documentation" field in the mutation.
func (m *ProjectDetailMutation) APIDocumentation() (r string, exists bool) {
	v := m.api_documentation
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIDocumentation returns the old "api_documentation" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldAPIDocumentation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIDocumentation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIDocumentation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIDocumentation: %w", err)
	}
	return oldValue.APIDocumentation, nil
}

// ClearAPIDocumentation clears the value of the "api_documentation" field.
func (m *ProjectDetailMutation) ClearAPIDocumentation() {
	m.api_documentation = nil
	m.clearedFields[projectdetail.FieldAPIDocumentation] = struct{}{}
}

// APIDocumentationCleared returns if the "api_documentation" field was cleared in this mutation.
func (m *ProjectDetailMutation) APIDocumentationCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldAPIDocumentation]
	return ok
}

// ResetAPIDocumentation resets all changes to the "api_documentation" field.
func (m *ProjectDetailMutation) ResetAPIDocumentation() {
	m.api_documentation = nil
	delete(m.clearedFields, projectdetail.FieldAPIDocumentation)
}

// SetDeploymentNotes sets the "deployment_notes" field.
func (m *ProjectDetailMutation) SetDeploymentNotes(s string) {
	m.deployment_notes = &s
}

// DeploymentNotes returns the value of the "deployment_notes" field in the mutation.
func (m *ProjectDetailMutation) DeploymentNotes() (r string, exists bool) {
	v := m.deployment_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldDeploymentNotes returns the old "deployment_notes" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldDeploymentNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeploymentNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeploymentNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeploymentNotes: %w", err)
	}
	return oldValue.DeploymentNotes, nil
}

// ClearDeploymentNotes clears the value of the "deployment_notes" field.
func (m *ProjectDetailMutation) ClearDeploymentNotes() {
	m.deployment_notes = nil
	m.clearedFields[projectdetail.FieldDeploymentNotes] = struct{}{}
}

// DeploymentNotesCleared returns if the "deployment_notes" field was cleared in this mutation.
func (m *ProjectDetailMutation) DeploymentNotesCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldDeploymentNotes]
	return ok
}

// ResetDeploymentNotes resets all changes to the "deployment_notes" field.
func (m *ProjectDetailMutation) ResetDeploymentNotes() {
	m.deployment_notes = nil
	delete(m.clearedFields, projectdetail.FieldDeploymentNotes)
}

// SetFutureEnhancements sets the "future_enhancements" field.
func (m *ProjectDetailMutation) SetFutureEnhancements(s string) {
	m.future_enhancements = &s
}

// FutureEnhancements returns the value of the "future_enhancements" field in the mutation.
func (m *ProjectDetailMutation) FutureEnhancements() (r string, exists bool) {
	v := m.future_enhancements
	if v == nil {
		return
	}
	return *v, true
}

// OldFutureEnhancements returns the old "future_enhancements" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldFutureEnhancements(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFutureEnhancements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFutureEnhancements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFutureEnhancements: %w", err)
	}
	return oldValue.FutureEnhancements, nil
}

// ClearFutureEnhancements clears the value of the "future_enhancements" field.
func (m *ProjectDetailMutation) ClearFutureEnhancements() {
	m.future_enhancements = nil
	m.clearedFields[projectdetail.FieldFutureEnhancements] = struct{}{}
}

// FutureEnhancementsCleared returns if the "future_enhancements" field was cleared in this mutation.
func (m *ProjectDetailMutation) FutureEnhancementsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldFutureEnhancements]
	return ok
}

// ResetFutureEnhancements resets all changes to the "future_enhancements" field.
func (m *ProjectDetailMutation) ResetFutureEnhancements() {
	m.future_enhancements = nil
	delete(m.clearedFields, projectdetail.FieldFutureEnhancements)
}

// SetTeamMembers sets the "team_members" field.
func (m *ProjectDetailMutation) SetTeamMembers(s []string) {
	m.team_members = &s
	m.appendteam_members = nil
}

// TeamMembers returns the value of the "team_members" field in the mutation.
func (m *ProjectDetailMutation) TeamMembers() (r []string, exists bool) {
	v := m.team_members
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamMembers returns the old "team_members" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldTeamMembers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamMembers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamMembers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamMembers: %w", err)
	}
	return oldValue.TeamMembers, nil
}

// AppendTeamMembers adds s to the "team_members" field.
func (m *ProjectDetailMutation) AppendTeamMembers(s []string) {
	m.appendteam_members = append(m.appendteam_members, s...)
}

// AppendedTeamMembers returns the list of values that were appended to the "team_members" field in this mutation.
func (m *ProjectDetailMutation) AppendedTeamMembers() ([]string, bool) {
	if len(m.appendteam_members) == 0 {
		return nil, false
	}
	return m.appendteam_members, true
}

// ClearTeamMembers clears the value of the "team_members" field.
func (m *ProjectDetailMutation) ClearTeamMembers() {
	m.team_members = nil
	m.appendteam_members = nil
	m.clearedFields[projectdetail.FieldTeamMembers] = struct{}{}
}

// TeamMembersCleared returns if the "team_members" field was cleared in this mutation.
func (m *ProjectDetailMutation) TeamMembersCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldTeamMembers]
	return ok
}

// ResetTeamMembers resets all changes to the "team_members" field.
func (m *ProjectDetailMutation) ResetTeamMembers() {
	m.team_members = nil
	m.appendteam_members = nil
	delete(m.clearedFields, projectdetail.FieldTeamMembers)
}

// SetProjectDuration sets the "project_duration" field.
func (m *ProjectDetailMutation) SetProjectDuration(s string) {
	m.project_duration = &s
}

// ProjectDuration returns the value of the "project_duration" field in the mutation.
func (m *ProjectDetailMutation) ProjectDuration() (r string, exists bool) {
	v := m.project_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectDuration returns the old "project_duration" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldProjectDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectDuration: %w", err)
	}
	return oldValue.ProjectDuration, nil
}

// ClearProjectDuration clears the value of the "project_duration" field.
func (m *ProjectDetailMutation) ClearProjectDuration() {
	m.project_duration = nil
	m.clearedFields[projectdetail.FieldProjectDuration] = struct{}{}
}

// ProjectDurationCleared returns if the "project_duration" field was cleared in this mutation.
func (m *ProjectDetailMutation) ProjectDurationCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldProjectDuration]
	return ok
}

// ResetProjectDuration resets all changes to the "project_duration" field.
func (m *ProjectDetailMutation) ResetProjectDuration() {
	m.project_duration = nil
	delete(m.clearedFields, projectdetail.FieldProjectDuration)
}

// SetTargetAudience sets the "target_audience" field.
func (m *ProjectDetailMutation) SetTargetAudience(s string) {
	m.target_audience = &s
}

// TargetAudience returns the value of the "target_audience" field in the mutation.
func (m *ProjectDetailMutation) TargetAudience() (r string, exists bool) {
	v := m.target_audience
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetAudience returns the old "target_audience" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldTargetAudience(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetAudience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetAudience: %w", err)
	}
	return oldValue.TargetAudience, nil
}

// ClearTargetAudience clears the value of the "target_audience" field.
func (m *ProjectDetailMutation) ClearTargetAudience() {
	m.target_audience = nil
	m.clearedFields[projectdetail.FieldTargetAudience] = struct{}{}
}

// TargetAudienceCleared returns if the "target_audience" field was cleared in this mutation.
func (m *ProjectDetailMutation) TargetAudienceCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldTargetAudience]
	return ok
}

// ResetTargetAudience resets all changes to the "target_audience" field.
func (m *ProjectDetailMutation) ResetTargetAudience() {
	m.target_audience = nil
	delete(m.clearedFields, projectdetail.FieldTargetAudience)
}

// SetPerformanceMetrics sets the "performance_metrics" field.
func (m *ProjectDetailMutation) SetPerformanceMetrics(value map[string]interface{}) {
	m.performance_metrics = &value
}

// PerformanceMetrics returns the value of the "performance_metrics" field in the mutation.
func (m *ProjectDetailMutation) PerformanceMetrics() (r map[string]interface{}, exists bool) {
	v := m.performance_metrics
	if v == nil {
		return
	}
	return *v, true
}

// OldPerformanceMetrics returns the old "performance_metrics" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldPerformanceMetrics(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPerformanceMetrics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPerformanceMetrics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPerformanceMetrics: %w", err)
	}
	return oldValue.PerformanceMetrics, nil
}

// ClearPerformanceMetrics clears the value of the "performance_metrics" field.
func (m *ProjectDetailMutation) ClearPerformanceMetrics() {
	m.performance_metrics = nil
	m.clearedFields[projectdetail.FieldPerformanceMetrics] = struct{}{}
}

// PerformanceMetricsCleared returns if the "performance_metrics" field was cleared in this mutation.
func (m *ProjectDetailMutation) PerformanceMetricsCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldPerformanceMetrics]
	return ok
}

// ResetPerformanceMetrics resets all changes to the "performance_metrics" field.
func (m *ProjectDetailMutation) ResetPerformanceMetrics() {
	m.performance_metrics = nil
	delete(m.clearedFields, projectdetail.FieldPerformanceMetrics)
}

// SetTestingApproach sets the "testing_approach" field.
func (m *ProjectDetailMutation) SetTestingApproach(value map[string]interface{}) {
	m.testing_approach = &value
}

// TestingApproach returns the value of the "testing_approach" field in the mutation.
func (m *ProjectDetailMutation) TestingApproach() (r map[string]interface{}, exists bool) {
	v := m.testing_approach
	if v == nil {
		return
	}
	return *v, true
}

// OldTestingApproach returns the old "testing_approach" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldTestingApproach(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTestingApproach is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTestingApproach requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTestingApproach: %w", err)
	}
	return oldValue.TestingApproach, nil
}

// ClearTestingApproach clears the value of the "testing_approach" field.
func (m *ProjectDetailMutation) ClearTestingApproach() {
	m.testing_approach = nil
	m.clearedFields[projectdetail.FieldTestingApproach] = struct{}{}
}

// TestingApproachCleared returns if the "testing_approach" field was cleared in this mutation.
func (m *ProjectDetailMutation) TestingApproachCleared() bool {
	_, ok := m.clearedFields[projectdetail.FieldTestingApproach]
	return ok
}

// ResetTestingApproach resets all changes to the "testing_approach" field.
func (m *ProjectDetailMutation) ResetTestingApproach() {
	m.testing_approach = nil
	delete(m.clearedFields, projectdetail.FieldTestingApproach)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectDetail entity.
// If the ProjectDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectDetailMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectDetailMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectDetailMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectDetailMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectDetailMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectDetailMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ProjectDetailMutation builder.
func (m *ProjectDetailMutation) Where(ps ...predicate.ProjectDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectDetail).
func (m *ProjectDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectDetailMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.full_description != nil {
		fields = append(fields, projectdetail.FieldFullDescription)
	}
	if m.features != nil {
		fields = append(fields, projectdetail.FieldFeatures)
	}
	if m.key_achievements != nil {
		fields = append(fields, projectdetail.FieldKeyAchievements)
	}
	if m.challenges_faced != nil {
		fields = append(fields, projectdetail.FieldChallengesFaced)
	}
	if m.lessons_learned != nil {
		fields = append(fields, projectdetail.FieldLessonsLearned)
	}
	if m.technical_overview != nil {
		fields = append(fields, projectdetail.FieldTechnicalOverview)
	}
	if m.installation_instructions != nil {
		fields = append(fields, projectdetail.FieldInstallationInstructions)
	}
	if m.usage_instructions != nil {
		fields = append(fields, projectdetail.FieldUsageInstructions)
	}
	if m.api_documentation != nil {
		fields = append(fields, projectdetail.FieldAPIDocumentation)
	}
	if m.deployment_notes != nil {
		fields = append(fields, projectdetail.FieldDeploymentNotes)
	}
	if m.future_enhancements != nil {
		fields = append(fields, projectdetail.FieldFutureEnhancements)
	}
	if m.team_members != nil {
		fields = append(fields, projectdetail.FieldTeamMembers)
	}
	if m.project_duration != nil {
		fields = append(fields, projectdetail.FieldProjectDuration)
	}
	if m.target_audience != nil {
		fields = append(fields, projectdetail.FieldTargetAudience)
	}
	if m.performance_metrics != nil {
		fields = append(fields, projectdetail.FieldPerformanceMetrics)
	}
	if m.testing_approach != nil {
		fields = append(fields, projectdetail.FieldTestingApproach)
	}
	if m.created_at != nil {
		fields = append(fields, projectdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectdetail.FieldFullDescription:
		return m.FullDescription()
	case projectdetail.FieldFeatures:
		return m.Features()
	case projectdetail.FieldKeyAchievements:
		return m.KeyAchievements()
	case projectdetail.FieldChallengesFaced:
		return m.ChallengesFaced()
	case projectdetail.FieldLessonsLearned:
		return m.LessonsLearned()
	case projectdetail.FieldTechnicalOverview:
		return m.TechnicalOverview()
	case projectdetail.FieldInstallationInstructions:
		return m.InstallationInstructions()
	case projectdetail.FieldUsageInstructions:
		return m.UsageInstructions()
	case projectdetail.FieldAPIDocumentation:
		return m.APIDocumentation()
	case projectdetail.FieldDeploymentNotes:
		return m.DeploymentNotes()
	case projectdetail.FieldFutureEnhancements:
		return m.FutureEnhancements()
	case projectdetail.FieldTeamMembers:
		return m.TeamMembers()
	case projectdetail.FieldProjectDuration:
		return m.ProjectDuration()
	case projectdetail.FieldTargetAudience:
		return m.TargetAudience()
	case projectdetail.FieldPerformanceMetrics:
		return m.PerformanceMetrics()
	case projectdetail.FieldTestingApproach:
		return m.TestingApproach()
	case projectdetail.FieldCreatedAt:
		return m.CreatedAt()
	case projectdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectdetail.FieldFullDescription:
		return m.OldFullDescription(ctx)
	case projectdetail.FieldFeatures:
		return m.OldFeatures(ctx)
	case projectdetail.FieldKeyAchievements:
		return m.OldKeyAchievements(ctx)
	case projectdetail.FieldChallengesFaced:
		return m.OldChallengesFaced(ctx)
	case projectdetail.FieldLessonsLearned:
		return m.OldLessonsLearned(ctx)
	case projectdetail.FieldTechnicalOverview:
		return m.OldTechnicalOverview(ctx)
	case projectdetail.FieldInstallationInstructions:
		return m.OldInstallationInstructions(ctx)
	case projectdetail.FieldUsageInstructions:
		return m.OldUsageInstructions(ctx)
	case projectdetail.FieldAPIDocumentation:
		return m.OldAPIDocumentation(ctx)
	case projectdetail.FieldDeploymentNotes:
		return m.OldDeploymentNotes(ctx)
	case projectdetail.FieldFutureEnhancements:
		return m.OldFutureEnhancements(ctx)
	case projectdetail.FieldTeamMembers:
		return m.OldTeamMembers(ctx)
	case projectdetail.FieldProjectDuration:
		return m.OldProjectDuration(ctx)
	case projectdetail.FieldTargetAudience:
		return m.OldTargetAudience(ctx)
	case projectdetail.FieldPerformanceMetrics:
		return m.OldPerformanceMetrics(ctx)
	case projectdetail.FieldTestingApproach:
		return m.OldTestingApproach(ctx)
	case projectdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectdetail.FieldFullDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullDescription(v)
		return nil
	case projectdetail.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case projectdetail.FieldKeyAchievements:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyAchievements(v)
		return nil
	case projectdetail.FieldChallengesFaced:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChallengesFaced(v)
		return nil
	case projectdetail.FieldLessonsLearned:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLessonsLearned(v)
		return nil
	case projectdetail.FieldTechnicalOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnicalOverview(v)
		return nil
	case projectdetail.FieldInstallationInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallationInstructions(v)
		return nil
	case projectdetail.FieldUsageInstructions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageInstructions(v)
		return nil
	case projectdetail.FieldAPIDocumentation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIDocumentation(v)
		return nil
	case projectdetail.FieldDeploymentNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeploymentNotes(v)
		return nil
	case projectdetail.FieldFutureEnhancements:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFutureEnhancements(v)
		return nil
	case projectdetail.FieldTeamMembers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamMembers(v)
		return nil
	case projectdetail.FieldProjectDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectDuration(v)
		return nil
	case projectdetail.FieldTargetAudience:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetAudience(v)
		return nil
	case projectdetail.FieldPerformanceMetrics:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPerformanceMetrics(v)
		return nil
	case projectdetail.FieldTestingApproach:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTestingApproach(v)
		return nil
	case projectdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectDetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectDetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectdetail.FieldFullDescription) {
		fields = append(fields, projectdetail.FieldFullDescription)
	}
	if m.FieldCleared(projectdetail.FieldFeatures) {
		fields = append(fields, projectdetail.FieldFeatures)
	}
	if m.FieldCleared(projectdetail.FieldKeyAchievements) {
		fields = append(fields, projectdetail.FieldKeyAchievements)
	}
	if m.FieldCleared(projectdetail.FieldChallengesFaced) {
		fields = append(fields, projectdetail.FieldChallengesFaced)
	}
	if m.FieldCleared(projectdetail.FieldLessonsLearned) {
		fields = append(fields, projectdetail.FieldLessonsLearned)
	}
	if m.FieldCleared(projectdetail.FieldTechnicalOverview) {
		fields = append(fields, projectdetail.FieldTechnicalOverview)
	}
	if m.FieldCleared(projectdetail.FieldInstallationInstructions) {
		fields = append(fields, projectdetail.FieldInstallationInstructions)
	}
	if m.FieldCleared(projectdetail.FieldUsageInstructions) {
		fields = append(fields, projectdetail.FieldUsageInstructions)
	}
	if m.FieldCleared(projectdetail.FieldAPIDocumentation) {
		fields = append(fields, projectdetail.FieldAPIDocumentation)
	}
	if m.FieldCleared(projectdetail.FieldDeploymentNotes) {
		fields = append(fields, projectdetail.FieldDeploymentNotes)
	}
	if m.FieldCleared(projectdetail.FieldFutureEnhancements) {
		fields = append(fields, projectdetail.FieldFutureEnhancements)
	}
	if m.FieldCleared(projectdetail.FieldTeamMembers) {
		fields = append(fields, projectdetail.FieldTeamMembers)
	}
	if m.FieldCleared(projectdetail.FieldProjectDuration) {
		fields = append(fields, projectdetail.FieldProjectDuration)
	}
	if m.FieldCleared(projectdetail.FieldTargetAudience) {
		fields = append(fields, projectdetail.FieldTargetAudience)
	}
	if m.FieldCleared(projectdetail.FieldPerformanceMetrics) {
		fields = append(fields, projectdetail.FieldPerformanceMetrics)
	}
	if m.FieldCleared(projectdetail.FieldTestingApproach) {
		fields = append(fields, projectdetail.FieldTestingApproach)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectDetailMutation) ClearField(name string) error {
	switch name {
	case projectdetail.FieldFullDescription:
		m.ClearFullDescription()
		return nil
	case projectdetail.FieldFeatures:
		m.ClearFeatures()
		return nil
	case projectdetail.FieldKeyAchievements:
		m.ClearKeyAchievements()
		return nil
	case projectdetail.FieldChallengesFaced:
		m.ClearChallengesFaced()
		return nil
	case projectdetail.FieldLessonsLearned:
		m.ClearLessonsLearned()
		return nil
	case projectdetail.FieldTechnicalOverview:
		m.ClearTechnicalOverview()
		return nil
	case projectdetail.FieldInstallationInstructions:
		m.ClearInstallationInstructions()
		return nil
	case projectdetail.FieldUsageInstructions:
		m.ClearUsageInstructions()
		return nil
	case projectdetail.FieldAPIDocumentation:
		m.ClearAPIDocumentation()
		return nil
	case projectdetail.FieldDeploymentNotes:
		m.ClearDeploymentNotes()
		return nil
	case projectdetail.FieldFutureEnhancements:
		m.ClearFutureEnhancements()
		return nil
	case projectdetail.FieldTeamMembers:
		m.ClearTeamMembers()
		return nil
	case projectdetail.FieldProjectDuration:
		m.ClearProjectDuration()
		return nil
	case projectdetail.FieldTargetAudience:
		m.ClearTargetAudience()
		return nil
	case projectdetail.FieldPerformanceMetrics:
		m.ClearPerformanceMetrics()
		return nil
	case projectdetail.FieldTestingApproach:
		m.ClearTestingApproach()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectDetailMutation) ResetField(name string) error {
	switch name {
	case projectdetail.FieldFullDescription:
		m.ResetFullDescription()
		return nil
	case projectdetail.FieldFeatures:
		m.ResetFeatures()
		return nil
	case projectdetail.FieldKeyAchievements:
		m.ResetKeyAchievements()
		return nil
	case projectdetail.FieldChallengesFaced:
		m.ResetChallengesFaced()
		return nil
	case projectdetail.FieldLessonsLearned:
		m.ResetLessonsLearned()
		return nil
	case projectdetail.FieldTechnicalOverview:
		m.ResetTechnicalOverview()
		return nil
	case projectdetail.FieldInstallationInstructions:
		m.ResetInstallationInstructions()
		return nil
	case projectdetail.FieldUsageInstructions:
		m.ResetUsageInstructions()
		return nil
	case projectdetail.FieldAPIDocumentation:
		m.ResetAPIDocumentation()
		return nil
	case projectdetail.FieldDeploymentNotes:
		m.ResetDeploymentNotes()
		return nil
	case projectdetail.FieldFutureEnhancements:
		m.ResetFutureEnhancements()
		return nil
	case projectdetail.FieldTeamMembers:
		m.ResetTeamMembers()
		return nil
	case projectdetail.FieldProjectDuration:
		m.ResetProjectDuration()
		return nil
	case projectdetail.FieldTargetAudience:
		m.ResetTargetAudience()
		return nil
	case projectdetail.FieldPerformanceMetrics:
		m.ResetPerformanceMetrics()
		return nil
	case projectdetail.FieldTestingApproach:
		m.ResetTestingApproach()
		return nil
	case projectdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, projectdetail.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectdetail.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, projectdetail.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case projectdetail.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectDetailMutation) ClearEdge(name string) error {
	switch name {
	case projectdetail.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectDetailMutation) ResetEdge(name string) error {
	switch name {
	case projectdetail.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectDetail edge %s", name)
}

// ProjectImageMutation represents an operation that mutates the ProjectImage nodes in the graph.
type ProjectImageMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	image_url      *string
	title          *string
	description    *string
	alt_text       *string
	image_type     *projectimage.ImageType
	file_name      *string
	file_size      *int
	addfile_size   *int
	mime_type      *string
	width          *int
	addwidth       *int
	height         *int
	addheight      *int
	is_primary     *bool
	is_public      *bool
	sort_order     *int
	addsort_order  *int
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	project        *uuid.UUID
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*ProjectImage, error)
	predicates     []predicate.ProjectImage
}

var _ ent.Mutation = (*ProjectImageMutation)(nil)

// projectimageOption allows management of the mutation configuration using functional options.
type projectimageOption func(*ProjectImageMutation)

// newProjectImageMutation creates new mutation for the ProjectImage entity.
func newProjectImageMutation(c config, op Op, opts ...projectimageOption) *ProjectImageMutation {
	m := &ProjectImageMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectImageID sets the ID field of the mutation.
func withProjectImageID(id uuid.UUID) projectimageOption {
	return func(m *ProjectImageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectImage
		)
		m.oldValue = func(ctx context.Context) (*ProjectImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectImage sets the old ProjectImage of the mutation.
func withProjectImage(node *ProjectImage) projectimageOption {
	return func(m *ProjectImageMutation) {
		m.oldValue = func(context.Context) (*ProjectImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectImage entities.
func (m *ProjectImageMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectImageMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectImageMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImageURL sets the "image_url" field.
func (m *ProjectImageMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ProjectImageMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ProjectImageMutation) ResetImageURL() {
	m.image_url = nil
}

// SetTitle sets the "title" field.
func (m *ProjectImageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProjectImageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ProjectImageMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[projectimage.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ProjectImageMutation) TitleCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectImageMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, projectimage.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *ProjectImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectImageMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projectimage.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectImageMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectImageMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projectimage.FieldDescription)
}

// SetAltText sets the "alt_text" field.
func (m *ProjectImageMutation) SetAltText(s string) {
	m.alt_text = &s
}

// AltText returns the value of the "alt_text" field in the mutation.
func (m *ProjectImageMutation) AltText() (r string, exists bool) {
	v := m.alt_text
	if v == nil {
		return
	}
	return *v, true
}

// OldAltText returns the old "alt_text" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldAltText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltText: %w", err)
	}
	return oldValue.AltText, nil
}

// ClearAltText clears the value of the "alt_text" field.
func (m *ProjectImageMutation) ClearAltText() {
	m.alt_text = nil
	m.clearedFields[projectimage.FieldAltText] = struct{}{}
}

// AltTextCleared returns if the "alt_text" field was cleared in this mutation.
func (m *ProjectImageMutation) AltTextCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldAltText]
	return ok
}

// ResetAltText resets all changes to the "alt_text" field.
func (m *ProjectImageMutation) ResetAltText() {
	m.alt_text = nil
	delete(m.clearedFields, projectimage.FieldAltText)
}

// SetImageType sets the "image_type" field.
func (m *ProjectImageMutation) SetImageType(pt projectimage.ImageType) {
	m.image_type = &pt
}

// ImageType returns the value of the "image_type" field in the mutation.
func (m *ProjectImageMutation) ImageType() (r projectimage.ImageType, exists bool) {
	v := m.image_type
	if v == nil {
		return
	}
	return *v, true
}

// OldImageType returns the old "image_type" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldImageType(ctx context.Context) (v projectimage.ImageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageType: %w", err)
	}
	return oldValue.ImageType, nil
}

// ResetImageType resets all changes to the "image_type" field.
func (m *ProjectImageMutation) ResetImageType() {
	m.image_type = nil
}

// SetFileName sets the "file_name" field.
func (m *ProjectImageMutation) SetFileName(s string) {
	m.file_name = &s
}

// FileName returns the value of the "file_name" field in the mutation.
func (m *ProjectImageMutation) FileName() (r string, exists bool) {
	v := m.file_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "file_name" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "file_name" field.
func (m *ProjectImageMutation) ClearFileName() {
	m.file_name = nil
	m.clearedFields[projectimage.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "file_name" field was cleared in this mutation.
func (m *ProjectImageMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "file_name" field.
func (m *ProjectImageMutation) ResetFileName() {
	m.file_name = nil
	delete(m.clearedFields, projectimage.FieldFileName)
}

// SetFileSize sets the "file_size" field.
func (m *ProjectImageMutation) SetFileSize(i int) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *ProjectImageMutation) FileSize() (r int, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldFileSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *ProjectImageMutation) AddFileSize(i int) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *ProjectImageMutation) AddedFileSize() (r int, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileSize clears the value of the "file_size" field.
func (m *ProjectImageMutation) ClearFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	m.clearedFields[projectimage.FieldFileSize] = struct{}{}
}

// FileSizeCleared returns if the "file_size" field was cleared in this mutation.
func (m *ProjectImageMutation) FileSizeCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldFileSize]
	return ok
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *ProjectImageMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
	delete(m.clearedFields, projectimage.FieldFileSize)
}

// SetMimeType sets the "mime_type" field.
func (m *ProjectImageMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *ProjectImageMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *ProjectImageMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[projectimage.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *ProjectImageMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *ProjectImageMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, projectimage.FieldMimeType)
}

// SetWidth sets the "width" field.
func (m *ProjectImageMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *ProjectImageMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *ProjectImageMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *ProjectImageMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *ProjectImageMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[projectimage.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *ProjectImageMutation) WidthCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *ProjectImageMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, projectimage.FieldWidth)
}

// SetHeight sets the "height" field.
func (m *ProjectImageMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *ProjectImageMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *ProjectImageMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *ProjectImageMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *ProjectImageMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[projectimage.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *ProjectImageMutation) HeightCleared() bool {
	_, ok := m.clearedFields[projectimage.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *ProjectImageMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, projectimage.FieldHeight)
}

// SetIsPrimary sets the "is_primary" field.
func (m *ProjectImageMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *ProjectImageMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *ProjectImageMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// SetIsPublic sets the "is_public" field.
func (m *ProjectImageMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ProjectImageMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ProjectImageMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *ProjectImageMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProjectImageMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProjectImageMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProjectImageMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProjectImageMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectImage entity.
// If the ProjectImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectImageMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectImageMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectImageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectImageMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectImageMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectImageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ProjectImageMutation builder.
func (m *ProjectImageMutation) Where(ps ...predicate.ProjectImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectImage).
func (m *ProjectImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectImageMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.image_url != nil {
		fields = append(fields, projectimage.FieldImageURL)
	}
	if m.title != nil {
		fields = append(fields, projectimage.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, projectimage.FieldDescription)
	}
	if m.alt_text != nil {
		fields = append(fields, projectimage.FieldAltText)
	}
	if m.image_type != nil {
		fields = append(fields, projectimage.FieldImageType)
	}
	if m.file_name != nil {
		fields = append(fields, projectimage.FieldFileName)
	}
	if m.file_size != nil {
		fields = append(fields, projectimage.FieldFileSize)
	}
	if m.mime_type != nil {
		fields = append(fields, projectimage.FieldMimeType)
	}
	if m.width != nil {
		fields = append(fields, projectimage.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, projectimage.FieldHeight)
	}
	if m.is_primary != nil {
		fields = append(fields, projectimage.FieldIsPrimary)
	}
	if m.is_public != nil {
		fields = append(fields, projectimage.FieldIsPublic)
	}
	if m.sort_order != nil {
		fields = append(fields, projectimage.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, projectimage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projectimage.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectimage.FieldImageURL:
		return m.ImageURL()
	case projectimage.FieldTitle:
		return m.Title()
	case projectimage.FieldDescription:
		return m.Description()
	case projectimage.FieldAltText:
		return m.AltText()
	case projectimage.FieldImageType:
		return m.ImageType()
	case projectimage.FieldFileName:
		return m.FileName()
	case projectimage.FieldFileSize:
		return m.FileSize()
	case projectimage.FieldMimeType:
		return m.MimeType()
	case projectimage.FieldWidth:
		return m.Width()
	case projectimage.FieldHeight:
		return m.Height()
	case projectimage.FieldIsPrimary:
		return m.IsPrimary()
	case projectimage.FieldIsPublic:
		return m.IsPublic()
	case projectimage.FieldSortOrder:
		return m.SortOrder()
	case projectimage.FieldCreatedAt:
		return m.CreatedAt()
	case projectimage.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectimage.FieldImageURL:
		return m.OldImageURL(ctx)
	case projectimage.FieldTitle:
		return m.OldTitle(ctx)
	case projectimage.FieldDescription:
		return m.OldDescription(ctx)
	case projectimage.FieldAltText:
		return m.OldAltText(ctx)
	case projectimage.FieldImageType:
		return m.OldImageType(ctx)
	case projectimage.FieldFileName:
		return m.OldFileName(ctx)
	case projectimage.FieldFileSize:
		return m.OldFileSize(ctx)
	case projectimage.FieldMimeType:
		return m.OldMimeType(ctx)
	case projectimage.FieldWidth:
		return m.OldWidth(ctx)
	case projectimage.FieldHeight:
		return m.OldHeight(ctx)
	case projectimage.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	case projectimage.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case projectimage.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case projectimage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projectimage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectimage.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case projectimage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case projectimage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projectimage.FieldAltText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltText(v)
		return nil
	case projectimage.FieldImageType:
		v, ok := value.(projectimage.ImageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageType(v)
		return nil
	case projectimage.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case projectimage.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case projectimage.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case projectimage.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case projectimage.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case projectimage.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	case projectimage.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case projectimage.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case projectimage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projectimage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectImageMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, projectimage.FieldFileSize)
	}
	if m.addwidth != nil {
		fields = append(fields, projectimage.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, projectimage.FieldHeight)
	}
	if m.addsort_order != nil {
		fields = append(fields, projectimage.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectImageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projectimage.FieldFileSize:
		return m.AddedFileSize()
	case projectimage.FieldWidth:
		return m.AddedWidth()
	case projectimage.FieldHeight:
		return m.AddedHeight()
	case projectimage.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projectimage.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	case projectimage.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case projectimage.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case projectimage.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectimage.FieldTitle) {
		fields = append(fields, projectimage.FieldTitle)
	}
	if m.FieldCleared(projectimage.FieldDescription) {
		fields = append(fields, projectimage.FieldDescription)
	}
	if m.FieldCleared(projectimage.FieldAltText) {
		fields = append(fields, projectimage.FieldAltText)
	}
	if m.FieldCleared(projectimage.FieldFileName) {
		fields = append(fields, projectimage.FieldFileName)
	}
	if m.FieldCleared(projectimage.FieldFileSize) {
		fields = append(fields, projectimage.FieldFileSize)
	}
	if m.FieldCleared(projectimage.FieldMimeType) {
		fields = append(fields, projectimage.FieldMimeType)
	}
	if m.FieldCleared(projectimage.FieldWidth) {
		fields = append(fields, projectimage.FieldWidth)
	}
	if m.FieldCleared(projectimage.FieldHeight) {
		fields = append(fields, projectimage.FieldHeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectImageMutation) ClearField(name string) error {
	switch name {
	case projectimage.FieldTitle:
		m.ClearTitle()
		return nil
	case projectimage.FieldDescription:
		m.ClearDescription()
		return nil
	case projectimage.FieldAltText:
		m.ClearAltText()
		return nil
	case projectimage.FieldFileName:
		m.ClearFileName()
		return nil
	case projectimage.FieldFileSize:
		m.ClearFileSize()
		return nil
	case projectimage.FieldMimeType:
		m.ClearMimeType()
		return nil
	case projectimage.FieldWidth:
		m.ClearWidth()
		return nil
	case projectimage.FieldHeight:
		m.ClearHeight()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectImageMutation) ResetField(name string) error {
	switch name {
	case projectimage.FieldImageURL:
		m.ResetImageURL()
		return nil
	case projectimage.FieldTitle:
		m.ResetTitle()
		return nil
	case projectimage.FieldDescription:
		m.ResetDescription()
		return nil
	case projectimage.FieldAltText:
		m.ResetAltText()
		return nil
	case projectimage.FieldImageType:
		m.ResetImageType()
		return nil
	case projectimage.FieldFileName:
		m.ResetFileName()
		return nil
	case projectimage.FieldFileSize:
		m.ResetFileSize()
		return nil
	case projectimage.FieldMimeType:
		m.ResetMimeType()
		return nil
	case projectimage.FieldWidth:
		m.ResetWidth()
		return nil
	case projectimage.FieldHeight:
		m.ResetHeight()
		return nil
	case projectimage.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	case projectimage.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case projectimage.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case projectimage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projectimage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, projectimage.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectimage.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, projectimage.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectImageMutation) EdgeCleared(name string) bool {
	switch name {
	case projectimage.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectImageMutation) ClearEdge(name string) error {
	switch name {
	case projectimage.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectImageMutation) ResetEdge(name string) error {
	switch name {
	case projectimage.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectImage edge %s", name)
}

// ProjectTechnologyMutation represents an operation that mutates the ProjectTechnology nodes in the graph.
type ProjectTechnologyMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	technology_name   *string
	category          *string
	version           *string
	proficiency_level *string
	description       *string
	icon_url          *string
	documentation_url *string
	sort_order        *int
	addsort_order     *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	project           *uuid.UUID
	clearedproject    bool
	done              bool
	oldValue          func(context.Context) (*ProjectTechnology, error)
	predicates        []predicate.ProjectTechnology
}

var _ ent.Mutation = (*ProjectTechnologyMutation)(nil)

// projecttechnologyOption allows management of the mutation configuration using functional options.
type projecttechnologyOption func(*ProjectTechnologyMutation)

// newProjectTechnologyMutation creates new mutation for the ProjectTechnology entity.
func newProjectTechnologyMutation(c config, op Op, opts ...projecttechnologyOption) *ProjectTechnologyMutation {
	m := &ProjectTechnologyMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectTechnology,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectTechnologyID sets the ID field of the mutation.
func withProjectTechnologyID(id uuid.UUID) projecttechnologyOption {
	return func(m *ProjectTechnologyMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectTechnology
		)
		m.oldValue = func(ctx context.Context) (*ProjectTechnology, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectTechnology.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectTechnology sets the old ProjectTechnology of the mutation.
func withProjectTechnology(node *ProjectTechnology) projecttechnologyOption {
	return func(m *ProjectTechnologyMutation) {
		m.oldValue = func(context.Context) (*ProjectTechnology, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectTechnologyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectTechnologyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectTechnology entities.
func (m *ProjectTechnologyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectTechnologyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectTechnologyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectTechnology.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTechnologyName sets the "technology_name" field.
func (m *ProjectTechnologyMutation) SetTechnologyName(s string) {
	m.technology_name = &s
}

// TechnologyName returns the value of the "technology_name" field in the mutation.
func (m *ProjectTechnologyMutation) TechnologyName() (r string, exists bool) {
	v := m.technology_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnologyName returns the old "technology_name" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldTechnologyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnologyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnologyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnologyName: %w", err)
	}
	return oldValue.TechnologyName, nil
}

// ResetTechnologyName resets all changes to the "technology_name" field.
func (m *ProjectTechnologyMutation) ResetTechnologyName() {
	m.technology_name = nil
}

// SetCategory sets the "category" field.
func (m *ProjectTechnologyMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ProjectTechnologyMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ProjectTechnologyMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[projecttechnology.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ProjectTechnologyMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, projecttechnology.FieldCategory)
}

// SetVersion sets the "version" field.
func (m *ProjectTechnologyMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ProjectTechnologyMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ProjectTechnologyMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[projecttechnology.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) VersionCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ProjectTechnologyMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, projecttechnology.FieldVersion)
}

// SetProficiencyLevel sets the "proficiency_level" field.
func (m *ProjectTechnologyMutation) SetProficiencyLevel(s string) {
	m.proficiency_level = &s
}

// ProficiencyLevel returns the value of the "proficiency_level" field in the mutation.
func (m *ProjectTechnologyMutation) ProficiencyLevel() (r string, exists bool) {
	v := m.proficiency_level
	if v == nil {
		return
	}
	return *v, true
}

// OldProficiencyLevel returns the old "proficiency_level" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldProficiencyLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProficiencyLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProficiencyLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProficiencyLevel: %w", err)
	}
	return oldValue.ProficiencyLevel, nil
}

// ClearProficiencyLevel clears the value of the "proficiency_level" field.
func (m *ProjectTechnologyMutation) ClearProficiencyLevel() {
	m.proficiency_level = nil
	m.clearedFields[projecttechnology.FieldProficiencyLevel] = struct{}{}
}

// ProficiencyLevelCleared returns if the "proficiency_level" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) ProficiencyLevelCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldProficiencyLevel]
	return ok
}

// ResetProficiencyLevel resets all changes to the "proficiency_level" field.
func (m *ProjectTechnologyMutation) ResetProficiencyLevel() {
	m.proficiency_level = nil
	delete(m.clearedFields, projecttechnology.FieldProficiencyLevel)
}

// SetDescription sets the "description" field.
func (m *ProjectTechnologyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectTechnologyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectTechnologyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[projecttechnology.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectTechnologyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, projecttechnology.FieldDescription)
}

// SetIconURL sets the "icon_url" field.
func (m *ProjectTechnologyMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *ProjectTechnologyMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldIconURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *ProjectTechnologyMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[projecttechnology.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *ProjectTechnologyMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, projecttechnology.FieldIconURL)
}

// SetDocumentationURL sets the "documentation_url" field.
func (m *ProjectTechnologyMutation) SetDocumentationURL(s string) {
	m.documentation_url = &s
}

// DocumentationURL returns the value of the "documentation_url" field in the mutation.
func (m *ProjectTechnologyMutation) DocumentationURL() (r string, exists bool) {
	v := m.documentation_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentationURL returns the old "documentation_url" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldDocumentationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentationURL: %w", err)
	}
	return oldValue.DocumentationURL, nil
}

// ClearDocumentationURL clears the value of the "documentation_url" field.
func (m *ProjectTechnologyMutation) ClearDocumentationURL() {
	m.documentation_url = nil
	m.clearedFields[projecttechnology.FieldDocumentationURL] = struct{}{}
}

// DocumentationURLCleared returns if the "documentation_url" field was cleared in this mutation.
func (m *ProjectTechnologyMutation) DocumentationURLCleared() bool {
	_, ok := m.clearedFields[projecttechnology.FieldDocumentationURL]
	return ok
}

// ResetDocumentationURL resets all changes to the "documentation_url" field.
func (m *ProjectTechnologyMutation) ResetDocumentationURL() {
	m.documentation_url = nil
	delete(m.clearedFields, projecttechnology.FieldDocumentationURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *ProjectTechnologyMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ProjectTechnologyMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ProjectTechnologyMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ProjectTechnologyMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ProjectTechnologyMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectTechnologyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectTechnologyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectTechnologyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectTechnologyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectTechnologyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProjectTechnology entity.
// If the ProjectTechnology object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectTechnologyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectTechnologyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectTechnologyMutation) SetProjectID(id uuid.UUID) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectTechnologyMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectTechnologyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectTechnologyMutation) ProjectID() (id uuid.UUID, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectTechnologyMutation) ProjectIDs() (ids []uuid.UUID) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectTechnologyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ProjectTechnologyMutation builder.
func (m *ProjectTechnologyMutation) Where(ps ...predicate.ProjectTechnology) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectTechnologyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectTechnologyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectTechnology, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectTechnologyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectTechnologyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectTechnology).
func (m *ProjectTechnologyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectTechnologyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.technology_name != nil {
		fields = append(fields, projecttechnology.FieldTechnologyName)
	}
	if m.category != nil {
		fields = append(fields, projecttechnology.FieldCategory)
	}
	if m.version != nil {
		fields = append(fields, projecttechnology.FieldVersion)
	}
	if m.proficiency_level != nil {
		fields = append(fields, projecttechnology.FieldProficiencyLevel)
	}
	if m.description != nil {
		fields = append(fields, projecttechnology.FieldDescription)
	}
	if m.icon_url != nil {
		fields = append(fields, projecttechnology.FieldIconURL)
	}
	if m.documentation_url != nil {
		fields = append(fields, projecttechnology.FieldDocumentationURL)
	}
	if m.sort_order != nil {
		fields = append(fields, projecttechnology.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, projecttechnology.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, projecttechnology.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectTechnologyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projecttechnology.FieldTechnologyName:
		return m.TechnologyName()
	case projecttechnology.FieldCategory:
		return m.Category()
	case projecttechnology.FieldVersion:
		return m.Version()
	case projecttechnology.FieldProficiencyLevel:
		return m.ProficiencyLevel()
	case projecttechnology.FieldDescription:
		return m.Description()
	case projecttechnology.FieldIconURL:
		return m.IconURL()
	case projecttechnology.FieldDocumentationURL:
		return m.DocumentationURL()
	case projecttechnology.FieldSortOrder:
		return m.SortOrder()
	case projecttechnology.FieldCreatedAt:
		return m.CreatedAt()
	case projecttechnology.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectTechnologyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projecttechnology.FieldTechnologyName:
		return m.OldTechnologyName(ctx)
	case projecttechnology.FieldCategory:
		return m.OldCategory(ctx)
	case projecttechnology.FieldVersion:
		return m.OldVersion(ctx)
	case projecttechnology.FieldProficiencyLevel:
		return m.OldProficiencyLevel(ctx)
	case projecttechnology.FieldDescription:
		return m.OldDescription(ctx)
	case projecttechnology.FieldIconURL:
		return m.OldIconURL(ctx)
	case projecttechnology.FieldDocumentationURL:
		return m.OldDocumentationURL(ctx)
	case projecttechnology.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case projecttechnology.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case projecttechnology.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectTechnology field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTechnologyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projecttechnology.FieldTechnologyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnologyName(v)
		return nil
	case projecttechnology.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case projecttechnology.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case projecttechnology.FieldProficiencyLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProficiencyLevel(v)
		return nil
	case projecttechnology.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case projecttechnology.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case projecttechnology.FieldDocumentationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentationURL(v)
		return nil
	case projecttechnology.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case projecttechnology.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case projecttechnology.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectTechnologyMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, projecttechnology.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectTechnologyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case projecttechnology.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectTechnologyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case projecttechnology.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectTechnologyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projecttechnology.FieldCategory) {
		fields = append(fields, projecttechnology.FieldCategory)
	}
	if m.FieldCleared(projecttechnology.FieldVersion) {
		fields = append(fields, projecttechnology.FieldVersion)
	}
	if m.FieldCleared(projecttechnology.FieldProficiencyLevel) {
		fields = append(fields, projecttechnology.FieldProficiencyLevel)
	}
	if m.FieldCleared(projecttechnology.FieldDescription) {
		fields = append(fields, projecttechnology.FieldDescription)
	}
	if m.FieldCleared(projecttechnology.FieldIconURL) {
		fields = append(fields, projecttechnology.FieldIconURL)
	}
	if m.FieldCleared(projecttechnology.FieldDocumentationURL) {
		fields = append(fields, projecttechnology.FieldDocumentationURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectTechnologyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectTechnologyMutation) ClearField(name string) error {
	switch name {
	case projecttechnology.FieldCategory:
		m.ClearCategory()
		return nil
	case projecttechnology.FieldVersion:
		m.ClearVersion()
		return nil
	case projecttechnology.FieldProficiencyLevel:
		m.ClearProficiencyLevel()
		return nil
	case projecttechnology.FieldDescription:
		m.ClearDescription()
		return nil
	case projecttechnology.FieldIconURL:
		m.ClearIconURL()
		return nil
	case projecttechnology.FieldDocumentationURL:
		m.ClearDocumentationURL()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectTechnologyMutation) ResetField(name string) error {
	switch name {
	case projecttechnology.FieldTechnologyName:
		m.ResetTechnologyName()
		return nil
	case projecttechnology.FieldCategory:
		m.ResetCategory()
		return nil
	case projecttechnology.FieldVersion:
		m.ResetVersion()
		return nil
	case projecttechnology.FieldProficiencyLevel:
		m.ResetProficiencyLevel()
		return nil
	case projecttechnology.FieldDescription:
		m.ResetDescription()
		return nil
	case projecttechnology.FieldIconURL:
		m.ResetIconURL()
		return nil
	case projecttechnology.FieldDocumentationURL:
		m.ResetDocumentationURL()
		return nil
	case projecttechnology.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case projecttechnology.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case projecttechnology.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectTechnologyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, projecttechnology.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectTechnologyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projecttechnology.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectTechnologyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectTechnologyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectTechnologyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, projecttechnology.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectTechnologyMutation) EdgeCleared(name string) bool {
	switch name {
	case projecttechnology.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectTechnologyMutation) ClearEdge(name string) error {
	switch name {
	case projecttechnology.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectTechnologyMutation) ResetEdge(name string) error {
	switch name {
	case projecttechnology.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectTechnology edge %s", name)
}

// PublicationMutation represents an operation that mutates the Publication nodes in the graph.
type PublicationMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	title             *string
	publication_type  *string
	journal_name      *string
	conference_name   *string
	volume            *string
	issue             *string
	pages             *string
	publication_date  *time.Time
	doi               *string
	isbn              *string
	url               *string
	pdf_url           *string
	citation_count    *int
	addcitation_count *int
	is_peer_reviewed  *bool
	sort_order        *int
	addsort_order     *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*Publication, error)
	predicates        []predicate.Publication
}

var _ ent.Mutation = (*PublicationMutation)(nil)

// publicationOption allows management of the mutation configuration using functional options.
type publicationOption func(*PublicationMutation)

// newPublicationMutation creates new mutation for the Publication entity.
func newPublicationMutation(c config, op Op, opts ...publicationOption) *PublicationMutation {
	m := &PublicationMutation{
		config:        c,
		op:            op,
		typ:           TypePublication,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicationID sets the ID field of the mutation.
func withPublicationID(id uuid.UUID) publicationOption {
	return func(m *PublicationMutation) {
		var (
			err   error
			once  sync.Once
			value *Publication
		)
		m.oldValue = func(ctx context.Context) (*Publication, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Publication.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublication sets the old Publication of the mutation.
func withPublication(node *Publication) publicationOption {
	return func(m *PublicationMutation) {
		m.oldValue = func(context.Context) (*Publication, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Publication entities.
func (m *PublicationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Publication.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *PublicationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PublicationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PublicationMutation) ResetTitle() {
	m.title = nil
}

// SetPublicationType sets the "publication_type" field.
func (m *PublicationMutation) SetPublicationType(s string) {
	m.publication_type = &s
}

// PublicationType returns the value of the "publication_type" field in the mutation.
func (m *PublicationMutation) PublicationType() (r string, exists bool) {
	v := m.publication_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationType returns the old "publication_type" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPublicationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationType: %w", err)
	}
	return oldValue.PublicationType, nil
}

// ResetPublicationType resets all changes to the "publication_type" field.
func (m *PublicationMutation) ResetPublicationType() {
	m.publication_type = nil
}

// SetJournalName sets the "journal_name" field.
func (m *PublicationMutation) SetJournalName(s string) {
	m.journal_name = &s
}

// JournalName returns the value of the "journal_name" field in the mutation.
func (m *PublicationMutation) JournalName() (r string, exists bool) {
	v := m.journal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldJournalName returns the old "journal_name" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldJournalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJournalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJournalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJournalName: %w", err)
	}
	return oldValue.JournalName, nil
}

// ClearJournalName clears the value of the "journal_name" field.
func (m *PublicationMutation) ClearJournalName() {
	m.journal_name = nil
	m.clearedFields[publication.FieldJournalName] = struct{}{}
}

// JournalNameCleared returns if the "journal_name" field was cleared in this mutation.
func (m *PublicationMutation) JournalNameCleared() bool {
	_, ok := m.clearedFields[publication.FieldJournalName]
	return ok
}

// ResetJournalName resets all changes to the "journal_name" field.
func (m *PublicationMutation) ResetJournalName() {
	m.journal_name = nil
	delete(m.clearedFields, publication.FieldJournalName)
}

// SetConferenceName sets the "conference_name" field.
func (m *PublicationMutation) SetConferenceName(s string) {
	m.conference_name = &s
}

// ConferenceName returns the value of the "conference_name" field in the mutation.
func (m *PublicationMutation) ConferenceName() (r string, exists bool) {
	v := m.conference_name
	if v == nil {
		return
	}
	return *v, true
}

// OldConferenceName returns the old "conference_name" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldConferenceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConferenceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConferenceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConferenceName: %w", err)
	}
	return oldValue.ConferenceName, nil
}

// ClearConferenceName clears the value of the "conference_name" field.
func (m *PublicationMutation) ClearConferenceName() {
	m.conference_name = nil
	m.clearedFields[publication.FieldConferenceName] = struct{}{}
}

// ConferenceNameCleared returns if the "conference_name" field was cleared in this mutation.
func (m *PublicationMutation) ConferenceNameCleared() bool {
	_, ok := m.clearedFields[publication.FieldConferenceName]
	return ok
}

// ResetConferenceName resets all changes to the "conference_name" field.
func (m *PublicationMutation) ResetConferenceName() {
	m.conference_name = nil
	delete(m.clearedFields, publication.FieldConferenceName)
}

// SetVolume sets the "volume" field.
func (m *PublicationMutation) SetVolume(s string) {
	m.volume = &s
}

// Volume returns the value of the "volume" field in the mutation.
func (m *PublicationMutation) Volume() (r string, exists bool) {
	v := m.volume
	if v == nil {
		return
	}
	return *v, true
}

// OldVolume returns the old "volume" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldVolume(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolume: %w", err)
	}
	return oldValue.Volume, nil
}

// ClearVolume clears the value of the "volume" field.
func (m *PublicationMutation) ClearVolume() {
	m.volume = nil
	m.clearedFields[publication.FieldVolume] = struct{}{}
}

// VolumeCleared returns if the "volume" field was cleared in this mutation.
func (m *PublicationMutation) VolumeCleared() bool {
	_, ok := m.clearedFields[publication.FieldVolume]
	return ok
}

// ResetVolume resets all changes to the "volume" field.
func (m *PublicationMutation) ResetVolume() {
	m.volume = nil
	delete(m.clearedFields, publication.FieldVolume)
}

// SetIssue sets the "issue" field.
func (m *PublicationMutation) SetIssue(s string) {
	m.issue = &s
}

// Issue returns the value of the "issue" field in the mutation.
func (m *PublicationMutation) Issue() (r string, exists bool) {
	v := m.issue
	if v == nil {
		return
	}
	return *v, true
}

// OldIssue returns the old "issue" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldIssue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssue: %w", err)
	}
	return oldValue.Issue, nil
}

// ClearIssue clears the value of the "issue" field.
func (m *PublicationMutation) ClearIssue() {
	m.issue = nil
	m.clearedFields[publication.FieldIssue] = struct{}{}
}

// IssueCleared returns if the "issue" field was cleared in this mutation.
func (m *PublicationMutation) IssueCleared() bool {
	_, ok := m.clearedFields[publication.FieldIssue]
	return ok
}

// ResetIssue resets all changes to the "issue" field.
func (m *PublicationMutation) ResetIssue() {
	m.issue = nil
	delete(m.clearedFields, publication.FieldIssue)
}

// SetPages sets the "pages" field.
func (m *PublicationMutation) SetPages(s string) {
	m.pages = &s
}

// Pages returns the value of the "pages" field in the mutation.
func (m *PublicationMutation) Pages() (r string, exists bool) {
	v := m.pages
	if v == nil {
		return
	}
	return *v, true
}

// OldPages returns the old "pages" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPages: %w", err)
	}
	return oldValue.Pages, nil
}

// ClearPages clears the value of the "pages" field.
func (m *PublicationMutation) ClearPages() {
	m.pages = nil
	m.clearedFields[publication.FieldPages] = struct{}{}
}

// PagesCleared returns if the "pages" field was cleared in this mutation.
func (m *PublicationMutation) PagesCleared() bool {
	_, ok := m.clearedFields[publication.FieldPages]
	return ok
}

// ResetPages resets all changes to the "pages" field.
func (m *PublicationMutation) ResetPages() {
	m.pages = nil
	delete(m.clearedFields, publication.FieldPages)
}

// SetPublicationDate sets the "publication_date" field.
func (m *PublicationMutation) SetPublicationDate(t time.Time) {
	m.publication_date = &t
}

// PublicationDate returns the value of the "publication_date" field in the mutation.
func (m *PublicationMutation) PublicationDate() (r time.Time, exists bool) {
	v := m.publication_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicationDate returns the old "publication_date" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPublicationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicationDate: %w", err)
	}
	return oldValue.PublicationDate, nil
}

// ClearPublicationDate clears the value of the "publication_date" field.
func (m *PublicationMutation) ClearPublicationDate() {
	m.publication_date = nil
	m.clearedFields[publication.FieldPublicationDate] = struct{}{}
}

// PublicationDateCleared returns if the "publication_date" field was cleared in this mutation.
func (m *PublicationMutation) PublicationDateCleared() bool {
	_, ok := m.clearedFields[publication.FieldPublicationDate]
	return ok
}

// ResetPublicationDate resets all changes to the "publication_date" field.
func (m *PublicationMutation) ResetPublicationDate() {
	m.publication_date = nil
	delete(m.clearedFields, publication.FieldPublicationDate)
}

// SetDoi sets the "doi" field.
func (m *PublicationMutation) SetDoi(s string) {
	m.doi = &s
}

// Doi returns the value of the "doi" field in the mutation.
func (m *PublicationMutation) Doi() (r string, exists bool) {
	v := m.doi
	if v == nil {
		return
	}
	return *v, true
}

// OldDoi returns the old "doi" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldDoi(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoi: %w", err)
	}
	return oldValue.Doi, nil
}

// ClearDoi clears the value of the "doi" field.
func (m *PublicationMutation) ClearDoi() {
	m.doi = nil
	m.clearedFields[publication.FieldDoi] = struct{}{}
}

// DoiCleared returns if the "doi" field was cleared in this mutation.
func (m *PublicationMutation) DoiCleared() bool {
	_, ok := m.clearedFields[publication.FieldDoi]
	return ok
}

// ResetDoi resets all changes to the "doi" field.
func (m *PublicationMutation) ResetDoi() {
	m.doi = nil
	delete(m.clearedFields, publication.FieldDoi)
}

// SetIsbn sets the "isbn" field.
func (m *PublicationMutation) SetIsbn(s string) {
	m.isbn = &s
}

// Isbn returns the value of the "isbn" field in the mutation.
func (m *PublicationMutation) Isbn() (r string, exists bool) {
	v := m.isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldIsbn returns the old "isbn" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsbn: %w", err)
	}
	return oldValue.Isbn, nil
}

// ClearIsbn clears the value of the "isbn" field.
func (m *PublicationMutation) ClearIsbn() {
	m.isbn = nil
	m.clearedFields[publication.FieldIsbn] = struct{}{}
}

// IsbnCleared returns if the "isbn" field was cleared in this mutation.
func (m *PublicationMutation) IsbnCleared() bool {
	_, ok := m.clearedFields[publication.FieldIsbn]
	return ok
}

// ResetIsbn resets all changes to the "isbn" field.
func (m *PublicationMutation) ResetIsbn() {
	m.isbn = nil
	delete(m.clearedFields, publication.FieldIsbn)
}

// SetURL sets the "url" field.
func (m *PublicationMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *PublicationMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *PublicationMutation) ClearURL() {
	m.url = nil
	m.clearedFields[publication.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *PublicationMutation) URLCleared() bool {
	_, ok := m.clearedFields[publication.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *PublicationMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, publication.FieldURL)
}

// SetPdfURL sets the "pdf_url" field.
func (m *PublicationMutation) SetPdfURL(s string) {
	m.pdf_url = &s
}

// PdfURL returns the value of the "pdf_url" field in the mutation.
func (m *PublicationMutation) PdfURL() (r string, exists bool) {
	v := m.pdf_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPdfURL returns the old "pdf_url" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldPdfURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPdfURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPdfURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPdfURL: %w", err)
	}
	return oldValue.PdfURL, nil
}

// ClearPdfURL clears the value of the "pdf_url" field.
func (m *PublicationMutation) ClearPdfURL() {
	m.pdf_url = nil
	m.clearedFields[publication.FieldPdfURL] = struct{}{}
}

// PdfURLCleared returns if the "pdf_url" field was cleared in this mutation.
func (m *PublicationMutation) PdfURLCleared() bool {
	_, ok := m.clearedFields[publication.FieldPdfURL]
	return ok
}

// ResetPdfURL resets all changes to the "pdf_url" field.
func (m *PublicationMutation) ResetPdfURL() {
	m.pdf_url = nil
	delete(m.clearedFields, publication.FieldPdfURL)
}

// SetCitationCount sets the "citation_count" field.
func (m *PublicationMutation) SetCitationCount(i int) {
	m.citation_count = &i
	m.addcitation_count = nil
}

// CitationCount returns the value of the "citation_count" field in the mutation.
func (m *PublicationMutation) CitationCount() (r int, exists bool) {
	v := m.citation_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCitationCount returns the old "citation_count" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCitationCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCitationCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCitationCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitationCount: %w", err)
	}
	return oldValue.CitationCount, nil
}

// AddCitationCount adds i to the "citation_count" field.
func (m *PublicationMutation) AddCitationCount(i int) {
	if m.addcitation_count != nil {
		*m.addcitation_count += i
	} else {
		m.addcitation_count = &i
	}
}

// AddedCitationCount returns the value that was added to the "citation_count" field in this mutation.
func (m *PublicationMutation) AddedCitationCount() (r int, exists bool) {
	v := m.addcitation_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCitationCount resets all changes to the "citation_count" field.
func (m *PublicationMutation) ResetCitationCount() {
	m.citation_count = nil
	m.addcitation_count = nil
}

// SetIsPeerReviewed sets the "is_peer_reviewed" field.
func (m *PublicationMutation) SetIsPeerReviewed(b bool) {
	m.is_peer_reviewed = &b
}

// IsPeerReviewed returns the value of the "is_peer_reviewed" field in the mutation.
func (m *PublicationMutation) IsPeerReviewed() (r bool, exists bool) {
	v := m.is_peer_reviewed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPeerReviewed returns the old "is_peer_reviewed" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldIsPeerReviewed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPeerReviewed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPeerReviewed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPeerReviewed: %w", err)
	}
	return oldValue.IsPeerReviewed, nil
}

// ResetIsPeerReviewed resets all changes to the "is_peer_reviewed" field.
func (m *PublicationMutation) ResetIsPeerReviewed() {
	m.is_peer_reviewed = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *PublicationMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *PublicationMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *PublicationMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *PublicationMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *PublicationMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PublicationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PublicationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PublicationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PublicationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PublicationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Publication entity.
// If the Publication object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PublicationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PublicationMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PublicationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PublicationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PublicationMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PublicationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PublicationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PublicationMutation builder.
func (m *PublicationMutation) Where(ps ...predicate.Publication) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Publication, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Publication).
func (m *PublicationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicationMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.title != nil {
		fields = append(fields, publication.FieldTitle)
	}
	if m.publication_type != nil {
		fields = append(fields, publication.FieldPublicationType)
	}
	if m.journal_name != nil {
		fields = append(fields, publication.FieldJournalName)
	}
	if m.conference_name != nil {
		fields = append(fields, publication.FieldConferenceName)
	}
	if m.volume != nil {
		fields = append(fields, publication.FieldVolume)
	}
	if m.issue != nil {
		fields = append(fields, publication.FieldIssue)
	}
	if m.pages != nil {
		fields = append(fields, publication.FieldPages)
	}
	if m.publication_date != nil {
		fields = append(fields, publication.FieldPublicationDate)
	}
	if m.doi != nil {
		fields = append(fields, publication.FieldDoi)
	}
	if m.isbn != nil {
		fields = append(fields, publication.FieldIsbn)
	}
	if m.url != nil {
		fields = append(fields, publication.FieldURL)
	}
	if m.pdf_url != nil {
		fields = append(fields, publication.FieldPdfURL)
	}
	if m.citation_count != nil {
		fields = append(fields, publication.FieldCitationCount)
	}
	if m.is_peer_reviewed != nil {
		fields = append(fields, publication.FieldIsPeerReviewed)
	}
	if m.sort_order != nil {
		fields = append(fields, publication.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, publication.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, publication.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publication.FieldTitle:
		return m.Title()
	case publication.FieldPublicationType:
		return m.PublicationType()
	case publication.FieldJournalName:
		return m.JournalName()
	case publication.FieldConferenceName:
		return m.ConferenceName()
	case publication.FieldVolume:
		return m.Volume()
	case publication.FieldIssue:
		return m.Issue()
	case publication.FieldPages:
		return m.Pages()
	case publication.FieldPublicationDate:
		return m.PublicationDate()
	case publication.FieldDoi:
		return m.Doi()
	case publication.FieldIsbn:
		return m.Isbn()
	case publication.FieldURL:
		return m.URL()
	case publication.FieldPdfURL:
		return m.PdfURL()
	case publication.FieldCitationCount:
		return m.CitationCount()
	case publication.FieldIsPeerReviewed:
		return m.IsPeerReviewed()
	case publication.FieldSortOrder:
		return m.SortOrder()
	case publication.FieldCreatedAt:
		return m.CreatedAt()
	case publication.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publication.FieldTitle:
		return m.OldTitle(ctx)
	case publication.FieldPublicationType:
		return m.OldPublicationType(ctx)
	case publication.FieldJournalName:
		return m.OldJournalName(ctx)
	case publication.FieldConferenceName:
		return m.OldConferenceName(ctx)
	case publication.FieldVolume:
		return m.OldVolume(ctx)
	case publication.FieldIssue:
		return m.OldIssue(ctx)
	case publication.FieldPages:
		return m.OldPages(ctx)
	case publication.FieldPublicationDate:
		return m.OldPublicationDate(ctx)
	case publication.FieldDoi:
		return m.OldDoi(ctx)
	case publication.FieldIsbn:
		return m.OldIsbn(ctx)
	case publication.FieldURL:
		return m.OldURL(ctx)
	case publication.FieldPdfURL:
		return m.OldPdfURL(ctx)
	case publication.FieldCitationCount:
		return m.OldCitationCount(ctx)
	case publication.FieldIsPeerReviewed:
		return m.OldIsPeerReviewed(ctx)
	case publication.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case publication.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case publication.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Publication field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publication.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case publication.FieldPublicationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationType(v)
		return nil
	case publication.FieldJournalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJournalName(v)
		return nil
	case publication.FieldConferenceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConferenceName(v)
		return nil
	case publication.FieldVolume:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolume(v)
		return nil
	case publication.FieldIssue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssue(v)
		return nil
	case publication.FieldPages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPages(v)
		return nil
	case publication.FieldPublicationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicationDate(v)
		return nil
	case publication.FieldDoi:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoi(v)
		return nil
	case publication.FieldIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsbn(v)
		return nil
	case publication.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case publication.FieldPdfURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPdfURL(v)
		return nil
	case publication.FieldCitationCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitationCount(v)
		return nil
	case publication.FieldIsPeerReviewed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPeerReviewed(v)
		return nil
	case publication.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case publication.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case publication.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicationMutation) AddedFields() []string {
	var fields []string
	if m.addcitation_count != nil {
		fields = append(fields, publication.FieldCitationCount)
	}
	if m.addsort_order != nil {
		fields = append(fields, publication.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case publication.FieldCitationCount:
		return m.AddedCitationCount()
	case publication.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case publication.FieldCitationCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCitationCount(v)
		return nil
	case publication.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Publication numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(publication.FieldJournalName) {
		fields = append(fields, publication.FieldJournalName)
	}
	if m.FieldCleared(publication.FieldConferenceName) {
		fields = append(fields, publication.FieldConferenceName)
	}
	if m.FieldCleared(publication.FieldVolume) {
		fields = append(fields, publication.FieldVolume)
	}
	if m.FieldCleared(publication.FieldIssue) {
		fields = append(fields, publication.FieldIssue)
	}
	if m.FieldCleared(publication.FieldPages) {
		fields = append(fields, publication.FieldPages)
	}
	if m.FieldCleared(publication.FieldPublicationDate) {
		fields = append(fields, publication.FieldPublicationDate)
	}
	if m.FieldCleared(publication.FieldDoi) {
		fields = append(fields, publication.FieldDoi)
	}
	if m.FieldCleared(publication.FieldIsbn) {
		fields = append(fields, publication.FieldIsbn)
	}
	if m.FieldCleared(publication.FieldURL) {
		fields = append(fields, publication.FieldURL)
	}
	if m.FieldCleared(publication.FieldPdfURL) {
		fields = append(fields, publication.FieldPdfURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicationMutation) ClearField(name string) error {
	switch name {
	case publication.FieldJournalName:
		m.ClearJournalName()
		return nil
	case publication.FieldConferenceName:
		m.ClearConferenceName()
		return nil
	case publication.FieldVolume:
		m.ClearVolume()
		return nil
	case publication.FieldIssue:
		m.ClearIssue()
		return nil
	case publication.FieldPages:
		m.ClearPages()
		return nil
	case publication.FieldPublicationDate:
		m.ClearPublicationDate()
		return nil
	case publication.FieldDoi:
		m.ClearDoi()
		return nil
	case publication.FieldIsbn:
		m.ClearIsbn()
		return nil
	case publication.FieldURL:
		m.ClearURL()
		return nil
	case publication.FieldPdfURL:
		m.ClearPdfURL()
		return nil
	}
	return fmt.Errorf("unknown Publication nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicationMutation) ResetField(name string) error {
	switch name {
	case publication.FieldTitle:
		m.ResetTitle()
		return nil
	case publication.FieldPublicationType:
		m.ResetPublicationType()
		return nil
	case publication.FieldJournalName:
		m.ResetJournalName()
		return nil
	case publication.FieldConferenceName:
		m.ResetConferenceName()
		return nil
	case publication.FieldVolume:
		m.ResetVolume()
		return nil
	case publication.FieldIssue:
		m.ResetIssue()
		return nil
	case publication.FieldPages:
		m.ResetPages()
		return nil
	case publication.FieldPublicationDate:
		m.ResetPublicationDate()
		return nil
	case publication.FieldDoi:
		m.ResetDoi()
		return nil
	case publication.FieldIsbn:
		m.ResetIsbn()
		return nil
	case publication.FieldURL:
		m.ResetURL()
		return nil
	case publication.FieldPdfURL:
		m.ResetPdfURL()
		return nil
	case publication.FieldCitationCount:
		m.ResetCitationCount()
		return nil
	case publication.FieldIsPeerReviewed:
		m.ResetIsPeerReviewed()
		return nil
	case publication.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case publication.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case publication.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Publication field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, publication.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publication.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, publication.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicationMutation) EdgeCleared(name string) bool {
	switch name {
	case publication.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicationMutation) ClearEdge(name string) error {
	switch name {
	case publication.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Publication unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicationMutation) ResetEdge(name string) error {
	switch name {
	case publication.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Publication edge %s", name)
}

// ResearchProjectMutation represents an operation that mutates the ResearchProject nodes in the graph.
type ResearchProjectMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	title             *string
	start_date        *time.Time
	end_date          *time.Time
	is_ongoing        *bool
	location          *string
	research_type     *string
	funding_source    *string
	funding_amount    *float64
	addfunding_amount *float64
	sort_order        *int
	addsort_order     *int
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*ResearchProject, error)
	predicates        []predicate.ResearchProject
}

var _ ent.Mutation = (*ResearchProjectMutation)(nil)

// researchprojectOption allows management of the mutation configuration using functional options.
type researchprojectOption func(*ResearchProjectMutation)

// newResearchProjectMutation creates new mutation for the ResearchProject entity.
func newResearchProjectMutation(c config, op Op, opts ...researchprojectOption) *ResearchProjectMutation {
	m := &ResearchProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeResearchProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResearchProjectID sets the ID field of the mutation.
func withResearchProjectID(id uuid.UUID) researchprojectOption {
	return func(m *ResearchProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *ResearchProject
		)
		m.oldValue = func(ctx context.Context) (*ResearchProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResearchProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResearchProject sets the old ResearchProject of the mutation.
func withResearchProject(node *ResearchProject) researchprojectOption {
	return func(m *ResearchProjectMutation) {
		m.oldValue = func(context.Context) (*ResearchProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResearchProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResearchProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ResearchProject entities.
func (m *ResearchProjectMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResearchProjectMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResearchProjectMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResearchProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ResearchProjectMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ResearchProjectMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ResearchProjectMutation) ResetTitle() {
	m.title = nil
}

// SetStartDate sets the "start_date" field.
func (m *ResearchProjectMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ResearchProjectMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *ResearchProjectMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[researchproject.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *ResearchProjectMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ResearchProjectMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, researchproject.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *ResearchProjectMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ResearchProjectMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ResearchProjectMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[researchproject.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ResearchProjectMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ResearchProjectMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, researchproject.FieldEndDate)
}

// SetIsOngoing sets the "is_ongoing" field.
func (m *ResearchProjectMutation) SetIsOngoing(b bool) {
	m.is_ongoing = &b
}

// IsOngoing returns the value of the "is_ongoing" field in the mutation.
func (m *ResearchProjectMutation) IsOngoing() (r bool, exists bool) {
	v := m.is_ongoing
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOngoing returns the old "is_ongoing" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldIsOngoing(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOngoing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOngoing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOngoing: %w", err)
	}
	return oldValue.IsOngoing, nil
}

// ResetIsOngoing resets all changes to the "is_ongoing" field.
func (m *ResearchProjectMutation) ResetIsOngoing() {
	m.is_ongoing = nil
}

// SetLocation sets the "location" field.
func (m *ResearchProjectMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *ResearchProjectMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *ResearchProjectMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[researchproject.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *ResearchProjectMutation) LocationCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *ResearchProjectMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, researchproject.FieldLocation)
}

// SetResearchType sets the "research_type" field.
func (m *ResearchProjectMutation) SetResearchType(s string) {
	m.research_type = &s
}

// ResearchType returns the value of the "research_type" field in the mutation.
func (m *ResearchProjectMutation) ResearchType() (r string, exists bool) {
	v := m.research_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResearchType returns the old "research_type" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldResearchType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResearchType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResearchType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResearchType: %w", err)
	}
	return oldValue.ResearchType, nil
}

// ClearResearchType clears the value of the "research_type" field.
func (m *ResearchProjectMutation) ClearResearchType() {
	m.research_type = nil
	m.clearedFields[researchproject.FieldResearchType] = struct{}{}
}

// ResearchTypeCleared returns if the "research_type" field was cleared in this mutation.
func (m *ResearchProjectMutation) ResearchTypeCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldResearchType]
	return ok
}

// ResetResearchType resets all changes to the "research_type" field.
func (m *ResearchProjectMutation) ResetResearchType() {
	m.research_type = nil
	delete(m.clearedFields, researchproject.FieldResearchType)
}

// SetFundingSource sets the "funding_source" field.
func (m *ResearchProjectMutation) SetFundingSource(s string) {
	m.funding_source = &s
}

// FundingSource returns the value of the "funding_source" field in the mutation.
func (m *ResearchProjectMutation) FundingSource() (r string, exists bool) {
	v := m.funding_source
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingSource returns the old "funding_source" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldFundingSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingSource: %w", err)
	}
	return oldValue.FundingSource, nil
}

// ClearFundingSource clears the value of the "funding_source" field.
func (m *ResearchProjectMutation) ClearFundingSource() {
	m.funding_source = nil
	m.clearedFields[researchproject.FieldFundingSource] = struct{}{}
}

// FundingSourceCleared returns if the "funding_source" field was cleared in this mutation.
func (m *ResearchProjectMutation) FundingSourceCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldFundingSource]
	return ok
}

// ResetFundingSource resets all changes to the "funding_source" field.
func (m *ResearchProjectMutation) ResetFundingSource() {
	m.funding_source = nil
	delete(m.clearedFields, researchproject.FieldFundingSource)
}

// SetFundingAmount sets the "funding_amount" field.
func (m *ResearchProjectMutation) SetFundingAmount(f float64) {
	m.funding_amount = &f
	m.addfunding_amount = nil
}

// FundingAmount returns the value of the "funding_amount" field in the mutation.
func (m *ResearchProjectMutation) FundingAmount() (r float64, exists bool) {
	v := m.funding_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFundingAmount returns the old "funding_amount" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldFundingAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFundingAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFundingAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundingAmount: %w", err)
	}
	return oldValue.FundingAmount, nil
}

// AddFundingAmount adds f to the "funding_amount" field.
func (m *ResearchProjectMutation) AddFundingAmount(f float64) {
	if m.addfunding_amount != nil {
		*m.addfunding_amount += f
	} else {
		m.addfunding_amount = &f
	}
}

// AddedFundingAmount returns the value that was added to the "funding_amount" field in this mutation.
func (m *ResearchProjectMutation) AddedFundingAmount() (r float64, exists bool) {
	v := m.addfunding_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFundingAmount clears the value of the "funding_amount" field.
func (m *ResearchProjectMutation) ClearFundingAmount() {
	m.funding_amount = nil
	m.addfunding_amount = nil
	m.clearedFields[researchproject.FieldFundingAmount] = struct{}{}
}

// FundingAmountCleared returns if the "funding_amount" field was cleared in this mutation.
func (m *ResearchProjectMutation) FundingAmountCleared() bool {
	_, ok := m.clearedFields[researchproject.FieldFundingAmount]
	return ok
}

// ResetFundingAmount resets all changes to the "funding_amount" field.
func (m *ResearchProjectMutation) ResetFundingAmount() {
	m.funding_amount = nil
	m.addfunding_amount = nil
	delete(m.clearedFields, researchproject.FieldFundingAmount)
}

// SetSortOrder sets the "sort_order" field.
func (m *ResearchProjectMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ResearchProjectMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ResearchProjectMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ResearchProjectMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ResearchProjectMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResearchProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResearchProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResearchProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResearchProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResearchProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResearchProject entity.
// If the ResearchProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResearchProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResearchProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ResearchProjectMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ResearchProjectMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ResearchProjectMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ResearchProjectMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ResearchProjectMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ResearchProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ResearchProjectMutation builder.
func (m *ResearchProjectMutation) Where(ps ...predicate.ResearchProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResearchProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResearchProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResearchProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResearchProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResearchProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResearchProject).
func (m *ResearchProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResearchProjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, researchproject.FieldTitle)
	}
	if m.start_date != nil {
		fields = append(fields, researchproject.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, researchproject.FieldEndDate)
	}
	if m.is_ongoing != nil {
		fields = append(fields, researchproject.FieldIsOngoing)
	}
	if m.location != nil {
		fields = append(fields, researchproject.FieldLocation)
	}
	if m.research_type != nil {
		fields = append(fields, researchproject.FieldResearchType)
	}
	if m.funding_source != nil {
		fields = append(fields, researchproject.FieldFundingSource)
	}
	if m.funding_amount != nil {
		fields = append(fields, researchproject.FieldFundingAmount)
	}
	if m.sort_order != nil {
		fields = append(fields, researchproject.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, researchproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, researchproject.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResearchProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case researchproject.FieldTitle:
		return m.Title()
	case researchproject.FieldStartDate:
		return m.StartDate()
	case researchproject.FieldEndDate:
		return m.EndDate()
	case researchproject.FieldIsOngoing:
		return m.IsOngoing()
	case researchproject.FieldLocation:
		return m.Location()
	case researchproject.FieldResearchType:
		return m.ResearchType()
	case researchproject.FieldFundingSource:
		return m.FundingSource()
	case researchproject.FieldFundingAmount:
		return m.FundingAmount()
	case researchproject.FieldSortOrder:
		return m.SortOrder()
	case researchproject.FieldCreatedAt:
		return m.CreatedAt()
	case researchproject.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResearchProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case researchproject.FieldTitle:
		return m.OldTitle(ctx)
	case researchproject.FieldStartDate:
		return m.OldStartDate(ctx)
	case researchproject.FieldEndDate:
		return m.OldEndDate(ctx)
	case researchproject.FieldIsOngoing:
		return m.OldIsOngoing(ctx)
	case researchproject.FieldLocation:
		return m.OldLocation(ctx)
	case researchproject.FieldResearchType:
		return m.OldResearchType(ctx)
	case researchproject.FieldFundingSource:
		return m.OldFundingSource(ctx)
	case researchproject.FieldFundingAmount:
		return m.OldFundingAmount(ctx)
	case researchproject.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case researchproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case researchproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResearchProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case researchproject.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case researchproject.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case researchproject.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case researchproject.FieldIsOngoing:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOngoing(v)
		return nil
	case researchproject.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case researchproject.FieldResearchType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResearchType(v)
		return nil
	case researchproject.FieldFundingSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingSource(v)
		return nil
	case researchproject.FieldFundingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundingAmount(v)
		return nil
	case researchproject.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case researchproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case researchproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResearchProjectMutation) AddedFields() []string {
	var fields []string
	if m.addfunding_amount != nil {
		fields = append(fields, researchproject.FieldFundingAmount)
	}
	if m.addsort_order != nil {
		fields = append(fields, researchproject.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResearchProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case researchproject.FieldFundingAmount:
		return m.AddedFundingAmount()
	case researchproject.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResearchProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case researchproject.FieldFundingAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFundingAmount(v)
		return nil
	case researchproject.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown ResearchProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResearchProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(researchproject.FieldStartDate) {
		fields = append(fields, researchproject.FieldStartDate)
	}
	if m.FieldCleared(researchproject.FieldEndDate) {
		fields = append(fields, researchproject.FieldEndDate)
	}
	if m.FieldCleared(researchproject.FieldLocation) {
		fields = append(fields, researchproject.FieldLocation)
	}
	if m.FieldCleared(researchproject.FieldResearchType) {
		fields = append(fields, researchproject.FieldResearchType)
	}
	if m.FieldCleared(researchproject.FieldFundingSource) {
		fields = append(fields, researchproject.FieldFundingSource)
	}
	if m.FieldCleared(researchproject.FieldFundingAmount) {
		fields = append(fields, researchproject.FieldFundingAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResearchProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResearchProjectMutation) ClearField(name string) error {
	switch name {
	case researchproject.FieldStartDate:
		m.ClearStartDate()
		return nil
	case researchproject.FieldEndDate:
		m.ClearEndDate()
		return nil
	case researchproject.FieldLocation:
		m.ClearLocation()
		return nil
	case researchproject.FieldResearchType:
		m.ClearResearchType()
		return nil
	case researchproject.FieldFundingSource:
		m.ClearFundingSource()
		return nil
	case researchproject.FieldFundingAmount:
		m.ClearFundingAmount()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResearchProjectMutation) ResetField(name string) error {
	switch name {
	case researchproject.FieldTitle:
		m.ResetTitle()
		return nil
	case researchproject.FieldStartDate:
		m.ResetStartDate()
		return nil
	case researchproject.FieldEndDate:
		m.ResetEndDate()
		return nil
	case researchproject.FieldIsOngoing:
		m.ResetIsOngoing()
		return nil
	case researchproject.FieldLocation:
		m.ResetLocation()
		return nil
	case researchproject.FieldResearchType:
		m.ResetResearchType()
		return nil
	case researchproject.FieldFundingSource:
		m.ResetFundingSource()
		return nil
	case researchproject.FieldFundingAmount:
		m.ResetFundingAmount()
		return nil
	case researchproject.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case researchproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case researchproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResearchProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, researchproject.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResearchProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case researchproject.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResearchProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResearchProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResearchProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, researchproject.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResearchProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case researchproject.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResearchProjectMutation) ClearEdge(name string) error {
	switch name {
	case researchproject.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResearchProjectMutation) ResetEdge(name string) error {
	switch name {
	case researchproject.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ResearchProject edge %s", name)
}

// SocialLinkMutation represents an operation that mutates the SocialLink nodes in the graph.
type SocialLinkMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	platform      *string
	url           *string
	username      *string
	display_name  *string
	is_public     *bool
	_order        *int
	add_order     *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*SocialLink, error)
	predicates    []predicate.SocialLink
}

var _ ent.Mutation = (*SocialLinkMutation)(nil)

// sociallinkOption allows management of the mutation configuration using functional options.
type sociallinkOption func(*SocialLinkMutation)

// newSocialLinkMutation creates new mutation for the SocialLink entity.
func newSocialLinkMutation(c config, op Op, opts ...sociallinkOption) *SocialLinkMutation {
	m := &SocialLinkMutation{
		config:        c,
		op:            op,
		typ:           TypeSocialLink,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSocialLinkID sets the ID field of the mutation.
func withSocialLinkID(id uuid.UUID) sociallinkOption {
	return func(m *SocialLinkMutation) {
		var (
			err   error
			once  sync.Once
			value *SocialLink
		)
		m.oldValue = func(ctx context.Context) (*SocialLink, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SocialLink.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSocialLink sets the old SocialLink of the mutation.
func withSocialLink(node *SocialLink) sociallinkOption {
	return func(m *SocialLinkMutation) {
		m.oldValue = func(context.Context) (*SocialLink, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SocialLinkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SocialLinkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SocialLink entities.
func (m *SocialLinkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SocialLinkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SocialLinkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SocialLink.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *SocialLinkMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *SocialLinkMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *SocialLinkMutation) ResetPlatform() {
	m.platform = nil
}

// SetURL sets the "url" field.
func (m *SocialLinkMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SocialLinkMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *SocialLinkMutation) ResetURL() {
	m.url = nil
}

// SetUsername sets the "username" field.
func (m *SocialLinkMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SocialLinkMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *SocialLinkMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[sociallink.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *SocialLinkMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[sociallink.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *SocialLinkMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, sociallink.FieldUsername)
}

// SetDisplayName sets the "display_name" field.
func (m *SocialLinkMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *SocialLinkMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ClearDisplayName clears the value of the "display_name" field.
func (m *SocialLinkMutation) ClearDisplayName() {
	m.display_name = nil
	m.clearedFields[sociallink.FieldDisplayName] = struct{}{}
}

// DisplayNameCleared returns if the "display_name" field was cleared in this mutation.
func (m *SocialLinkMutation) DisplayNameCleared() bool {
	_, ok := m.clearedFields[sociallink.FieldDisplayName]
	return ok
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *SocialLinkMutation) ResetDisplayName() {
	m.display_name = nil
	delete(m.clearedFields, sociallink.FieldDisplayName)
}

// SetIsPublic sets the "is_public" field.
func (m *SocialLinkMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *SocialLinkMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *SocialLinkMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetOrder sets the "order" field.
func (m *SocialLinkMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *SocialLinkMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *SocialLinkMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *SocialLinkMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *SocialLinkMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SocialLinkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SocialLinkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SocialLinkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SocialLinkMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SocialLinkMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SocialLink entity.
// If the SocialLink object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SocialLinkMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SocialLinkMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SocialLinkMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SocialLinkMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SocialLinkMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SocialLinkMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SocialLinkMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SocialLinkMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SocialLinkMutation builder.
func (m *SocialLinkMutation) Where(ps ...predicate.SocialLink) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SocialLinkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SocialLinkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SocialLink, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SocialLinkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SocialLinkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SocialLink).
func (m *SocialLinkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SocialLinkMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.platform != nil {
		fields = append(fields, sociallink.FieldPlatform)
	}
	if m.url != nil {
		fields = append(fields, sociallink.FieldURL)
	}
	if m.username != nil {
		fields = append(fields, sociallink.FieldUsername)
	}
	if m.display_name != nil {
		fields = append(fields, sociallink.FieldDisplayName)
	}
	if m.is_public != nil {
		fields = append(fields, sociallink.FieldIsPublic)
	}
	if m._order != nil {
		fields = append(fields, sociallink.FieldOrder)
	}
	if m.created_at != nil {
		fields = append(fields, sociallink.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sociallink.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SocialLinkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sociallink.FieldPlatform:
		return m.Platform()
	case sociallink.FieldURL:
		return m.URL()
	case sociallink.FieldUsername:
		return m.Username()
	case sociallink.FieldDisplayName:
		return m.DisplayName()
	case sociallink.FieldIsPublic:
		return m.IsPublic()
	case sociallink.FieldOrder:
		return m.Order()
	case sociallink.FieldCreatedAt:
		return m.CreatedAt()
	case sociallink.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SocialLinkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sociallink.FieldPlatform:
		return m.OldPlatform(ctx)
	case sociallink.FieldURL:
		return m.OldURL(ctx)
	case sociallink.FieldUsername:
		return m.OldUsername(ctx)
	case sociallink.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case sociallink.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case sociallink.FieldOrder:
		return m.OldOrder(ctx)
	case sociallink.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sociallink.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SocialLink field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SocialLinkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sociallink.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case sociallink.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case sociallink.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case sociallink.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case sociallink.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case sociallink.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	case sociallink.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sociallink.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SocialLink field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SocialLinkMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, sociallink.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SocialLinkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sociallink.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SocialLinkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sociallink.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown SocialLink numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SocialLinkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sociallink.FieldUsername) {
		fields = append(fields, sociallink.FieldUsername)
	}
	if m.FieldCleared(sociallink.FieldDisplayName) {
		fields = append(fields, sociallink.FieldDisplayName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SocialLinkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SocialLinkMutation) ClearField(name string) error {
	switch name {
	case sociallink.FieldUsername:
		m.ClearUsername()
		return nil
	case sociallink.FieldDisplayName:
		m.ClearDisplayName()
		return nil
	}
	return fmt.Errorf("unknown SocialLink nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SocialLinkMutation) ResetField(name string) error {
	switch name {
	case sociallink.FieldPlatform:
		m.ResetPlatform()
		return nil
	case sociallink.FieldURL:
		m.ResetURL()
		return nil
	case sociallink.FieldUsername:
		m.ResetUsername()
		return nil
	case sociallink.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case sociallink.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case sociallink.FieldOrder:
		m.ResetOrder()
		return nil
	case sociallink.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sociallink.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SocialLink field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SocialLinkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, sociallink.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SocialLinkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sociallink.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SocialLinkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SocialLinkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SocialLinkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, sociallink.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SocialLinkMutation) EdgeCleared(name string) bool {
	switch name {
	case sociallink.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SocialLinkMutation) ClearEdge(name string) error {
	switch name {
	case sociallink.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SocialLink unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SocialLinkMutation) ResetEdge(name string) error {
	switch name {
	case sociallink.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SocialLink edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	username                 *string
	email                    *string
	password_hash            *string
	first_name               *string
	last_name                *string
	avatar_url               *string
	bio                      *string
	is_active                *bool
	is_admin                 *bool
	last_login_at            *time.Time
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	personal_info            map[uuid.UUID]struct{}
	removedpersonal_info     map[uuid.UUID]struct{}
	clearedpersonal_info     bool
	social_links             map[uuid.UUID]struct{}
	removedsocial_links      map[uuid.UUID]struct{}
	clearedsocial_links      bool
	education                map[uuid.UUID]struct{}
	removededucation         map[uuid.UUID]struct{}
	clearededucation         bool
	work_experience          map[uuid.UUID]struct{}
	removedwork_experience   map[uuid.UUID]struct{}
	clearedwork_experience   bool
	projects                 map[uuid.UUID]struct{}
	removedprojects          map[uuid.UUID]struct{}
	clearedprojects          bool
	blog_posts               map[uuid.UUID]struct{}
	removedblog_posts        map[uuid.UUID]struct{}
	clearedblog_posts        bool
	blog_series              map[uuid.UUID]struct{}
	removedblog_series       map[uuid.UUID]struct{}
	clearedblog_series       bool
	ideas                    map[uuid.UUID]struct{}
	removedideas             map[uuid.UUID]struct{}
	clearedideas             bool
	research_projects        map[uuid.UUID]struct{}
	removedresearch_projects map[uuid.UUID]struct{}
	clearedresearch_projects bool
	publications             map[uuid.UUID]struct{}
	removedpublications      map[uuid.UUID]struct{}
	clearedpublications      bool
	awards                   map[uuid.UUID]struct{}
	removedawards            map[uuid.UUID]struct{}
	clearedawards            bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddPersonalInfoIDs adds the "personal_info" edge to the PersonalInfo entity by ids.
func (m *UserMutation) AddPersonalInfoIDs(ids ...uuid.UUID) {
	if m.personal_info == nil {
		m.personal_info = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.personal_info[ids[i]] = struct{}{}
	}
}

// ClearPersonalInfo clears the "personal_info" edge to the PersonalInfo entity.
func (m *UserMutation) ClearPersonalInfo() {
	m.clearedpersonal_info = true
}

// PersonalInfoCleared reports if the "personal_info" edge to the PersonalInfo entity was cleared.
func (m *UserMutation) PersonalInfoCleared() bool {
	return m.clearedpersonal_info
}

// RemovePersonalInfoIDs removes the "personal_info" edge to the PersonalInfo entity by IDs.
func (m *UserMutation) RemovePersonalInfoIDs(ids ...uuid.UUID) {
	if m.removedpersonal_info == nil {
		m.removedpersonal_info = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.personal_info, ids[i])
		m.removedpersonal_info[ids[i]] = struct{}{}
	}
}

// RemovedPersonalInfo returns the removed IDs of the "personal_info" edge to the PersonalInfo entity.
func (m *UserMutation) RemovedPersonalInfoIDs() (ids []uuid.UUID) {
	for id := range m.removedpersonal_info {
		ids = append(ids, id)
	}
	return
}

// PersonalInfoIDs returns the "personal_info" edge IDs in the mutation.
func (m *UserMutation) PersonalInfoIDs() (ids []uuid.UUID) {
	for id := range m.personal_info {
		ids = append(ids, id)
	}
	return
}

// ResetPersonalInfo resets all changes to the "personal_info" edge.
func (m *UserMutation) ResetPersonalInfo() {
	m.personal_info = nil
	m.clearedpersonal_info = false
	m.removedpersonal_info = nil
}

// AddSocialLinkIDs adds the "social_links" edge to the SocialLink entity by ids.
func (m *UserMutation) AddSocialLinkIDs(ids ...uuid.UUID) {
	if m.social_links == nil {
		m.social_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.social_links[ids[i]] = struct{}{}
	}
}

// ClearSocialLinks clears the "social_links" edge to the SocialLink entity.
func (m *UserMutation) ClearSocialLinks() {
	m.clearedsocial_links = true
}

// SocialLinksCleared reports if the "social_links" edge to the SocialLink entity was cleared.
func (m *UserMutation) SocialLinksCleared() bool {
	return m.clearedsocial_links
}

// RemoveSocialLinkIDs removes the "social_links" edge to the SocialLink entity by IDs.
func (m *UserMutation) RemoveSocialLinkIDs(ids ...uuid.UUID) {
	if m.removedsocial_links == nil {
		m.removedsocial_links = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.social_links, ids[i])
		m.removedsocial_links[ids[i]] = struct{}{}
	}
}

// RemovedSocialLinks returns the removed IDs of the "social_links" edge to the SocialLink entity.
func (m *UserMutation) RemovedSocialLinksIDs() (ids []uuid.UUID) {
	for id := range m.removedsocial_links {
		ids = append(ids, id)
	}
	return
}

// SocialLinksIDs returns the "social_links" edge IDs in the mutation.
func (m *UserMutation) SocialLinksIDs() (ids []uuid.UUID) {
	for id := range m.social_links {
		ids = append(ids, id)
	}
	return
}

// ResetSocialLinks resets all changes to the "social_links" edge.
func (m *UserMutation) ResetSocialLinks() {
	m.social_links = nil
	m.clearedsocial_links = false
	m.removedsocial_links = nil
}

// AddEducationIDs adds the "education" edge to the Education entity by ids.
func (m *UserMutation) AddEducationIDs(ids ...uuid.UUID) {
	if m.education == nil {
		m.education = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.education[ids[i]] = struct{}{}
	}
}

// ClearEducation clears the "education" edge to the Education entity.
func (m *UserMutation) ClearEducation() {
	m.clearededucation = true
}

// EducationCleared reports if the "education" edge to the Education entity was cleared.
func (m *UserMutation) EducationCleared() bool {
	return m.clearededucation
}

// RemoveEducationIDs removes the "education" edge to the Education entity by IDs.
func (m *UserMutation) RemoveEducationIDs(ids ...uuid.UUID) {
	if m.removededucation == nil {
		m.removededucation = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.education, ids[i])
		m.removededucation[ids[i]] = struct{}{}
	}
}

// RemovedEducation returns the removed IDs of the "education" edge to the Education entity.
func (m *UserMutation) RemovedEducationIDs() (ids []uuid.UUID) {
	for id := range m.removededucation {
		ids = append(ids, id)
	}
	return
}

// EducationIDs returns the "education" edge IDs in the mutation.
func (m *UserMutation) EducationIDs() (ids []uuid.UUID) {
	for id := range m.education {
		ids = append(ids, id)
	}
	return
}

// ResetEducation resets all changes to the "education" edge.
func (m *UserMutation) ResetEducation() {
	m.education = nil
	m.clearededucation = false
	m.removededucation = nil
}

// AddWorkExperienceIDs adds the "work_experience" edge to the WorkExperience entity by ids.
func (m *UserMutation) AddWorkExperienceIDs(ids ...uuid.UUID) {
	if m.work_experience == nil {
		m.work_experience = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.work_experience[ids[i]] = struct{}{}
	}
}

// ClearWorkExperience clears the "work_experience" edge to the WorkExperience entity.
func (m *UserMutation) ClearWorkExperience() {
	m.clearedwork_experience = true
}

// WorkExperienceCleared reports if the "work_experience" edge to the WorkExperience entity was cleared.
func (m *UserMutation) WorkExperienceCleared() bool {
	return m.clearedwork_experience
}

// RemoveWorkExperienceIDs removes the "work_experience" edge to the WorkExperience entity by IDs.
func (m *UserMutation) RemoveWorkExperienceIDs(ids ...uuid.UUID) {
	if m.removedwork_experience == nil {
		m.removedwork_experience = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.work_experience, ids[i])
		m.removedwork_experience[ids[i]] = struct{}{}
	}
}

// RemovedWorkExperience returns the removed IDs of the "work_experience" edge to the WorkExperience entity.
func (m *UserMutation) RemovedWorkExperienceIDs() (ids []uuid.UUID) {
	for id := range m.removedwork_experience {
		ids = append(ids, id)
	}
	return
}

// WorkExperienceIDs returns the "work_experience" edge IDs in the mutation.
func (m *UserMutation) WorkExperienceIDs() (ids []uuid.UUID) {
	for id := range m.work_experience {
		ids = append(ids, id)
	}
	return
}

// ResetWorkExperience resets all changes to the "work_experience" edge.
func (m *UserMutation) ResetWorkExperience() {
	m.work_experience = nil
	m.clearedwork_experience = false
	m.removedwork_experience = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *UserMutation) AddProjectIDs(ids ...uuid.UUID) {
	if m.projects == nil {
		m.projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *UserMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *UserMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveProjectIDs(ids ...uuid.UUID) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *UserMutation) RemovedProjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *UserMutation) ProjectsIDs() (ids []uuid.UUID) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *UserMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddBlogPostIDs adds the "blog_posts" edge to the BlogPost entity by ids.
func (m *UserMutation) AddBlogPostIDs(ids ...uuid.UUID) {
	if m.blog_posts == nil {
		m.blog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_posts[ids[i]] = struct{}{}
	}
}

// ClearBlogPosts clears the "blog_posts" edge to the BlogPost entity.
func (m *UserMutation) ClearBlogPosts() {
	m.clearedblog_posts = true
}

// BlogPostsCleared reports if the "blog_posts" edge to the BlogPost entity was cleared.
func (m *UserMutation) BlogPostsCleared() bool {
	return m.clearedblog_posts
}

// RemoveBlogPostIDs removes the "blog_posts" edge to the BlogPost entity by IDs.
func (m *UserMutation) RemoveBlogPostIDs(ids ...uuid.UUID) {
	if m.removedblog_posts == nil {
		m.removedblog_posts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_posts, ids[i])
		m.removedblog_posts[ids[i]] = struct{}{}
	}
}

// RemovedBlogPosts returns the removed IDs of the "blog_posts" edge to the BlogPost entity.
func (m *UserMutation) RemovedBlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_posts {
		ids = append(ids, id)
	}
	return
}

// BlogPostsIDs returns the "blog_posts" edge IDs in the mutation.
func (m *UserMutation) BlogPostsIDs() (ids []uuid.UUID) {
	for id := range m.blog_posts {
		ids = append(ids, id)
	}
	return
}

// ResetBlogPosts resets all changes to the "blog_posts" edge.
func (m *UserMutation) ResetBlogPosts() {
	m.blog_posts = nil
	m.clearedblog_posts = false
	m.removedblog_posts = nil
}

// AddBlogSeriesIDs adds the "blog_series" edge to the BlogSeries entity by ids.
func (m *UserMutation) AddBlogSeriesIDs(ids ...uuid.UUID) {
	if m.blog_series == nil {
		m.blog_series = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.blog_series[ids[i]] = struct{}{}
	}
}

// ClearBlogSeries clears the "blog_series" edge to the BlogSeries entity.
func (m *UserMutation) ClearBlogSeries() {
	m.clearedblog_series = true
}

// BlogSeriesCleared reports if the "blog_series" edge to the BlogSeries entity was cleared.
func (m *UserMutation) BlogSeriesCleared() bool {
	return m.clearedblog_series
}

// RemoveBlogSeriesIDs removes the "blog_series" edge to the BlogSeries entity by IDs.
func (m *UserMutation) RemoveBlogSeriesIDs(ids ...uuid.UUID) {
	if m.removedblog_series == nil {
		m.removedblog_series = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.blog_series, ids[i])
		m.removedblog_series[ids[i]] = struct{}{}
	}
}

// RemovedBlogSeries returns the removed IDs of the "blog_series" edge to the BlogSeries entity.
func (m *UserMutation) RemovedBlogSeriesIDs() (ids []uuid.UUID) {
	for id := range m.removedblog_series {
		ids = append(ids, id)
	}
	return
}

// BlogSeriesIDs returns the "blog_series" edge IDs in the mutation.
func (m *UserMutation) BlogSeriesIDs() (ids []uuid.UUID) {
	for id := range m.blog_series {
		ids = append(ids, id)
	}
	return
}

// ResetBlogSeries resets all changes to the "blog_series" edge.
func (m *UserMutation) ResetBlogSeries() {
	m.blog_series = nil
	m.clearedblog_series = false
	m.removedblog_series = nil
}

// AddIdeaIDs adds the "ideas" edge to the Idea entity by ids.
func (m *UserMutation) AddIdeaIDs(ids ...uuid.UUID) {
	if m.ideas == nil {
		m.ideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.ideas[ids[i]] = struct{}{}
	}
}

// ClearIdeas clears the "ideas" edge to the Idea entity.
func (m *UserMutation) ClearIdeas() {
	m.clearedideas = true
}

// IdeasCleared reports if the "ideas" edge to the Idea entity was cleared.
func (m *UserMutation) IdeasCleared() bool {
	return m.clearedideas
}

// RemoveIdeaIDs removes the "ideas" edge to the Idea entity by IDs.
func (m *UserMutation) RemoveIdeaIDs(ids ...uuid.UUID) {
	if m.removedideas == nil {
		m.removedideas = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.ideas, ids[i])
		m.removedideas[ids[i]] = struct{}{}
	}
}

// RemovedIdeas returns the removed IDs of the "ideas" edge to the Idea entity.
func (m *UserMutation) RemovedIdeasIDs() (ids []uuid.UUID) {
	for id := range m.removedideas {
		ids = append(ids, id)
	}
	return
}

// IdeasIDs returns the "ideas" edge IDs in the mutation.
func (m *UserMutation) IdeasIDs() (ids []uuid.UUID) {
	for id := range m.ideas {
		ids = append(ids, id)
	}
	return
}

// ResetIdeas resets all changes to the "ideas" edge.
func (m *UserMutation) ResetIdeas() {
	m.ideas = nil
	m.clearedideas = false
	m.removedideas = nil
}

// AddResearchProjectIDs adds the "research_projects" edge to the ResearchProject entity by ids.
func (m *UserMutation) AddResearchProjectIDs(ids ...uuid.UUID) {
	if m.research_projects == nil {
		m.research_projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.research_projects[ids[i]] = struct{}{}
	}
}

// ClearResearchProjects clears the "research_projects" edge to the ResearchProject entity.
func (m *UserMutation) ClearResearchProjects() {
	m.clearedresearch_projects = true
}

// ResearchProjectsCleared reports if the "research_projects" edge to the ResearchProject entity was cleared.
func (m *UserMutation) ResearchProjectsCleared() bool {
	return m.clearedresearch_projects
}

// RemoveResearchProjectIDs removes the "research_projects" edge to the ResearchProject entity by IDs.
func (m *UserMutation) RemoveResearchProjectIDs(ids ...uuid.UUID) {
	if m.removedresearch_projects == nil {
		m.removedresearch_projects = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.research_projects, ids[i])
		m.removedresearch_projects[ids[i]] = struct{}{}
	}
}

// RemovedResearchProjects returns the removed IDs of the "research_projects" edge to the ResearchProject entity.
func (m *UserMutation) RemovedResearchProjectsIDs() (ids []uuid.UUID) {
	for id := range m.removedresearch_projects {
		ids = append(ids, id)
	}
	return
}

// ResearchProjectsIDs returns the "research_projects" edge IDs in the mutation.
func (m *UserMutation) ResearchProjectsIDs() (ids []uuid.UUID) {
	for id := range m.research_projects {
		ids = append(ids, id)
	}
	return
}

// ResetResearchProjects resets all changes to the "research_projects" edge.
func (m *UserMutation) ResetResearchProjects() {
	m.research_projects = nil
	m.clearedresearch_projects = false
	m.removedresearch_projects = nil
}

// AddPublicationIDs adds the "publications" edge to the Publication entity by ids.
func (m *UserMutation) AddPublicationIDs(ids ...uuid.UUID) {
	if m.publications == nil {
		m.publications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.publications[ids[i]] = struct{}{}
	}
}

// ClearPublications clears the "publications" edge to the Publication entity.
func (m *UserMutation) ClearPublications() {
	m.clearedpublications = true
}

// PublicationsCleared reports if the "publications" edge to the Publication entity was cleared.
func (m *UserMutation) PublicationsCleared() bool {
	return m.clearedpublications
}

// RemovePublicationIDs removes the "publications" edge to the Publication entity by IDs.
func (m *UserMutation) RemovePublicationIDs(ids ...uuid.UUID) {
	if m.removedpublications == nil {
		m.removedpublications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.publications, ids[i])
		m.removedpublications[ids[i]] = struct{}{}
	}
}

// RemovedPublications returns the removed IDs of the "publications" edge to the Publication entity.
func (m *UserMutation) RemovedPublicationsIDs() (ids []uuid.UUID) {
	for id := range m.removedpublications {
		ids = append(ids, id)
	}
	return
}

// PublicationsIDs returns the "publications" edge IDs in the mutation.
func (m *UserMutation) PublicationsIDs() (ids []uuid.UUID) {
	for id := range m.publications {
		ids = append(ids, id)
	}
	return
}

// ResetPublications resets all changes to the "publications" edge.
func (m *UserMutation) ResetPublications() {
	m.publications = nil
	m.clearedpublications = false
	m.removedpublications = nil
}

// AddAwardIDs adds the "awards" edge to the Award entity by ids.
func (m *UserMutation) AddAwardIDs(ids ...uuid.UUID) {
	if m.awards == nil {
		m.awards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.awards[ids[i]] = struct{}{}
	}
}

// ClearAwards clears the "awards" edge to the Award entity.
func (m *UserMutation) ClearAwards() {
	m.clearedawards = true
}

// AwardsCleared reports if the "awards" edge to the Award entity was cleared.
func (m *UserMutation) AwardsCleared() bool {
	return m.clearedawards
}

// RemoveAwardIDs removes the "awards" edge to the Award entity by IDs.
func (m *UserMutation) RemoveAwardIDs(ids ...uuid.UUID) {
	if m.removedawards == nil {
		m.removedawards = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.awards, ids[i])
		m.removedawards[ids[i]] = struct{}{}
	}
}

// RemovedAwards returns the removed IDs of the "awards" edge to the Award entity.
func (m *UserMutation) RemovedAwardsIDs() (ids []uuid.UUID) {
	for id := range m.removedawards {
		ids = append(ids, id)
	}
	return
}

// AwardsIDs returns the "awards" edge IDs in the mutation.
func (m *UserMutation) AwardsIDs() (ids []uuid.UUID) {
	for id := range m.awards {
		ids = append(ids, id)
	}
	return
}

// ResetAwards resets all changes to the "awards" edge.
func (m *UserMutation) ResetAwards() {
	m.awards = nil
	m.clearedawards = false
	m.removedawards = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldBio:
		return m.Bio()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.personal_info != nil {
		edges = append(edges, user.EdgePersonalInfo)
	}
	if m.social_links != nil {
		edges = append(edges, user.EdgeSocialLinks)
	}
	if m.education != nil {
		edges = append(edges, user.EdgeEducation)
	}
	if m.work_experience != nil {
		edges = append(edges, user.EdgeWorkExperience)
	}
	if m.projects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.blog_posts != nil {
		edges = append(edges, user.EdgeBlogPosts)
	}
	if m.blog_series != nil {
		edges = append(edges, user.EdgeBlogSeries)
	}
	if m.ideas != nil {
		edges = append(edges, user.EdgeIdeas)
	}
	if m.research_projects != nil {
		edges = append(edges, user.EdgeResearchProjects)
	}
	if m.publications != nil {
		edges = append(edges, user.EdgePublications)
	}
	if m.awards != nil {
		edges = append(edges, user.EdgeAwards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePersonalInfo:
		ids := make([]ent.Value, 0, len(m.personal_info))
		for id := range m.personal_info {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSocialLinks:
		ids := make([]ent.Value, 0, len(m.social_links))
		for id := range m.social_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEducation:
		ids := make([]ent.Value, 0, len(m.education))
		for id := range m.education {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkExperience:
		ids := make([]ent.Value, 0, len(m.work_experience))
		for id := range m.work_experience {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.blog_posts))
		for id := range m.blog_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlogSeries:
		ids := make([]ent.Value, 0, len(m.blog_series))
		for id := range m.blog_series {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdeas:
		ids := make([]ent.Value, 0, len(m.ideas))
		for id := range m.ideas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResearchProjects:
		ids := make([]ent.Value, 0, len(m.research_projects))
		for id := range m.research_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePublications:
		ids := make([]ent.Value, 0, len(m.publications))
		for id := range m.publications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAwards:
		ids := make([]ent.Value, 0, len(m.awards))
		for id := range m.awards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedpersonal_info != nil {
		edges = append(edges, user.EdgePersonalInfo)
	}
	if m.removedsocial_links != nil {
		edges = append(edges, user.EdgeSocialLinks)
	}
	if m.removededucation != nil {
		edges = append(edges, user.EdgeEducation)
	}
	if m.removedwork_experience != nil {
		edges = append(edges, user.EdgeWorkExperience)
	}
	if m.removedprojects != nil {
		edges = append(edges, user.EdgeProjects)
	}
	if m.removedblog_posts != nil {
		edges = append(edges, user.EdgeBlogPosts)
	}
	if m.removedblog_series != nil {
		edges = append(edges, user.EdgeBlogSeries)
	}
	if m.removedideas != nil {
		edges = append(edges, user.EdgeIdeas)
	}
	if m.removedresearch_projects != nil {
		edges = append(edges, user.EdgeResearchProjects)
	}
	if m.removedpublications != nil {
		edges = append(edges, user.EdgePublications)
	}
	if m.removedawards != nil {
		edges = append(edges, user.EdgeAwards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePersonalInfo:
		ids := make([]ent.Value, 0, len(m.removedpersonal_info))
		for id := range m.removedpersonal_info {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSocialLinks:
		ids := make([]ent.Value, 0, len(m.removedsocial_links))
		for id := range m.removedsocial_links {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEducation:
		ids := make([]ent.Value, 0, len(m.removededucation))
		for id := range m.removededucation {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkExperience:
		ids := make([]ent.Value, 0, len(m.removedwork_experience))
		for id := range m.removedwork_experience {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlogPosts:
		ids := make([]ent.Value, 0, len(m.removedblog_posts))
		for id := range m.removedblog_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlogSeries:
		ids := make([]ent.Value, 0, len(m.removedblog_series))
		for id := range m.removedblog_series {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeIdeas:
		ids := make([]ent.Value, 0, len(m.removedideas))
		for id := range m.removedideas {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResearchProjects:
		ids := make([]ent.Value, 0, len(m.removedresearch_projects))
		for id := range m.removedresearch_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePublications:
		ids := make([]ent.Value, 0, len(m.removedpublications))
		for id := range m.removedpublications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAwards:
		ids := make([]ent.Value, 0, len(m.removedawards))
		for id := range m.removedawards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedpersonal_info {
		edges = append(edges, user.EdgePersonalInfo)
	}
	if m.clearedsocial_links {
		edges = append(edges, user.EdgeSocialLinks)
	}
	if m.clearededucation {
		edges = append(edges, user.EdgeEducation)
	}
	if m.clearedwork_experience {
		edges = append(edges, user.EdgeWorkExperience)
	}
	if m.clearedprojects {
		edges = append(edges, user.EdgeProjects)
	}
	if m.clearedblog_posts {
		edges = append(edges, user.EdgeBlogPosts)
	}
	if m.clearedblog_series {
		edges = append(edges, user.EdgeBlogSeries)
	}
	if m.clearedideas {
		edges = append(edges, user.EdgeIdeas)
	}
	if m.clearedresearch_projects {
		edges = append(edges, user.EdgeResearchProjects)
	}
	if m.clearedpublications {
		edges = append(edges, user.EdgePublications)
	}
	if m.clearedawards {
		edges = append(edges, user.EdgeAwards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePersonalInfo:
		return m.clearedpersonal_info
	case user.EdgeSocialLinks:
		return m.clearedsocial_links
	case user.EdgeEducation:
		return m.clearededucation
	case user.EdgeWorkExperience:
		return m.clearedwork_experience
	case user.EdgeProjects:
		return m.clearedprojects
	case user.EdgeBlogPosts:
		return m.clearedblog_posts
	case user.EdgeBlogSeries:
		return m.clearedblog_series
	case user.EdgeIdeas:
		return m.clearedideas
	case user.EdgeResearchProjects:
		return m.clearedresearch_projects
	case user.EdgePublications:
		return m.clearedpublications
	case user.EdgeAwards:
		return m.clearedawards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePersonalInfo:
		m.ResetPersonalInfo()
		return nil
	case user.EdgeSocialLinks:
		m.ResetSocialLinks()
		return nil
	case user.EdgeEducation:
		m.ResetEducation()
		return nil
	case user.EdgeWorkExperience:
		m.ResetWorkExperience()
		return nil
	case user.EdgeProjects:
		m.ResetProjects()
		return nil
	case user.EdgeBlogPosts:
		m.ResetBlogPosts()
		return nil
	case user.EdgeBlogSeries:
		m.ResetBlogSeries()
		return nil
	case user.EdgeIdeas:
		m.ResetIdeas()
		return nil
	case user.EdgeResearchProjects:
		m.ResetResearchProjects()
		return nil
	case user.EdgePublications:
		m.ResetPublications()
		return nil
	case user.EdgeAwards:
		m.ResetAwards()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkExperienceMutation represents an operation that mutates the WorkExperience nodes in the graph.
type WorkExperienceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	company          *string
	position         *string
	start_date       *time.Time
	end_date         *time.Time
	is_current       *bool
	location         *string
	company_website  *string
	company_logo_url *string
	sort_order       *int
	addsort_order    *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*WorkExperience, error)
	predicates       []predicate.WorkExperience
}

var _ ent.Mutation = (*WorkExperienceMutation)(nil)

// workexperienceOption allows management of the mutation configuration using functional options.
type workexperienceOption func(*WorkExperienceMutation)

// newWorkExperienceMutation creates new mutation for the WorkExperience entity.
func newWorkExperienceMutation(c config, op Op, opts ...workexperienceOption) *WorkExperienceMutation {
	m := &WorkExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkExperienceID sets the ID field of the mutation.
func withWorkExperienceID(id uuid.UUID) workexperienceOption {
	return func(m *WorkExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkExperience
		)
		m.oldValue = func(ctx context.Context) (*WorkExperience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkExperience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkExperience sets the old WorkExperience of the mutation.
func withWorkExperience(node *WorkExperience) workexperienceOption {
	return func(m *WorkExperienceMutation) {
		m.oldValue = func(context.Context) (*WorkExperience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkExperience entities.
func (m *WorkExperienceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkExperienceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkExperienceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkExperience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompany sets the "company" field.
func (m *WorkExperienceMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *WorkExperienceMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ResetCompany resets all changes to the "company" field.
func (m *WorkExperienceMutation) ResetCompany() {
	m.company = nil
}

// SetPosition sets the "position" field.
func (m *WorkExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *WorkExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *WorkExperienceMutation) ResetPosition() {
	m.position = nil
}

// SetStartDate sets the "start_date" field.
func (m *WorkExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *WorkExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *WorkExperienceMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[workexperience.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *WorkExperienceMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *WorkExperienceMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, workexperience.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *WorkExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *WorkExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *WorkExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[workexperience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *WorkExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *WorkExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, workexperience.FieldEndDate)
}

// SetIsCurrent sets the "is_current" field.
func (m *WorkExperienceMutation) SetIsCurrent(b bool) {
	m.is_current = &b
}

// IsCurrent returns the value of the "is_current" field in the mutation.
func (m *WorkExperienceMutation) IsCurrent() (r bool, exists bool) {
	v := m.is_current
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCurrent returns the old "is_current" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldIsCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCurrent: %w", err)
	}
	return oldValue.IsCurrent, nil
}

// ResetIsCurrent resets all changes to the "is_current" field.
func (m *WorkExperienceMutation) ResetIsCurrent() {
	m.is_current = nil
}

// SetLocation sets the "location" field.
func (m *WorkExperienceMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *WorkExperienceMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *WorkExperienceMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[workexperience.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *WorkExperienceMutation) LocationCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *WorkExperienceMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, workexperience.FieldLocation)
}

// SetCompanyWebsite sets the "company_website" field.
func (m *WorkExperienceMutation) SetCompanyWebsite(s string) {
	m.company_website = &s
}

// CompanyWebsite returns the value of the "company_website" field in the mutation.
func (m *WorkExperienceMutation) CompanyWebsite() (r string, exists bool) {
	v := m.company_website
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyWebsite returns the old "company_website" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompanyWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyWebsite: %w", err)
	}
	return oldValue.CompanyWebsite, nil
}

// ClearCompanyWebsite clears the value of the "company_website" field.
func (m *WorkExperienceMutation) ClearCompanyWebsite() {
	m.company_website = nil
	m.clearedFields[workexperience.FieldCompanyWebsite] = struct{}{}
}

// CompanyWebsiteCleared returns if the "company_website" field was cleared in this mutation.
func (m *WorkExperienceMutation) CompanyWebsiteCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldCompanyWebsite]
	return ok
}

// ResetCompanyWebsite resets all changes to the "company_website" field.
func (m *WorkExperienceMutation) ResetCompanyWebsite() {
	m.company_website = nil
	delete(m.clearedFields, workexperience.FieldCompanyWebsite)
}

// SetCompanyLogoURL sets the "company_logo_url" field.
func (m *WorkExperienceMutation) SetCompanyLogoURL(s string) {
	m.company_logo_url = &s
}

// CompanyLogoURL returns the value of the "company_logo_url" field in the mutation.
func (m *WorkExperienceMutation) CompanyLogoURL() (r string, exists bool) {
	v := m.company_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyLogoURL returns the old "company_logo_url" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCompanyLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyLogoURL: %w", err)
	}
	return oldValue.CompanyLogoURL, nil
}

// ClearCompanyLogoURL clears the value of the "company_logo_url" field.
func (m *WorkExperienceMutation) ClearCompanyLogoURL() {
	m.company_logo_url = nil
	m.clearedFields[workexperience.FieldCompanyLogoURL] = struct{}{}
}

// CompanyLogoURLCleared returns if the "company_logo_url" field was cleared in this mutation.
func (m *WorkExperienceMutation) CompanyLogoURLCleared() bool {
	_, ok := m.clearedFields[workexperience.FieldCompanyLogoURL]
	return ok
}

// ResetCompanyLogoURL resets all changes to the "company_logo_url" field.
func (m *WorkExperienceMutation) ResetCompanyLogoURL() {
	m.company_logo_url = nil
	delete(m.clearedFields, workexperience.FieldCompanyLogoURL)
}

// SetSortOrder sets the "sort_order" field.
func (m *WorkExperienceMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *WorkExperienceMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *WorkExperienceMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *WorkExperienceMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *WorkExperienceMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkExperienceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkExperienceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkExperienceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkExperienceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkExperience entity.
// If the WorkExperience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkExperienceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WorkExperienceMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkExperienceMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkExperienceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WorkExperienceMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkExperienceMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkExperienceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WorkExperienceMutation builder.
func (m *WorkExperienceMutation) Where(ps ...predicate.WorkExperience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkExperience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkExperience).
func (m *WorkExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkExperienceMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.company != nil {
		fields = append(fields, workexperience.FieldCompany)
	}
	if m.position != nil {
		fields = append(fields, workexperience.FieldPosition)
	}
	if m.start_date != nil {
		fields = append(fields, workexperience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, workexperience.FieldEndDate)
	}
	if m.is_current != nil {
		fields = append(fields, workexperience.FieldIsCurrent)
	}
	if m.location != nil {
		fields = append(fields, workexperience.FieldLocation)
	}
	if m.company_website != nil {
		fields = append(fields, workexperience.FieldCompanyWebsite)
	}
	if m.company_logo_url != nil {
		fields = append(fields, workexperience.FieldCompanyLogoURL)
	}
	if m.sort_order != nil {
		fields = append(fields, workexperience.FieldSortOrder)
	}
	if m.created_at != nil {
		fields = append(fields, workexperience.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workexperience.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workexperience.FieldCompany:
		return m.Company()
	case workexperience.FieldPosition:
		return m.Position()
	case workexperience.FieldStartDate:
		return m.StartDate()
	case workexperience.FieldEndDate:
		return m.EndDate()
	case workexperience.FieldIsCurrent:
		return m.IsCurrent()
	case workexperience.FieldLocation:
		return m.Location()
	case workexperience.FieldCompanyWebsite:
		return m.CompanyWebsite()
	case workexperience.FieldCompanyLogoURL:
		return m.CompanyLogoURL()
	case workexperience.FieldSortOrder:
		return m.SortOrder()
	case workexperience.FieldCreatedAt:
		return m.CreatedAt()
	case workexperience.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workexperience.FieldCompany:
		return m.OldCompany(ctx)
	case workexperience.FieldPosition:
		return m.OldPosition(ctx)
	case workexperience.FieldStartDate:
		return m.OldStartDate(ctx)
	case workexperience.FieldEndDate:
		return m.OldEndDate(ctx)
	case workexperience.FieldIsCurrent:
		return m.OldIsCurrent(ctx)
	case workexperience.FieldLocation:
		return m.OldLocation(ctx)
	case workexperience.FieldCompanyWebsite:
		return m.OldCompanyWebsite(ctx)
	case workexperience.FieldCompanyLogoURL:
		return m.OldCompanyLogoURL(ctx)
	case workexperience.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case workexperience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workexperience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkExperience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workexperience.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case workexperience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case workexperience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case workexperience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case workexperience.FieldIsCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCurrent(v)
		return nil
	case workexperience.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case workexperience.FieldCompanyWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyWebsite(v)
		return nil
	case workexperience.FieldCompanyLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyLogoURL(v)
		return nil
	case workexperience.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case workexperience.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workexperience.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkExperienceMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, workexperience.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workexperience.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workexperience.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown WorkExperience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workexperience.FieldStartDate) {
		fields = append(fields, workexperience.FieldStartDate)
	}
	if m.FieldCleared(workexperience.FieldEndDate) {
		fields = append(fields, workexperience.FieldEndDate)
	}
	if m.FieldCleared(workexperience.FieldLocation) {
		fields = append(fields, workexperience.FieldLocation)
	}
	if m.FieldCleared(workexperience.FieldCompanyWebsite) {
		fields = append(fields, workexperience.FieldCompanyWebsite)
	}
	if m.FieldCleared(workexperience.FieldCompanyLogoURL) {
		fields = append(fields, workexperience.FieldCompanyLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkExperienceMutation) ClearField(name string) error {
	switch name {
	case workexperience.FieldStartDate:
		m.ClearStartDate()
		return nil
	case workexperience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case workexperience.FieldLocation:
		m.ClearLocation()
		return nil
	case workexperience.FieldCompanyWebsite:
		m.ClearCompanyWebsite()
		return nil
	case workexperience.FieldCompanyLogoURL:
		m.ClearCompanyLogoURL()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkExperienceMutation) ResetField(name string) error {
	switch name {
	case workexperience.FieldCompany:
		m.ResetCompany()
		return nil
	case workexperience.FieldPosition:
		m.ResetPosition()
		return nil
	case workexperience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case workexperience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case workexperience.FieldIsCurrent:
		m.ResetIsCurrent()
		return nil
	case workexperience.FieldLocation:
		m.ResetLocation()
		return nil
	case workexperience.FieldCompanyWebsite:
		m.ResetCompanyWebsite()
		return nil
	case workexperience.FieldCompanyLogoURL:
		m.ResetCompanyLogoURL()
		return nil
	case workexperience.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case workexperience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workexperience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, workexperience.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workexperience.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, workexperience.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case workexperience.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkExperienceMutation) ClearEdge(name string) error {
	switch name {
	case workexperience.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkExperienceMutation) ResetEdge(name string) error {
	switch name {
	case workexperience.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WorkExperience edge %s", name)
}
